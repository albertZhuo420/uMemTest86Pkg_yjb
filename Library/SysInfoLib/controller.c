// PassMark MemTest86
//
// Copyright (c) 2016
//   This software is the confidential and proprietary information of PassMark
//   Software Pty. Ltd. ("Confidential Information").  You shall not disclose
//   such Confidential Information and shall use it only in accordance with
//   the terms of the license agreement you entered into with PassMark
//   Software.
//
// Program:
//   MemTest86
//
// Module:
//   controller.c
//
// Author(s):
//   Keith Mah
//
// Description:
//   Functions for detecting ECC support and polling ECC errors
//
//   Based on the original MemTest86 source code by Chris Brady, cbrady@sgi.com

#ifdef WIN32
#include <intrin.h>
#include <stdio.h>
#include <stdarg.h>
#include <Windows.h>
#include "controller.h"
#include "DirectPort_DirectIo.h"
#include "PCI.h"
#include "Uefi.h"
#include "Cpuid.h"
#include "SysInfoPrivate.h"

#if _MSC_VER
#define DISABLE_OPTIMISATIONS() __pragma(optimize("", off))
#define ENABLE_OPTIMISATIONS() __pragma(optimize("", on))
#elif __GNUC__
#define DISABLE_OPTIMISATIONS() \
    _Pragma("GCC push_options") \
        _Pragma("GCC optimize (\"O0\")")
#define ENABLE_OPTIMISATIONS() _Pragma("GCC pop_options")
#else
#error new compiler
#endif

#define ARRAY_SIZE(Array) (sizeof(Array) / sizeof((Array)[0]))
#define ABS(a) \
    (((a) < 0) ? (-(a)) : (a))

#define IN
#define OUT
#define OPTIONAL
#define LShiftU64(Operand, Count) ((unsigned long long)(Operand) << (Count))
#define RShiftU64(Operand, Count) ((unsigned long long)(Operand) >> (Count))
#define DivU64x32(Dividend, Divisor) ((Dividend) / (Divisor))
#define DivS64x64Remainder(Dividend, Divisor, Remainder) ((Dividend) / (Divisor))
#define MultS64x64(Multiplicand, Multiplier) ((Multiplicand) * (Multiplier))
#define MtSupportReportECCError
#define MtSupportReportECCError_dimm
#define MtSupportReportIBECCError
#define MtSupportReportIBECCError_dimm
#define MtSupportReportECCErrorType_dimm
#define MPSupportGetBspId() (0)
#define MPSupportSwitchBSP
#define MPSupportSwitchPkg(Pkg) (EFI_SUCCESS)
#define MPSupportGetNumPackages() (1)

static unsigned long long clks_msec;

static inline UINT64 MtSupportReadTSC()
{
    if (clks_msec == 0)
    {
        LARGE_INTEGER liFreq = {};
        QueryPerformanceFrequency(&liFreq);
        clks_msec = liFreq.QuadPart / 1000;
    }

    LARGE_INTEGER liCntr = {};
    QueryPerformanceCounter(&liCntr);
    return liCntr.QuadPart;
}

static void MtSupportDebugWriteLine(char *str)
{
    TCHAR wszBuf[BUF_SIZE];
    MultiByteToWideChar(CP_UTF8, 0, str, -1, wszBuf, sizeof(wszBuf) / sizeof(wszBuf[0]) - 1);
    SysInfo_DebugLogWriteLine(wszBuf);
}

static inline void MtSupportDebugWriteLine(wchar_t *str)
{
    SysInfo_DebugLogWriteLine(str);
}

typedef void *MT_HANDLE;
#define DEBUG_FILE_HANDLE ((MT_HANDLE) - 1)

void AsciiFPrint(
    IN MT_HANDLE FileHandle,
    IN CONST CHAR8 *FormatString,
    ...)
{
    va_list Marker;
    UINTN NumberOfPrinted;
    CHAR8 szBuffer[VLONG_STRING_LEN];

    va_start(Marker, FormatString);
    NumberOfPrinted = vsprintf_s(szBuffer, sizeof(szBuffer), FormatString, Marker);
    va_end(Marker);

    if (FileHandle == DEBUG_FILE_HANDLE)
    {
        if (szBuffer[strlen(szBuffer) - 1] == '\n')
            szBuffer[strlen(szBuffer) - 1] = '\0';

        MtSupportDebugWriteLine(szBuffer);
    }
}

int AsciiSPrint(wchar_t *buf, int bufsize, const char *fmt, ...)
{
    char mbbuf[BUF_SIZE];
    va_list ap; // variable list

    va_start(ap, fmt);
    vsprintf(mbbuf, fmt, ap);
    va_end(ap);
    return MultiByteToWideChar(CP_UTF8, 0, mbbuf, -1, buf, bufsize / sizeof(buf[0]) - 1);
}

inline void AsciiStrCat(wchar_t *buf, const char *str)
{
    TCHAR wszBuf[BUF_SIZE];
    MultiByteToWideChar(CP_UTF8, 0, str, -1, wszBuf, sizeof(wszBuf) / sizeof(wszBuf[0]) - 1);
    wcscat(buf, wszBuf);
}

inline void AsciiStrCat(wchar_t *buf, const wchar_t *str)
{
    wcscat(buf, str);
}

inline void AsciiStrCatS(wchar_t *buf, size_t bufsize, const char *str)
{
    TCHAR wszBuf[BUF_SIZE];
    MultiByteToWideChar(CP_UTF8, 0, str, -1, wszBuf, sizeof(wszBuf) / sizeof(wszBuf[0]) - 1);
    wcscat_s(buf, bufsize / sizeof(buf[0]), wszBuf);
}

#define I64HEXFMT "%016llx"
#define MBSTRFMT "%hs"
#define SetMem(buf, size, val) memset(buf, val, size)
#define CopyMem memcpy
#define CompareMem memcmp
#define AllocateZeroPool(size) (unsigned char *)calloc(1, size)
#define ReallocatePool(OldSize, NewSize, OldBuffer) realloc(OldBuffer, NewSize)
#define FreePool(Buffer) free(Buffer)

static wchar_t gBuffer[BUF_SIZE];

enum
{
    ECC_TYPE_READWRITE,
    ECC_TYPE_SCRUB,
    ECC_TYPE_INBAND
};

static struct cpu_ident cpu_id;

DWORD MmioRead32(UINT_PTR Address)
{
    DWORD Data = 0;
    // Ask driver to map MMIO base address to pointer we can use
    BYTE *pbLinAddr = NULL;
    tagPhys32Struct Phys32Struct = {0};
    // HANDLE		hPhysicalMemory	= NULL;
    pbLinAddr = MapPhysToLin((PBYTE)Address, 4, &Phys32Struct);
    if (pbLinAddr)
    {
        Data = *((DWORD *)pbLinAddr);

        UnmapPhysicalMemory(&Phys32Struct, pbLinAddr, 4);
    }
    return Data;
}

ULONGLONG MmioRead64(UINT_PTR Address)
{
    ULONGLONG Data = 0;
    // Ask driver to map MMIO base address to pointer we can use
    BYTE *pbLinAddr = NULL;
    tagPhys32Struct Phys32Struct = {0};
    // HANDLE		hPhysicalMemory	= NULL;
    pbLinAddr = MapPhysToLin((PBYTE)Address, 8, &Phys32Struct);
    if (pbLinAddr)
    {
        Data = *((ULONGLONG *)pbLinAddr);

        UnmapPhysicalMemory(&Phys32Struct, pbLinAddr, 4);
    }
    return Data;
}

void MmioWrite32(UINT_PTR Address, DWORD Data)
{
    // Ask driver to map MMIO base address to pointer we can use
    BYTE *pbLinAddr = NULL;
    tagPhys32Struct Phys32Struct = {0};
    // HANDLE		hPhysicalMemory	= NULL;
    pbLinAddr = MapPhysToLin((PBYTE)Address, 4, &Phys32Struct, TRUE);
    if (pbLinAddr)
    {
        *((DWORD *)pbLinAddr) = Data;

        UnmapPhysicalMemory(&Phys32Struct, pbLinAddr, 4);
    }
}

void MmioWrite64(UINT_PTR Address, ULONGLONG Data)
{
    // Ask driver to map MMIO base address to pointer we can use
    BYTE *pbLinAddr = NULL;
    tagPhys32Struct Phys32Struct = {0};
    // HANDLE		hPhysicalMemory	= NULL;
    pbLinAddr = MapPhysToLin((PBYTE)Address, 8, &Phys32Struct, TRUE);
    if (pbLinAddr)
    {
        *((ULONGLONG *)pbLinAddr) = Data;

        UnmapPhysicalMemory(&Phys32Struct, pbLinAddr, 4);
    }
}

#else // For MemTest86
#include <Uefi.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/BaseLib.h>
#include <Library/Cpuid.h>
#include <Library/PciLib.h>
#include <Library/IoLib.h>

#include <Library/MemTestSupportLib.h>
#include <Library/MPSupportLib.h>
#include <uMemTest86.h>

#include "controller.h"
#include <SysInfoLib/pci.h>
#include <Library/OKN/OknMemTestLib.h>

#define Sleep(x) gBS->Stall(x * 1000)

#define I64HEXFMT "%016lx"
#define MBSTRFMT "%a"

typedef UINTN PVOID;

extern struct cpu_ident cpu_id;
extern UINTN clks_msec;

#endif

#define PCI_VENDOR_ID 0x00 /* 16 bits */
#define PCI_DEVICE_ID 0x02 /* 16 bits */

#define MSR_IA32_LT_UNLOCK_MEMORY 0x2e6
#define MSR_IA32_LT_LOCK_MEMORY 0x2e7

#define rdmsr(msr, vallo, valhi) _rdmsr(msr, &vallo, &valhi)

#define BitExtract(dwReg, wIndexHigh, dwIndexLow) ((dwReg) >> (dwIndexLow) & ((1 << ((wIndexHigh) - (dwIndexLow) + 1)) - 1))
#define BitExtractULL(dwReg, wIndexHigh, dwIndexLow) (RShiftU64((UINT64)(dwReg), dwIndexLow) & (LShiftU64(1, ((wIndexHigh) - (dwIndexLow) + 1)) - 1))

static __inline unsigned char numsetbits32(unsigned int i)
{
    // Java: use >>> instead of >>
    // C or C++: use uint32_t
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}

typedef unsigned long ulong;

#if 0
int col, col2;
int nhm_bus = 0x3F;
#endif

void _cpuid(IN UINT32 Index,
            OUT UINT32 *RegisterEax, OPTIONAL OUT UINT32 *RegisterEbx, OPTIONAL OUT UINT32 *RegisterEcx, OPTIONAL OUT UINT32 *RegisterEdx OPTIONAL)

{
#ifdef WIN32
    int CPUInfo[4] = {0};

#if !defined(_M_ARM) && !defined(_M_ARM64)
    __cpuid(CPUInfo, Index);
#endif

    if (RegisterEax)
        *RegisterEax = CPUInfo[0];
    if (RegisterEbx)
        *RegisterEbx = CPUInfo[1];
    if (RegisterEcx)
        *RegisterEcx = CPUInfo[2];
    if (RegisterEdx)
        *RegisterEdx = CPUInfo[3];

#else
#if defined(MDE_CPU_IA32) || defined(MDE_CPU_X64)
    AsmCpuid(Index, RegisterEax, RegisterEbx, RegisterEcx, RegisterEdx);
#endif
#endif
}

void _invdcache()
{
#ifdef WIN32
#if !defined(_M_ARM) && !defined(_M_ARM64)
    __wbinvd();
#endif
#else
#if defined(MDE_CPU_IA32) || defined(MDE_CPU_X64)
    AsmWbinvd();
#endif
#endif
}
// Read MSR
void _rdmsr64(UINT32 msr, UINT64 *val)
{
#ifdef WIN32
    int iMSR = msr;
    ULONGLONG ullMSRResult = 0;
    DWORD dwBytesReturned = 0;
    if (DeviceIoControl(g_hDirectIO, IOCTL_DIRECTIO_READMSR, &iMSR, sizeof(iMSR), &ullMSRResult, sizeof(ullMSRResult), &dwBytesReturned, NULL))
    {
        *val = ullMSRResult;
    }
#else
#if defined(MDE_CPU_IA32) || defined(MDE_CPU_X64)
    *val = AsmReadMsr64(msr);
#endif
#endif
}

// Write MSR
void _wrmsr64(UINT32 msr, UINT64 val)
{
#ifdef WIN32
    tagWriteMSR WriteMSR;
    ULONGLONG ullValue = 0;
    DWORD dwBytesReturned = 0;

    WriteMSR.dwMSR = msr;
    WriteMSR.ullValue = val;
    if (DeviceIoControl(g_hDirectIO, IOCTL_DIRECTIO_WRITEMSR, &WriteMSR, sizeof(WriteMSR), &ullValue, sizeof(ullValue), &dwBytesReturned, NULL))
    {
    }
#else
#if defined(MDE_CPU_IA32) || defined(MDE_CPU_X64)
    AsmWriteMsr64(msr, val);
#endif
#endif
}

// Read MSR
void _rdmsr(UINT32 msr, UINT32 *vallo, UINT32 *valhi)
{
    UINT64 val;
    _rdmsr64(msr, &val);
    *vallo = val & 0xFFFFFFFF;
    *valhi = (val >> 32) & 0xFFFFFFFF;
}

// Write MSR
void wrmsr(UINT32 msr, UINT32 vallo, UINT32 valhi)
{
    UINT64 val = LShiftU64(valhi, 32) | vallo;
    _wrmsr64(msr, val);
}

// Read 32-bit MMIO
unsigned int readmmio32(unsigned int *addr)
{
    return (unsigned int)MmioRead32((UINTN)addr);
}

// Read 64-bit MMIO
unsigned long long readmmio64(unsigned int *addr)
{
    return (unsigned long long)MmioRead64((UINTN)addr);
}

// Write 32-bit MMIO
void writemmio32(unsigned int *addr, unsigned int value)
{
    MmioWrite32((UINTN)addr, value);
}

// Write 64-bit MMIO
void writemmio64(unsigned int *addr, unsigned long long value)
{
    MmioWrite64((UINTN)addr, value);
}

// Read PCI register
int pci_conf_read(unsigned bus, unsigned dev, unsigned fn, unsigned reg,
                  unsigned len, unsigned long *value)
{
#ifdef WIN32
    DWORD dwVal = Get_PCI_Reg(bus, dev, fn, reg & ~3);
    int shift = (reg & 3) * 8;
    dwVal >>= shift;
    switch (len)
    {
    case 1:
        *value = dwVal & 0xFF;
        return 0;
    case 2:
        *value = dwVal & 0xFFFF;
        return 0;
    case 4:
        *value = dwVal;
        return 0;
    default:
        break;
    }
#else
    switch (len)
    {
    case 1:
        *value = PciRead8(PCI_LIB_ADDRESS(bus, dev, fn, reg));
        return 0;
    case 2:
        *value = PciRead16(PCI_LIB_ADDRESS(bus, dev, fn, reg));
        return 0;
    case 4:
        *value = PciRead32(PCI_LIB_ADDRESS(bus, dev, fn, reg));
        return 0;
    default:
        break;
    }
#endif
    return -1;
}

// Write PCI register
int pci_conf_write(unsigned bus, unsigned dev, unsigned fn, unsigned reg,
                   unsigned len, unsigned long value)
{
#ifdef WIN32
    DWORD dwVal = Get_PCI_Reg(bus, dev, fn, reg & ~3);
    DWORD dwMask = 0xFFFFFFFF;
    switch (len)
    {
    case 1:
        dwMask = 0xFF;
        break;
    case 2:
        dwMask = 0xFFFF;
        break;
    default:
        break;
    }
    dwVal &= ~(dwMask << ((reg & 3) * 8));
    dwVal |= (value & dwMask) << ((reg & 3) * 8);

    Set_PCI_Reg(bus, dev, fn, reg & ~3, dwVal);
    return 0;
#else
    switch (len)
    {
    case 1:
        PciWrite8(PCI_LIB_ADDRESS(bus, dev, fn, reg), (UINT8)value);
        return 0;
    case 2:
        PciWrite16(PCI_LIB_ADDRESS(bus, dev, fn, reg), (UINT16)value);
        return 0;
    case 4:
        PciWrite32(PCI_LIB_ADDRESS(bus, dev, fn, reg), (UINT32)value);
        return 0;
    default:
        break;
    }
#endif
    return -1;
}

// Read PCI register
unsigned long pciex_conf_read32(UINTN mmbase, unsigned bus, unsigned dev, unsigned fn, unsigned reg)
{
    if (reg < 0x100)
    {
        unsigned long val = (unsigned long)-1;
        pci_conf_read(bus, dev, fn, reg, 4, &val);
        return val;
    }

    if (NeedBSODWorkaround())
        return (unsigned long)-1;

    return readmmio32((unsigned int *)(mmbase + (bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + reg));
}

unsigned long long pciex_conf_read64(UINTN mmbase, unsigned bus, unsigned dev, unsigned fn, unsigned reg)
{
    if (NeedBSODWorkaround())
        return (unsigned long long)-1;

    return readmmio64((unsigned int *)(mmbase + (bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + reg));
}

/*
 * Read/Write MBUS registers in Atom E3800
 */
#define INTEL_ATOM_E3800_CUNIT_MSG_CTRL_REG 0xD0
#define INTEL_ATOM_E3800_CUNIT_MSG_DATA_REG 0xD4
#define INTEL_ATOM_E3800_CUNIT_MSG_CTRL_EXT_REG 0xD8

#define INTEL_ATOM_E3800_MBUS_READOP 0x06
#define INTEL_ATOM_E3800_MBUS_WRITEOP 0x07

DISABLE_OPTIMISATIONS() // Optimisation must be turned off
int mbus_read(unsigned port, unsigned reg, unsigned long *value)
{
    unsigned mcr = 0;
    unsigned mcrx = reg & 0xFFFFFF00;

    pci_conf_write(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_CTRL_EXT_REG, 4, mcrx);

    mcr = (INTEL_ATOM_E3800_MBUS_READOP << 24) | ((port & 0xFF) << 16) | ((reg & 0xFF) << 8) | (0xf << 4);

    pci_conf_write(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_CTRL_REG, 4, mcr);

    pci_conf_read(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_DATA_REG, 4, value);

    return 0;
}

int mbus_write(unsigned port, unsigned reg, unsigned long value)
{
    unsigned mcr = 0;
    if (reg > 0xFF)
    {
        unsigned mcrx = reg & 0xFFFFFF00;

        pci_conf_write(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_CTRL_EXT_REG, 4, mcrx);
    }

    pci_conf_write(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_DATA_REG, 4, value);

    mcr = (INTEL_ATOM_E3800_MBUS_WRITEOP << 24) | ((port & 0xFF) << 16) | ((reg & 0xFF) << 8) | (0xf << 4);

    pci_conf_write(0, 0, 0, INTEL_ATOM_E3800_CUNIT_MSG_CTRL_REG, 4, mcr);

    return 0;
}
ENABLE_OPTIMISATIONS()

#define INTEL_GET_SUBADDR(addr, intlv_bit) (LShiftU64(BitExtractULL(addr, 63, intlv_bit + 1), intlv_bit) | BitExtractULL(addr, intlv_bit - 1, 0))

static int decode_chan_hash(unsigned long long addr, unsigned long long mask, int intlv_bit)
{
    unsigned long long intlv_mask = LShiftU64(1, intlv_bit);
    unsigned long long masked_addr = addr & (mask | intlv_mask);
    int i;
    int hash = 0;

    for (i = 0; i < 63; i++)
    {
        hash ^= (int)(RShiftU64(masked_addr, i) & 1);
    }

    return hash & 1;
}

static void decode_subaddr(unsigned long long addr, int intlv_lsb, int hash_mode, unsigned long long hash_mask, unsigned long long s_size, int l_map,
                           int *idx, unsigned long long *sub_addr)
{
    if (addr > 2 * s_size)
    {
        *sub_addr = addr - 2 * s_size;
        *idx = l_map;
        // AsciiFPrint(DEBUG_FILE_HANDLE, "decode_sub - A(%p,%d,%p)", *sub_addr, *idx, s_size);
        return;
    }

    if (hash_mode)
    {
        *sub_addr = INTEL_GET_SUBADDR(addr, intlv_lsb);
        *idx = decode_chan_hash(addr, hash_mask, intlv_lsb);
    }
    else
    {
        *sub_addr = INTEL_GET_SUBADDR(addr, intlv_lsb);
        *idx = (int)BitExtractULL(addr, intlv_lsb, intlv_lsb);
    }
    // AsciiFPrint(DEBUG_FILE_HANDLE, "decode_sub - B(%p,%d,%p)", *sub_addr, *idx, s_size);
}

/*
 * Read/Write IOSF-SB registers in Atom C2000
 */
#define INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_REG 0xD0
#define INTEL_ATOM_C2000_IOSFSB_MSG_DATA_REG 0xD4
#define INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_EXT_REG 0xD8

#define INTEL_ATOM_C2000_IOSFSB_READOP 0x10
#define INTEL_ATOM_C2000_IOSFSB_WRITEOP 0x11

DISABLE_OPTIMISATIONS() // Optimisation must be turned off
int iosfsb_read(unsigned port, unsigned reg, unsigned long *value)
{
    unsigned mcr = 0;
    if (reg > 0xFF)
    {
        unsigned mcrx = reg & 0xFFFFFF00;

        pci_conf_write(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_EXT_REG, 4, mcrx);
    }

    mcr = (INTEL_ATOM_C2000_IOSFSB_READOP << 24) | ((port & 0xFF) << 16) | ((reg & 0xFF) << 8) | (0xf << 4);

    pci_conf_write(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_REG, 4, mcr);

    Sleep(1);

    pci_conf_read(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_DATA_REG, 4, value);

    return 0;
}

int iosfsb_write(unsigned port, unsigned reg, unsigned long value)
{
    unsigned mcr = 0;
    if (reg > 0xFF)
    {
        unsigned mcrx = reg & 0xFFFFFF00;

        pci_conf_write(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_EXT_REG, 4, mcrx);
    }

    pci_conf_write(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_DATA_REG, 4, value);

    Sleep(1);

    mcr = (INTEL_ATOM_C2000_IOSFSB_WRITEOP << 24) | ((port & 0xFF) << 16) | ((reg & 0xFF) << 8) | (0xf << 4);

    pci_conf_write(0, 0, 0, INTEL_ATOM_C2000_IOSFSB_MSG_CTRL_REG, 4, mcr);

    return 0;
}
ENABLE_OPTIMISATIONS()

#define NB_SMN_INDEX_0 0x60 // PCI register offset
#define NB_SMN_DATA_0 0x64  // PCI register offset

DISABLE_OPTIMISATIONS() // Optimisation must be turned off
int smn_read(unsigned bus, unsigned reg, unsigned long *value)
{
    // Set SMN_INDEX_0 to the register to read
    pci_conf_write(bus, 0, 0, NB_SMN_INDEX_0, 4, reg);

    Sleep(1);

    // Read NB_SMN_DATA_0 to read the register value
    pci_conf_read(bus, 0, 0, NB_SMN_DATA_0, 4, value);

    return 0;
}

int smn_write(unsigned bus, unsigned reg, unsigned long value)
{
    // Set SMN_INDEX_0 to the register to read
    pci_conf_write(bus, 0, 0, NB_SMN_INDEX_0, 4, reg);

    Sleep(1);

    // Write NB_SMN_DATA_0 to write the register value
    pci_conf_write(bus, 0, 0, NB_SMN_DATA_0, 4, value);

    return 0;
}

#define NB_SMN_INDEX_3 0xC4 // PCI register offset
#define NB_SMN_DATA_3 0xC8  // PCI register offset

#define SMN_HSMP_MSG_ID 0x3B10534
#define SMN_HSMP_MSG_RESPONSE 0x3B10980
#define SMN_HSMP_MSG_ARG(n) (0x3B109E0 + 4 * n)

/*
 * HSMP Messages supported
 */
enum hsmp_message_ids
{
    HSMP_TEST = 1,                   /* 01h Increments input value by 1 */
    HSMP_GET_SMU_VER,                /* 02h SMU FW version */
    HSMP_GET_PROTO_VER,              /* 03h HSMP interface version */
    HSMP_GET_SOCKET_POWER,           /* 04h average package power consumption */
    HSMP_SET_SOCKET_POWER_LIMIT,     /* 05h Set the socket power limit */
    HSMP_GET_SOCKET_POWER_LIMIT,     /* 06h Get current socket power limit */
    HSMP_GET_SOCKET_POWER_LIMIT_MAX, /* 07h Get maximum socket power value */
    HSMP_SET_BOOST_LIMIT,            /* 08h Set a core maximum frequency limit */
    HSMP_SET_BOOST_LIMIT_SOCKET,     /* 09h Set socket maximum frequency level */
    HSMP_GET_BOOST_LIMIT,            /* 0Ah Get current frequency limit */
    HSMP_GET_PROC_HOT,               /* 0Bh Get PROCHOT status */
    HSMP_SET_XGMI_LINK_WIDTH,        /* 0Ch Set max and min width of xGMI Link */
    HSMP_SET_DF_PSTATE,              /* 0Dh Alter APEnable/Disable messages behavior */
    HSMP_SET_AUTO_DF_PSTATE,         /* 0Eh Enable DF P-State Performance Boost algorithm */
    HSMP_GET_FCLK_MCLK,              /* 0Fh Get FCLK and MEMCLK for current socket */
    HSMP_GET_CCLK_THROTTLE_LIMIT,    /* 10h Get CCLK frequency limit in socket */
    HSMP_GET_C0_PERCENT,             /* 11h Get average C0 residency in socket */
    HSMP_SET_NBIO_DPM_LEVEL,         /* 12h Set max/min LCLK DPM Level for a given NBIO */
    HSMP_GET_NBIO_DPM_LEVEL,         /* 13h Get LCLK DPM level min and max for a given NBIO */
    HSMP_GET_DDR_BANDWIDTH,          /* 14h Get theoretical maximum and current DDR Bandwidth */
    HSMP_GET_TEMP_MONITOR,           /* 15h Get socket temperature */
    HSMP_GET_DIMM_TEMP_RANGE,        /* 16h Get per-DIMM temperature range and refresh rate */
    HSMP_GET_DIMM_POWER,             /* 17h Get per-DIMM power consumption */
    HSMP_GET_DIMM_THERMAL,           /* 18h Get per-DIMM thermal sensors */
    HSMP_GET_SOCKET_FREQ_LIMIT,      /* 19h Get current active frequency per socket */
    HSMP_GET_CCLK_CORE_LIMIT,        /* 1Ah Get CCLK frequency limit per core */
    HSMP_GET_RAILS_SVI,              /* 1Bh Get SVI-based Telemetry for all rails */
    HSMP_GET_SOCKET_FMAX_FMIN,       /* 1Ch Get Fmax and Fmin per socket */
    HSMP_GET_IOLINK_BANDWITH,        /* 1Dh Get current bandwidth on IO Link */
    HSMP_GET_XGMI_BANDWITH,          /* 1Eh Get current bandwidth on xGMI Link */
    HSMP_SET_GMI3_WIDTH,             /* 1Fh Set max and min GMI3 Link width */
    HSMP_SET_PCI_RATE,               /* 20h Control link rate on PCIe devices */
    HSMP_SET_POWER_MODE,             /* 21h Select power efficiency profile policy */
    HSMP_SET_PSTATE_MAX_MIN,         /* 22h Set the max and min DF P-State  */
    HSMP_GET_METRIC_TABLE_VER,       /* 23h Get metrics table version */
    HSMP_GET_METRIC_TABLE,           /* 24h Get metrics table */
    HSMP_GET_METRIC_TABLE_DRAM_ADDR, /* 25h Get metrics table dram address */
    HSMP_SET_XGMI_PSTATE_RANGE,      /* 26h Set xGMI P-state range */
    HSMP_CPU_RAIL_ISO_FREQ_POLICY,   /* 27h Get/Set Cpu Iso frequency policy */
    HSMP_DFC_ENABLE_CTRL,            /* 28h Enable/Disable DF C-state */
    HSMP_GET_RAPL_UNITS = 0x30,      /* 30h Get scaling factor for energy */
    HSMP_GET_RAPL_CORE_COUNTER,      /* 31h Get core energy counter value */
    HSMP_GET_RAPL_PACKAGE_COUNTER,   /* 32h Get package energy counter value */
    HSMP_MSG_ID_MAX,
};

typedef struct
{
    unsigned long response;
    unsigned long argument[8];
} hsmp_arg;

int hsmp_request(unsigned bus, unsigned func_id, hsmp_arg *arg)
{
    // To request a given HSMP function, software executes the following sequence:
    // . Write zero (0) to the Message Response register.
    // . Write function arguments into the Message Argument registers.
    // . Write the function ID into the Message ID register.
    // . Wait (poll) until the Message Response register returns a non-zero value.

    AsciiFPrint(DEBUG_FILE_HANDLE, "hsmp - request function %02x", func_id);

    arg->response = 0;
    smn_write(bus, SMN_HSMP_MSG_RESPONSE, 0);
#if 0
    pci_conf_write(bus, 0, 0, NB_SMN_INDEX_3, 4, SMN_HSMP_MSG_RESPONSE);
    Sleep(1);
    pci_conf_write(bus, 0, 0, NB_SMN_DATA_3, 4, 0);
#endif

    for (int n = 0; n < ARRAY_SIZE(arg->argument); n++)
    {
        smn_write(bus, SMN_HSMP_MSG_ARG(n), arg->argument[n]);
#if 0
        pci_conf_write(bus, 0, 0, NB_SMN_INDEX_3, 4, SMN_HSMP_MSG_ARG(n));
        Sleep(1);
        pci_conf_write(bus, 0, 0, NB_SMN_DATA_3, 4, arg->argument[n]);
#endif
    }

    smn_write(bus, SMN_HSMP_MSG_ID, func_id);
#if 0
    pci_conf_write(bus, 0, 0, NB_SMN_INDEX_3, 4, SMN_HSMP_MSG_ID);
    Sleep(1);
    pci_conf_write(bus, 0, 0, NB_SMN_DATA_3, 4, func_id);
#endif

    // pci_conf_write(bus, 0, 0, NB_SMN_INDEX_3, 4, SMN_HSMP_MSG_RESPONSE);
    const int MAX_ATTEMPTS = 100;
    int attempts = 0;
    do
    {
        Sleep(1);
        smn_read(bus, SMN_HSMP_MSG_RESPONSE, &arg->response);
        // pci_conf_read(bus, 0, 0, NB_SMN_DATA_3, 4, &arg->response);
        attempts++;
    } while (arg->response == 0 && attempts < MAX_ATTEMPTS);

    if (arg->response == 0)
        return -1;

    for (int n = 0; n < ARRAY_SIZE(arg->argument); n++)
    {
        smn_read(bus, SMN_HSMP_MSG_ARG(n), &arg->argument[n]);
#if 0
        pci_conf_write(bus, 0, 0, NB_SMN_INDEX_3, 4, SMN_HSMP_MSG_ARG(n));
        Sleep(1);
        pci_conf_write(bus, 0, 0, NB_SMN_DATA_3, 4, arg->argument[n]);
#endif
    }

    return 0;
}
ENABLE_OPTIMISATIONS()

#define MAX_UMC 12
#define MAX_SLOTS_PER_UMC 2
#define MAX_CS_PER_UMC 4

// Keep track of memory controller info of the system
struct ecc_info
{
    int index;
    int ctrlno;
    int poll;
    unsigned bus;
    unsigned dev;
    unsigned fn;
    UINT64 mchbar;
    UINT64 mchbar2;
    UINT64 membar[MAX_UMC];
    unsigned cap;
    unsigned mode;

    UINT8 numch;
    UINT8 numsl;
    UINT8 chmode;

    unsigned char numranks[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned char chipwidth[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned int preverrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned char dimmtemp[MAX_UMC * MAX_SLOTS_PER_UMC];

    unsigned int memclk;
    unsigned int ctrlclk;
    unsigned char tAA;
    unsigned char tRCD;
    unsigned char tRAS;
    unsigned char tRP;
    unsigned char tRC;

    // User data
    unsigned char *userdata;
};

static struct ecc_info *s_ctrl = NULL;
static int s_numctrls = 0;

// Database of supported memory controllers
struct pci_memory_controller
{
    unsigned bus;
    unsigned dev;
    unsigned fn;
    unsigned vendor;
    unsigned device;
    char *name;
    int tested;
    void (*poll_fsb)(struct ecc_info *ctrl);
    void (*poll_timings)(struct ecc_info *ctrl);
    void (*setup_ecc)(struct ecc_info *ctrl);
    void (*poll_errors)(struct ecc_info *ctrl);
    int (*poll_temp)(struct ecc_info *ctrl);
    int (*decode_addr)(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
};

struct pci_memory_controller controllers[];

// Initialize functions for memory controllers
static void setup_nothing(struct ecc_info *ctrl);
static void setup_nhm(struct ecc_info *ctrl);
static void setup_e3sb(struct ecc_info *ctrl); //
static void setup_e5sb(struct ecc_info *ctrl);
static void setup_e5ib(struct ecc_info *ctrl);
static void setup_e3haswell(struct ecc_info *ctrl);
static void setup_e5haswell(struct ecc_info *ctrl);
static void setup_broadwell(struct ecc_info *ctrl);
static void setup_broadwell_h(struct ecc_info *ctrl);
static void setup_skylake(struct ecc_info *ctrl);
static void setup_skylake_sp(struct ecc_info *ctrl);
static void setup_kabylake(struct ecc_info *ctrl);
static void setup_ryzen(struct ecc_info *ctrl);
static void setup_ryzen_zen2(struct ecc_info *ctrl);
static void setup_ryzen_zen4_61h(struct ecc_info *ctrl);
static void setup_ryzen_zen4_78h(struct ecc_info *ctrl);
static void setup_ryzen_zen5(struct ecc_info *ctrl);
static void setup_amd64(struct ecc_info *ctrl);
static void setup_amd10h(struct ecc_info *ctrl);
static void setup_amd751(struct ecc_info *ctrl);
static void setup_amd76x(struct ecc_info *ctrl);
static void setup_cnb20(struct ecc_info *ctrl);
static void setup_E5400(struct ecc_info *ctrl);
static void setup_iE7xxx(struct ecc_info *ctrl);
static void setup_iE7520(struct ecc_info *ctrl);
static void setup_i440gx(struct ecc_info *ctrl);
static void setup_i840(struct ecc_info *ctrl);
static void setup_i875(struct ecc_info *ctrl);
static void setup_i925(struct ecc_info *ctrl);
static void setup_i3000(struct ecc_info *ctrl); //
static void setup_p35(struct ecc_info *ctrl);
static void setup_i3200(struct ecc_info *ctrl); //
static void setup_x38(struct ecc_info *ctrl);   //
static void setup_i845(struct ecc_info *ctrl);
static void setup_i820(struct ecc_info *ctrl);
static void setup_i850(struct ecc_info *ctrl);
static void setup_i860(struct ecc_info *ctrl);
static void setup_e3800atom(struct ecc_info *ctrl);
static void setup_c2000atom(struct ecc_info *ctrl);
static void setup_c3000atom(struct ecc_info *ctrl);
static void setup_apollolake(struct ecc_info *ctrl);
static void setup_elkhartlake(struct ecc_info *ctrl);
static void setup_icelake(struct ecc_info *ctrl);
static void setup_tigerlake(struct ecc_info *ctrl);
static void setup_tigerlake_h(struct ecc_info *ctrl);
static void setup_rocketlake(struct ecc_info *ctrl);
static void setup_alderlake(struct ecc_info *ctrl);
static void setup_meteorlake(struct ecc_info *ctrl);
static void setup_icelake_sp(struct ecc_info *ctrl);
static void setup_emeraldrapids_sp(struct ecc_info *ctrl);

// ECC poll functions for memory controllers
static void poll_nothing(struct ecc_info *ctrl);
static void poll_nhm(struct ecc_info *ctrl);
static void poll_e5sb(struct ecc_info *ctrl);
static void poll_e5ib(struct ecc_info *ctrl);
static void poll_e5haswell(struct ecc_info *ctrl);
static void poll_broadwell(struct ecc_info *ctrl);
static void poll_broadwell_h(struct ecc_info *ctrl);
static void poll_skylake(struct ecc_info *ctrl);
static void poll_skylake_sp(struct ecc_info *ctrl);
static void poll_kabylake(struct ecc_info *ctrl);
static void poll_ryzen(struct ecc_info *ctrl);
static void poll_ryzen_zen2(struct ecc_info *ctrl);
static void poll_ryzen_zen4_61h(struct ecc_info *ctrl);
static void poll_ryzen_zen4_78h(struct ecc_info *ctrl);
static void poll_ryzen_zen5(struct ecc_info *ctrl);
static void poll_amd64(struct ecc_info *ctrl);
static void poll_amd751(struct ecc_info *ctrl);
static void poll_amd76x(struct ecc_info *ctrl);
static void poll_E5400(struct ecc_info *ctrl); //
static void poll_i5000(struct ecc_info *ctrl); //
static void poll_i5100(struct ecc_info *ctrl); //
static void poll_i7300(struct ecc_info *ctrl); //
static void poll_iE7xxx(struct ecc_info *ctrl);
static void poll_i440gx(struct ecc_info *ctrl);
static void poll_i840(struct ecc_info *ctrl);
static void poll_i925(struct ecc_info *ctrl);  //
static void poll_i3000(struct ecc_info *ctrl); //
static void poll_i3200(struct ecc_info *ctrl); //
static void poll_x38(struct ecc_info *ctrl);   //
static void poll_e3sb(struct ecc_info *ctrl);  //
static void poll_e3haswell(struct ecc_info *ctrl);
static void poll_i875(struct ecc_info *ctrl);
static void poll_i845(struct ecc_info *ctrl);
static void poll_i820(struct ecc_info *ctrl);
static void poll_i850(struct ecc_info *ctrl);
static void poll_i860(struct ecc_info *ctrl); //
static void poll_iE7221(struct ecc_info *ctrl);
static void poll_iE7520(struct ecc_info *ctrl);
static void poll_e3800atom(struct ecc_info *ctrl);
static void poll_c2000atom(struct ecc_info *ctrl);
static void poll_c3000atom(struct ecc_info *ctrl);
static void poll_apollolake(struct ecc_info *ctrl);
static void poll_elkhartlake(struct ecc_info *ctrl);
static void poll_icelake(struct ecc_info *ctrl);
static void poll_tigerlake(struct ecc_info *ctrl);
static void poll_tigerlake_h(struct ecc_info *ctrl);
static void poll_rocketlake(struct ecc_info *ctrl);
static void poll_alderlake(struct ecc_info *ctrl);
static void poll_meteorlake(struct ecc_info *ctrl);
static void poll_icelake_sp(struct ecc_info *ctrl);
static void poll_emeraldrapids_sp(struct ecc_info *ctrl);

static int poll_temp_e3sb(struct ecc_info *ctrl);
static int poll_temp_e3haswell(struct ecc_info *ctrl);
static int poll_temp_broadwell(struct ecc_info *ctrl);
static int poll_temp_broadwell_h(struct ecc_info *ctrl);
static int poll_temp_skylake(struct ecc_info *ctrl);
static int poll_temp_kabylake(struct ecc_info *ctrl);

static void poll_timings_e3sb(struct ecc_info *ctrl);
static void poll_timings_e3ib(struct ecc_info *ctrl);
static void poll_timings_e3haswell(struct ecc_info *ctrl);
static void poll_timings_skylake(struct ecc_info *ctrl);
static void poll_timings_skylake_sp(struct ecc_info *ctrl);
static void poll_timings_coffeelake(struct ecc_info *ctrl);
static void poll_timings_cometlake(struct ecc_info *ctrl);
static void poll_timings_icelake(struct ecc_info *ctrl);
static void poll_timings_icelake_sp(struct ecc_info *ctrl);
static void poll_timings_emeraldrapids_sp(struct ecc_info *ctrl);
static void poll_timings_tigerlake(struct ecc_info *ctrl);
static void poll_timings_tigerlake_h(struct ecc_info *ctrl);
static void poll_timings_rocketlake(struct ecc_info *ctrl);
static void poll_timings_alderlake(struct ecc_info *ctrl);
static void poll_timings_meteorlake(struct ecc_info *ctrl);
static void poll_timings_elkhartlake(struct ecc_info *ctrl);
static void poll_timings_k10(struct ecc_info *ctrl);
static void poll_timings_ryzen(struct ecc_info *ctrl);
static void poll_timings_ryzen_zen4(struct ecc_info *ctrl);
static void poll_timings_ryzen_zen5(struct ecc_info *ctrl);

static int decode_coffeelake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_broadwell(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_icelake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_rocketlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_alderlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_meteorlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_ryzen_zen2(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_ryzen_zen4_61h(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_ryzen_zen4_78h(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);
static int decode_ryzen_zen5(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr);

static void poll_fsb_nothing(struct ecc_info *ctrl)
{
    /* Code to run for no specific fsb detection */
    return;
}

static void setup_nothing(struct ecc_info *ctrl)
{
    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;
}

static void poll_nothing(struct ecc_info *ctrl)
{
    /* Code to run when we don't know how, or can't ask the memory
     * controller about memory errors.
     */
    return;
}

/*
 * Nehalem-based memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-5500-vol-2-datasheet.html
 */
#define NHM_MC_CFG_CONTROL 0x90

/* Device 3, Function 0 Integrated Memory Controller Registers */
#define NHM_MC_STATUS 0x4C
#define NHM_MC_STATUS_ECC_EN(reg) ((reg >> 4) & 1)
/* Device 3, Function 2 Integrated Memory Controller RAS Registers */
#define NHM_MC_SSRCONTROL 0x48

#define NHM_MC_CHANNEL_ADDR_MATCH 0xF0
#define NHM_MC_CHANNEL_ECC_ERROR_MASK 0xF8
#define NHM_MC_CHANNEL_ECC_ERROR_INJECT 0xFC

#define NHM_MC_TEST_ERR_RCV1 0x60
#define NHM_MC_TEST_ERR_RCV0 0x64

#define NHM_MC_COR_ECC_CNT_0 0x80
#define NHM_MC_COR_ECC_CNT_1 0x84
#define NHM_MC_COR_ECC_CNT_2 0x88
#define NHM_MC_COR_ECC_CNT_3 0x8c
#define NHM_MC_COR_ECC_CNT_4 0x90
#define NHM_MC_COR_ECC_CNT_5 0x94

#define NHM_MC_CHANNEL_DIMM_INIT_PARAMS 0x58

#define MSR_IA32_MCG_CAP 0x00000179
#define MSR_IA32_MCG_STATUS 0x0000017a

#define MCI_STATUS_VAL (1ULL << 63)   /* valid error */
#define MCI_STATUS_MISCV (1ULL << 59) /* misc error reg. valid */
#define MCI_STATUS_ADDRV (1ULL << 58) /* addr reg. valid */

#define MSR_IA32_MCi_CTL(i) (0x00000400 + 4 * i)
#define MSR_IA32_MCi_STATUS(i) (0x00000401 + 4 * i)
#define MSR_IA32_MCi_ADDR(i) (0x00000402 + 4 * i)
#define MSR_IA32_MCi_MISC(i) (0x00000403 + 4 * i)
#define MSR_IA32_MCi_CTL2(i) (0x00000280 + i)

#define MSR_IA32_MC8_STATUS 0x00000421
#define MSR_IA32_MC8_ADDR 0x00000422
#define MSR_IA32_MC8_MISC 0x00000423
#define MSR_IA32_MC8_CTL2 0x00000288

#define MSR_ERROR_CONTROL 0x0000017F

#define MSR_IA32_APIC_BASE 0x0000001B

static void setup_nhm(struct ecc_info *ctrl)
{
    unsigned long mc_status = 0, mc_ssrcontrol = 0;

    MtSupportDebugWriteLine("Intel Nehalem/Lynnfield/Westmere chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;

    /* Check for ECC & Scrub */

    pci_conf_read(ctrl->bus, 3, 0, NHM_MC_STATUS, 2, &mc_status);

    AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC_STATUS=%08x", mc_status);
    MtSupportDebugWriteLine(gBuffer);

    if (NHM_MC_STATUS_ECC_EN(mc_status))
    {
        UINT64 mc8status = 0;
        ctrl->mode = ECC_CORRECT;
        pci_conf_read(ctrl->bus, 3, 2, NHM_MC_SSRCONTROL, 2, &mc_ssrcontrol);

        AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC_SSRCONTROL=%08x", mc_ssrcontrol);
        MtSupportDebugWriteLine(gBuffer);

        if (mc_ssrcontrol & 3)
        {
            ctrl->mode = ECC_SCRUB;
        }

        // clear any errors
        _rdmsr64(MSR_IA32_MC8_STATUS, &mc8status);
        if (mc8status != 0)
        {
            _wrmsr64(MSR_IA32_MC8_STATUS, 0);
        }
    }
}

static void poll_nhm(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;
    UINT64 mc8status = 0;
    UINT64 mc8misc = 0;
    UINT64 mc8addr = 0;

    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    _rdmsr64(MSR_IA32_MC8_STATUS, &mc8status);

    if (mc8status & MCI_STATUS_VAL)
    {
        BOOLEAN uncorrected_error;
        UINT8 channel;
        UINT8 dimm;
        UINT32 syndrome;

        AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC8_STATUS=" I64HEXFMT, mc8status);
        MtSupportDebugWriteLine(gBuffer);

        if (mc8status & MCI_STATUS_ADDRV)
            _rdmsr64(MSR_IA32_MC8_ADDR, &mc8addr);

        if (mc8status & MCI_STATUS_MISCV)
            _rdmsr64(MSR_IA32_MC8_MISC, &mc8misc);

        AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC8_ADDR=" I64HEXFMT, mc8addr);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC8_MISC=" I64HEXFMT, mc8misc);
        MtSupportDebugWriteLine(gBuffer);

        _wrmsr64(MSR_IA32_MC8_STATUS, 0);

        uncorrected_error = (mc8status & (1ll << 61)) != 0;

        channel = (mc8misc >> 18) & 0x3;
        dimm = (mc8misc >> 16) & 0x3;
        syndrome = mc8misc >> 32;

        MtSupportReportECCError((UINTN)mc8addr, !uncorrected_error, syndrome, -1, channel, dimm);
    }
}

void inject_nhm(int index, int uncorrectable)
{
    UINT64 mask = 0;
    UINT32 eccmask = 0;
    UINT32 injectmask = 0;

    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    pci_conf_write(ctrl->bus, 0, 0, NHM_MC_CFG_CONTROL, 4, 0x2);

    mask |= 1LL << 41;
    mask |= 1LL << 40;
    mask |= 1LL << 39;
    mask |= 1LL << 38;
    mask |= 1LL << 37;

    AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC_CHANNEL_0_ADDR_MATCH=" I64HEXFMT, mask);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_write(ctrl->bus, 4, 0, NHM_MC_CHANNEL_ADDR_MATCH, 4, (unsigned long)(mask & 0x0ffffffffULL));

    pci_conf_write(ctrl->bus, 4, 0, NHM_MC_CHANNEL_ADDR_MATCH + 4, 4, mask >> 32);

    if (uncorrectable)
        eccmask = 0x00010001;
    else
        eccmask = 0x00000001;

    AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC_CHANNEL_0_ECC_ERROR_MASK=%08x", eccmask);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_write(ctrl->bus, 4, 0, NHM_MC_CHANNEL_ECC_ERROR_MASK, 4, eccmask);

    injectmask = 1 << 3;
    injectmask |= 1 << 1;

    AsciiSPrint(gBuffer, BUF_SIZE, "Nehalem MC_CHANNEL_0_ECC_ERROR_INJECT=%08x", injectmask);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_write(ctrl->bus, 4, 0, NHM_MC_CHANNEL_ECC_ERROR_INJECT, 4, injectmask);

    pci_conf_write(ctrl->bus, 0, 0, NHM_MC_CFG_CONTROL, 4, 0x8);
}

/*
 * Xeon E5-1600 memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-1600-2600-vol-2-datasheet.html
 */
#define INTEL_E5SB_MCMTR 0x7C
#define INTEL_E5SB_SCRUBCTL 0xA0
#define INTEL_E5SB_SMICTRL 0xD8
#define INTEL_E5SB_SMISPARECTL 0xB4

#define INTEL_E5SB_CORRERRCNT_0 0x104
#define INTEL_E5SB_CORRERRCNT_1 0x108
#define INTEL_E5SB_CORRERRCNT_2 0x10C
#define INTEL_E5SB_CORRERRCNT_3 0x110

#define INTEL_E5SB_CORRERRTHRSHLD_0 0x11C
#define INTEL_E5SB_CORRERRTHRSHLD_1 0x120
#define INTEL_E5SB_CORRERRTHRSHLD_2 0x124
#define INTEL_E5SB_CORRERRTHRSHLD_3 0x128

#define INTEL_E5SB_CORRERRORSTATUS 0x134

#define INTEL_E5SB_DEVTAG_CNTRL 0x140

#define INTEL_E5SB_IOSAV_CH_B0_B3_BW_SERR 0x1A0
#define INTEL_E5SB_IOSAV_CH_B4_B7_BW_SERR 0x1A4
#define INTEL_E5SB_IOSAV_CH_B8_BW_SERR 0x1A8

#define INTEL_E5SB_RSP_FUNC_ADDR_MATCH_LO 0x1C0
#define INTEL_E5SB_RSP_FUNC_ADDR_MATCH_HI 0x1C4
#define INTEL_E5SB_RSP_FUNC_ADDR_MASK_LO 0x1C8
#define INTEL_E5SB_RSP_FUNC_ADDR_MASK_HI 0x1CC
#define INTEL_E5SB_RSP_FUNC_MCCTRL_ERR_INJ 0x300
#define INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK 0x200
#define INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 0x204
#define INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_EXTRA 0x208

static void setup_e5sb(struct ecc_info *ctrl)
{
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
#if 0
    unsigned long smictrl = 0, smisparectl = 0;
#endif
    unsigned long mmcfg = 0, mmcfglim = 0;

    unsigned int correrrcnt = 0, correrrthrshld = 0;
    int dev, rank;
    UINT64 mcgcap = 0;
    UINT64 errctl = 0;
    UINT64 mcgstatus = 0;

    int mcbank;
    UINT64 mcstatus = 0;
#if 0
    UINT64 mcctl2 = 0;
    UINT64 apicbase = 0;

    unsigned int cmci = 0;
#endif
    MtSupportDebugWriteLine("Intel E5 Sandy Bridge chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 4;
    ctrl->numsl = 2;
    ctrl->mchbar = 0;
    /* Check for ECC & Scrub */

    pci_conf_read(ctrl->bus, 15, 0, INTEL_E5SB_MCMTR, 4, &mc_mtr);

    AsciiSPrint(gBuffer, BUF_SIZE, "SB-E MCMTR=%08x", mc_mtr);
    MtSupportDebugWriteLine(gBuffer);

    if ((mc_mtr >> 2) & 0x01)
    {
        ctrl->mode = ECC_CORRECT;
        pci_conf_read(ctrl->bus, 15, 1, INTEL_E5SB_SCRUBCTL, 4, &mc_scrubctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "SB-E SCRUBCTL=%08x", mc_scrubctl);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_scrubctl >> 31) & 0x01)
        {
            ctrl->mode = ECC_SCRUB;
        }
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(0, 5, 0, 0x84, 4, &mmcfg);
    mmcfg &= 0xFC000000;
    pci_conf_read(0, 5, 0, 0x88, 4, &mmcfglim);
    mmcfglim &= 0xFC000000;

    AsciiSPrint(gBuffer, BUF_SIZE, "SB-E MMCFGBase=%08x, MMCFGLim=%08x", mmcfg, mmcfglim);
    MtSupportDebugWriteLine(gBuffer);

    if (mmcfg > 0 && mmcfglim > 0 && mmcfg <= mmcfglim) // Sanity check
    {
        ctrl->mchbar = mmcfg;
        for (dev = 2; dev <= 7; dev++)
        {
            if (dev == 2 || dev == 3 || dev == 6 || dev == 7)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    // Read corrected error count/threshold registers
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRCNT_0 + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRTHRSHLD_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, dev, INTEL_E5SB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
                    pci_conf_read(ctrl->bus, 16, dev, INTEL_E5SB_CORRERRTHRSHLD_0 + 4 * rank, 4, &correrrthrshld);
#endif
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", dev <= 3 ? dev : dev - 6, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0)
                        writemmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRCNT_0 + 4 * rank), 0x80008000);
                }
            }
        }
    }

#if 0
    pci_conf_read(ctrl->bus, 11, 3, INTEL_E5SB_SMICTRL, 4, &smictrl);

    AsciiSPrint(gBuffer, BUF_SIZE, "SMICTRL=%08x", smictrl);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, 15, 1, INTEL_E5SB_SMISPARECTL, 4, &smisparectl);

    AsciiSPrint(gBuffer, BUF_SIZE, "SMISPARECTL=%08x", smisparectl);
    MtSupportDebugWriteLine(gBuffer);

    if (smisparectl & (1 << 15))
    {
        smisparectl &= ~(1 << 15);
        AsciiSPrint(gBuffer, BUF_SIZE, "SMI Enabled. Disabling... (New SMISPARECTL=%08X)", smisparectl);
        MtSupportDebugWriteLine(gBuffer);
        pci_conf_write(ctrl->bus, 15, 1, INTEL_E5SB_SMISPARECTL, 4, smisparectl);
    }
#endif

    // ECC errors also reported in the MSR, read and clear any previous errors
    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
    _rdmsr64(MSR_ERROR_CONTROL, &errctl);

    AsciiSPrint(gBuffer, BUF_SIZE, "SB-E MCG_CAP=" I64HEXFMT ", MCG_STATUS=" I64HEXFMT ", ERROR_CONTROL=" I64HEXFMT, mcgcap, mcgstatus, errctl);
    MtSupportDebugWriteLine(gBuffer);

    // Clear error status
    for (mcbank = 8; mcbank <= 11; mcbank++)
    {
        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);
#if 0
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_CTL2(mcbank), &mcctl2);
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_CTL2=" I64HEXFMT, mcbank, mcctl2);
        MtSupportDebugWriteLine(gBuffer);
#endif
        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "SB-E MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }
#if 0
    _rdmsr64(MSR_IA32_APIC_BASE, &apicbase);
    AsciiSPrint(gBuffer, BUF_SIZE, "APIC_BASE=" I64HEXFMT, apicbase);
    MtSupportDebugWriteLine(gBuffer);

    cmci = readmmio32((unsigned int *)((UINTN)0xFEE002F0));
    AsciiSPrint(gBuffer, BUF_SIZE, "LCT CMCI Register=%08x", cmci);
    MtSupportDebugWriteLine(gBuffer);
#endif
}

static void poll_e5sb(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;

    int mcreg;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    // unsigned int serr0, serr1, serr2;

    UINT8 dev, rank;
    UINT8 ch, slot;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        for (dev = 2; dev <= 7; dev++)
        {
            if (dev == 2 || dev == 3 || dev == 6 || dev == 7)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    ch = dev <= 3 ? dev : dev - 6;
                    slot = rank < 2 ? 0 : 1;

                    correrrcnt = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRCNT_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, dev, INTEL_E5SB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
#endif

                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                    }
                }
#if 0
                correrrorstatus = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRORSTATUS));
#if 0
                pci_conf_read(ctrl->bus, 16, dev, INTEL_E5SB_CORRERRORSTATUS, 4, &correrrorstatus);
#endif
                if ((correrrorstatus & 0xFF) != 0)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] CORRERRORSTATUS=%08X", dev <= 3 ? dev : dev - 6, correrrorstatus);
                    MtSupportDebugWriteLine(gBuffer);

                    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_CORRERRORSTATUS), correrrorstatus | 0xFF);
                }

                serr0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B0_B3_BW_SERR));

                if (serr0 != 0)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] IOSAV_CH_B0_B3_BW_SERR=%08X", dev <= 3 ? dev : dev - 6, serr0);
                    MtSupportDebugWriteLine(gBuffer);

                    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B0_B3_BW_SERR), 0xffffffff);
                }

                serr1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B4_B7_BW_SERR));

                if (serr1 != 0)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] IOSAV_CH_B4_B7_BW_SERR=%08X", dev <= 3 ? dev : dev - 6, serr1);
                    MtSupportDebugWriteLine(gBuffer);

                    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B4_B7_BW_SERR), 0xffffffff);
                }

                serr2 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B8_BW_SERR));

                if ((serr2 & 0xFF) != 0)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] IOSAV_CH_B0_B3_BW_SERR=%08X", dev <= 3 ? dev : dev - 6, serr0);
                    MtSupportDebugWriteLine(gBuffer);

                    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (16 * 0x8000) + (dev * 0x1000) + INTEL_E5SB_IOSAV_CH_B8_BW_SERR), serr2 | 0xFF);
                }
#endif
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    // Poll MCE MSR registers as well for debug. But don't report any errors
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    for (mcreg = 8; mcreg <= 11; mcreg++)
    {
        UINT64 mcstatus = 0;
        UINT64 mcmisc = 0;
        UINT64 mcaddr = 0;

        _rdmsr64(MSR_IA32_MCi_STATUS(mcreg), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            BOOLEAN uncorrected_error;
            UINT32 mserr;
            UINT32 channel;
            UINT64 addrmask;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Recoverable=%s, Corrected error count=%d, Error code=%04X)", mcreg, mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 56)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);
                AsciiSPrint(gBuffer, BUF_SIZE, "Transaction error type: ");
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x001:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address parity error");
                break;
            case 0x002:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA Wrt buffer Data parity error");
                break;
            case 0x004:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA Wrt byte enable parity error");
                break;
            case 0x008:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected patrol scrub error");
                break;
            case 0x010:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x020:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected spare error");
                break;
            case 0x040:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected spare error");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
                _rdmsr64(MSR_IA32_MCi_ADDR(mcreg), &mcaddr);

            if (mcstatus & MCI_STATUS_MISCV)
                _rdmsr64(MSR_IA32_MCi_MISC(mcreg), &mcmisc);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcreg, mcaddr);
            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcreg, mcmisc);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_MCi_STATUS(mcreg), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;

            channel = (UINT32)(mcstatus & 0xF);
            addrmask = LShiftU64(1, mcmisc & 0x3F);
            addrmask = ~(addrmask - 1);
#if 0
            MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, channel, -1);
#endif
        }
    }
}

// Reference: Intel? Xeon? Processor E5-1600/ E5-2400/E5-2600/E5-4600 Product Families External Design Specification - Volume Two (Reference Number: 443553 Revision: 2.0)
void inject_e5sb(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;

    int fn;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        for (fn = 2; fn <= 5; fn++)
        {
            UINT64 addr_match = 0;
            UINT64 addr_mask = 0;

            unsigned long value;

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_ADDR_MATCH_LO));
            addr_match = (UINT64)value << 3;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_ADDR_MATCH_LO, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_ADDR_MATCH_HI));
            addr_match |= ((UINT64)value & 0x7FF) << 35;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_ADDR_MATCH_HI, value);
            MtSupportDebugWriteLine(gBuffer);

            if ((value & (1 << 11)) == 0) // Enable RSP_FUNC_ADDR_MATCH_EN
            {
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_ADDR_MATCH_HI), value | (1 << 11));
            }

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_ADDR_MASK_LO));
            addr_mask = (UINT64)value << 3;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_ADDR_MASK_LO, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_ADDR_MASK_HI));
            addr_mask |= ((UINT64)value & 0x7FF) << 35;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_ADDR_MASK_HI, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_MCCTRL_ERR_INJ));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_MCCTRL_ERR_INJ=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_MCCTRL_ERR_INJ, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK, value);
            MtSupportDebugWriteLine(gBuffer);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (15 * 0x8000) + (fn * 0x1000) + INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_EXTRA));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_e5sb - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, 15, fn, INTEL_E5SB_RSP_FUNC_CRC_ERR_INJ_EXTRA, value);
            MtSupportDebugWriteLine(gBuffer);
        }
    }
}

/*
 * Xeon E5 v2 Family memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v2-datasheet-vol-2.html
 */
#define INTEL_E5IB_MCMTR 0x7C
#define INTEL_E5IB_SCRUBCTL 0xA0

#define INTEL_E5IB_CORRERRCNT_0 0x104
#define INTEL_E5IB_CORRERRCNT_1 0x108
#define INTEL_E5IB_CORRERRCNT_2 0x10C
#define INTEL_E5IB_CORRERRCNT_3 0x110

#define INTEL_E5IB_CORRERRTHRSHLD_0 0x11C
#define INTEL_E5IB_CORRERRTHRSHLD_1 0x120
#define INTEL_E5IB_CORRERRTHRSHLD_2 0x124
#define INTEL_E5IB_CORRERRTHRSHLD_3 0x128

#define INTEL_E5IB_CORRERRORSTATUS 0x134

static void setup_e5ib(struct ecc_info *ctrl)
{
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
#if 0
    unsigned long smictrl = 0, smisparectl = 0;
#endif
    unsigned long pci_id = 0, mmcfg = 0, mmcfglim = 0;
    int mcbank;

    unsigned int correrrcnt = 0, correrrthrshld = 0;
    int fn, rank;
    int ch, slot;
    UINT64 mcgcap = 0;
    UINT64 errctl = 0;
    UINT64 mcgstatus = 0;
    UINT64 mcstatus = 0;
#if 0
    UINT64 mcctl2 = 0;

    UINT64 apicbase = 0;

    unsigned int cmci = 0;
#endif

    MtSupportDebugWriteLine("Intel E5 Ivy Bridge chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 4;
    ctrl->numsl = 2;
    ctrl->mchbar = 0;
    /* Check for ECC & Scrub */

    pci_conf_read(ctrl->bus, ctrl->dev, 0, INTEL_E5IB_MCMTR, 4, &mc_mtr);

    AsciiSPrint(gBuffer, BUF_SIZE, "IB-E MCMTR=%08x", mc_mtr);
    MtSupportDebugWriteLine(gBuffer);

    if ((mc_mtr >> 2) & 0x01)
    {
        ctrl->mode = ECC_CORRECT;
        pci_conf_read(ctrl->bus, ctrl->dev, 1, INTEL_E5IB_SCRUBCTL, 4, &mc_scrubctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "IB-E SCRUBCTL=%08x", mc_scrubctl);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_scrubctl >> 31) & 0x01)
        {
            ctrl->mode = ECC_SCRUB;
        }
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(0, 5, 0, 0, 4, &pci_id);
    if (pci_id == 0x0e288086)
    {
        pci_conf_read(0, 5, 0, 0x84, 4, &mmcfg);
        mmcfg &= 0xFC000000;
        pci_conf_read(0, 5, 0, 0x88, 4, &mmcfglim);
        mmcfglim &= 0xFC000000;

        AsciiSPrint(gBuffer, BUF_SIZE, "IB-E MMCFGBase=%08x, MMCFGLim=%08x", mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "IB-E Device 5, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 22, 1, 0, 4, &pci_id);
        if (pci_id == 0x0ec98086)
        {
            unsigned long mmcfg_rule = 0;
            pci_conf_read(ctrl->bus, 22, 1, 0xc0, 4, &mmcfg_rule);
            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0xFC000000;
                AsciiSPrint(gBuffer, BUF_SIZE, "IB-E [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=%08x, MMCFG=%08x", ctrl->bus, 22, 1, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    if (mmcfg > 0 && mmcfglim > 0 && mmcfg <= mmcfglim) // Sanity check
    {
        ctrl->mchbar = mmcfg;
        for (fn = 2; fn <= 7; fn++)
        {
            if (fn == 2 || fn == 3 || fn == 6 || fn == 7)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1; // CORRERRCNT registers are in devices 16 (15+1) and 30 (29+1)
                    ch = fn <= 3 ? fn : fn - 6;
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error count/threshold registers
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + INTEL_E5IB_CORRERRCNT_0 + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + INTEL_E5IB_CORRERRTHRSHLD_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, fn, INTEL_E5IB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
                    pci_conf_read(ctrl->bus, 16, fn, INTEL_E5IB_CORRERRTHRSHLD_0 + 4 * rank, 4, &correrrthrshld);
#endif
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", fn <= 3 ? fn : fn - 6, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0)
                        writemmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + INTEL_E5IB_CORRERRCNT_0 + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + INTEL_E5IB_CORRERRCNT_0 + 4 * rank));
                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
            }
        }
    }

    // ECC errors also reported in the MSR, read and clear any previous errors
    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
    _rdmsr64(MSR_ERROR_CONTROL, &errctl);

    AsciiSPrint(gBuffer, BUF_SIZE, "IB-E MCG_CAP=" I64HEXFMT ", MCG_STATUS=" I64HEXFMT ", ERROR_CONTROL=" I64HEXFMT, mcgcap, mcgstatus, errctl);
    MtSupportDebugWriteLine(gBuffer);

    for (mcbank = 9; mcbank <= 16; mcbank++)
    {
        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);
#if 0
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_CTL2(mcbank), &mcctl2);
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_CTL2=" I64HEXFMT, mcbank, mcctl2);
        MtSupportDebugWriteLine(gBuffer);

        if ((mcctl2 & 0x7FFFULL) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "IB-E Writing " I64HEXFMT " to MC%d_CTL2", (mcctl2 & ~0x7FFFULL) | 0x1, mcbank);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_CTL2(mcbank), (mcctl2 & ~0x7FFFULL) | 0x1);
        }
#endif
        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "IB-E MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }

#if 0
    _rdmsr64(MSR_IA32_APIC_BASE, &apicbase);
    AsciiSPrint(gBuffer, BUF_SIZE, "APIC_BASE=" I64HEXFMT, apicbase);
    MtSupportDebugWriteLine(gBuffer);

    cmci = readmmio32((unsigned int *)((UINTN)0xFEE002F0));
    AsciiSPrint(gBuffer, BUF_SIZE, "LCT CMCI Register=%08x", cmci);
    MtSupportDebugWriteLine(gBuffer);
#endif
}

static void poll_e5ib(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;

    int mcreg;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    // unsigned int serr0, serr1, serr2;

    UINT8 fn, rank;
    UINT8 ch, slot;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    if (ctrl->mchbar != 0)
    {
        for (fn = 2; fn <= 7; fn++)
        {
            if (fn == 2 || fn == 3 || fn == 6 || fn == 7)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1; // CORRERRCNT registers are in devices 16 (15+1) and 30 (29+1)
                    ch = fn <= 3 ? fn : fn - 6;
                    slot = rank < 2 ? 0 : 1;

                    correrrcnt = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fn * 0x1000) + INTEL_E5IB_CORRERRCNT_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, fn, INTEL_E5IB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
#endif

                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, fn <= 3 ? fn : fn-6, rank < 2 ? 0 : 1);

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, fn <= 3 ? fn : fn-6, rank < 2 ? 0 : 1);
                    }
                }
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    // Poll MCE MSR registers as well for debug. But don't report any errors
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    for (mcreg = 9; mcreg <= 16; mcreg++)
    {
        UINT64 mcstatus = 0;
        UINT64 mcmisc = 0;
        UINT64 mcaddr = 0;

        _rdmsr64(MSR_IA32_MCi_STATUS(mcreg), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            BOOLEAN uncorrected_error;
            UINT32 mserr;
            UINT32 channel;
            UINT64 addrmask;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Recoverable=%s, Corrected error count=%d, Error code=%04X)", mcreg, mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 56)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);
                AsciiSPrint(gBuffer, BUF_SIZE, "Transaction error type: ");
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x001:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address parity error");
                break;
            case 0x002:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA Wrt buffer Data parity error");
                break;
            case 0x004:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA Wrt byte enable parity error");
                break;
            case 0x008:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected patrol scrub error");
                break;
            case 0x010:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x020:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected spare error");
                break;
            case 0x040:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected spare error");
                break;
            case 0x100:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "iMC, WDB, parity errors");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
                _rdmsr64(MSR_IA32_MCi_ADDR(mcreg), &mcaddr);

            if (mcstatus & MCI_STATUS_MISCV)
                _rdmsr64(MSR_IA32_MCi_MISC(mcreg), &mcmisc);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcreg, mcaddr);
            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcreg, mcmisc);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_MCi_STATUS(mcreg), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;

            channel = (UINT32)(mcstatus & 0xF);
            addrmask = LShiftU64(1, mcmisc & 0x3F);
            addrmask = ~(addrmask - 1);
#if 0
            MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, channel, -1);
#endif
        }
    }
}

/*
 * Xeon E5 v3 Family memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v3-datasheet-vol-2.html
 */
#define INTEL_E5HASWELL_MCMTR 0x7C
#define INTEL_E5HASWELL_SCRUBCTL 0xA0

#define INTEL_E5HASWELL_CORRERRCNT_0 0x104
#define INTEL_E5HASWELL_CORRERRCNT_1 0x108
#define INTEL_E5HASWELL_CORRERRCNT_2 0x10C
#define INTEL_E5HASWELL_CORRERRCNT_3 0x110

#define INTEL_E5HASWELL_CORRERRTHRSHLD_0 0x11C
#define INTEL_E5HASWELL_CORRERRTHRSHLD_1 0x120
#define INTEL_E5HASWELL_CORRERRTHRSHLD_2 0x124
#define INTEL_E5HASWELL_CORRERRTHRSHLD_3 0x128

#define INTEL_E5HASWELL_CORRERRORSTATUS 0x134

static void setup_e5haswell(struct ecc_info *ctrl)
{
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
#if 0
    unsigned long smictrl = 0, smisparectl = 0;
#endif
    unsigned long pci_id = 0, mmcfg = 0, mmcfglim = 0;
    int mcbank;

    unsigned int correrrcnt = 0, correrrthrshld = 0;

    unsigned long imcch2_did = 0;
    const int fnlist[] = {2, 3};

    UINT8 numdev = 1;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int rank;
    int ch, slot;

    UINT64 mcgcap = 0;
#if 0
    UINT64 errctl = 0;
#endif
    UINT64 mcgstatus = 0;
    UINT64 mcstatus = 0;
#if 0
    UINT64 mcctl2 = 0;

    UINT64 apicbase = 0;

    unsigned int cmci = 0;
#endif

    MtSupportDebugWriteLine("Intel E5 Haswell-E chipset init");

    AsciiSPrint(gBuffer, BUF_SIZE, "numdev=%d, numfn=%d", numdev, numfn);
    MtSupportDebugWriteLine(gBuffer);

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 4;
    ctrl->numsl = 2;
    ctrl->mchbar = 0;

    /* Check for ECC & Scrub */

    pci_conf_read(ctrl->bus, ctrl->dev, 0, INTEL_E5HASWELL_MCMTR, 4, &mc_mtr);

    AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E MCMTR=%08x", mc_mtr);
    MtSupportDebugWriteLine(gBuffer);

    if ((mc_mtr >> 2) & 0x01)
    {
        ctrl->mode = ECC_CORRECT;
        pci_conf_read(ctrl->bus, ctrl->dev, 1, INTEL_E5HASWELL_SCRUBCTL, 4, &mc_scrubctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E SCRUBCTL=%08x", mc_scrubctl);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_scrubctl >> 31) & 0x01)
        {
            ctrl->mode = ECC_SCRUB;
        }
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(0, 5, 0, 0, 4, &pci_id);
    if (pci_id == 0x2f288086)
    {
        pci_conf_read(0, 5, 0, 0x90, 4, &mmcfg);
        mmcfg &= 0xFC000000;
        pci_conf_read(0, 5, 0, 0x98, 4, &mmcfglim);
        mmcfglim &= 0xFC000000;

        AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E MMCFGBase=%08x, MMCFGLim=%08x", mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E Device 5, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 15, 5, 0, 4, &pci_id);
        if (pci_id == 0x2ffd8086)
        {
            unsigned long mmcfg_rule = 0;
            pci_conf_read(ctrl->bus, 15, 5, 0xc0, 4, &mmcfg_rule);
            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0xFC000000;
                AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=%08x, MMCFG=%08x", ctrl->bus, 15, 5, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    if (mmcfg > 0 && mmcfglim > 0 && mmcfg <= mmcfglim) // Sanity check
    {
        ctrl->mchbar = mmcfg;

        // Check if channels 2-3 are available
        pci_conf_read(ctrl->bus, ctrl->dev + 2, fnlist[0], PCI_DEVICE_ID, 2, &imcch2_did);

        if (imcch2_did == 0x2fb6 || imcch2_did == 0x2fd6) // If the device ID is 0x2fb6 or 0x2fd6, channels 2-3 are available
            numdev = 2;
        else
            numdev = 1;

        if (numdev == 2)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E Found channels 2-3 at %d-%d-%d", ctrl->bus, ctrl->dev + 2, fnlist[0]);
            MtSupportDebugWriteLine(gBuffer);
        }

        ctrl->numch = numdev * numfn;
        for (i = 0; i < numdev; i++)
        {
            for (j = 0; j < numfn; j++)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1 + i; // CORRERRCNT registers are in devices 20 (19+1), 21 (19+2) and 23 (22+1)
                    ch = i * numfn + j;
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error/threshold registers
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_E5HASWELL_CORRERRCNT_0 + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_E5HASWELL_CORRERRTHRSHLD_0 + 4 * rank));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", ch, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0)
                        writemmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_E5HASWELL_CORRERRCNT_0 + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_E5HASWELL_CORRERRCNT_0 + 4 * rank));
                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
            }
        }
    }

    // ECC errors also reported in the MSR, read and clear any previous errors
    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
#if 0
    _rdmsr64(MSR_ERROR_CONTROL, &errctl);
#endif
    AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E MCG_CAP=" I64HEXFMT ", MCG_STATUS=" I64HEXFMT, mcgcap, mcgstatus);
    MtSupportDebugWriteLine(gBuffer);

    for (mcbank = 9; mcbank <= 16; mcbank++)
    {
        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);
#if 0
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_CTL2(mcbank), &mcctl2);
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_CTL2=" I64HEXFMT, mcbank, mcctl2);
        MtSupportDebugWriteLine(gBuffer);

        if ((mcctl2 & 0x7FFFULL) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "IB-E Writing " I64HEXFMT " to MC%d_CTL2", (mcctl2 & ~0x7FFFULL) | 0x1, mcbank);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_CTL2(mcbank), (mcctl2 & ~0x7FFFULL) | 0x1);
        }
#endif
        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Haswell-E MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }

#if 0
    _rdmsr64(MSR_IA32_APIC_BASE, &apicbase);
    AsciiSPrint(gBuffer, BUF_SIZE, "APIC_BASE=" I64HEXFMT, apicbase);
    MtSupportDebugWriteLine(gBuffer);

    cmci = readmmio32((unsigned int *)((UINTN)0xFEE002F0));
    AsciiSPrint(gBuffer, BUF_SIZE, "LCT CMCI Register=%08x", cmci);
    MtSupportDebugWriteLine(gBuffer);
#endif
}

static void poll_e5haswell(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;

    int mcreg;

    unsigned int correrrcnt[MAX_UMC * MAX_SLOTS_PER_UMC]; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    unsigned long imcch2_did = 0;
    // unsigned int serr0, serr1, serr2;
    const int fnlist[] = {2, 3};

    UINT8 numdev = 1;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    UINT8 i, j;
    int rank;
    UINT8 ch, slot;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    if (ctrl->mchbar != 0)
    {
        // Check if channels 2-3 are available
        pci_conf_read(ctrl->bus, ctrl->dev + 2, fnlist[0], PCI_DEVICE_ID, 2, &imcch2_did);

        if (imcch2_did == 0x2fb6 || imcch2_did == 0x2fd6) // If the device ID is 0x2fb6 or 0x2fd6, channels 2-3 are available
            numdev = 2;
        else
            numdev = 1;

        for (i = 0; i < numdev; i++)
        {
            for (j = 0; j < numfn; j++)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1 + i; // CORRERRCNT registers are in devices 20 (19+1), 21 (19+2) and 23 (22+1)
                    ch = i * numfn + j;
                    slot = rank < 2 ? 0 : 1;

                    int ridx = ch * 4 + rank;
                    correrrcnt[ridx] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_E5HASWELL_CORRERRCNT_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, dev, INTEL_E5IB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
#endif

                    if (correrrcnt[ridx] != 0)
                    {
                        if ((correrrcnt[ridx] & 0x00007FFF) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += correrrcnt[ridx] & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                        if ((correrrcnt[ridx] & 0x7FFF0000) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += (correrrcnt[ridx] >> 16) & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                    }
                }
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                for (rank = 0; rank < 4; rank++)
                {
                    int ridx = ch * 4 + rank;
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] CORRERRCNT_%d=%08x", ch, rank, correrrcnt[ridx]);
                    MtSupportDebugWriteLine(gBuffer);
                }
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev= %d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    // Poll MCE MSR registers as well for debug. But don't report any errors
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    for (mcreg = 9; mcreg <= 16; mcreg++)
    {
        UINT64 mcstatus = 0;
        UINT64 mcmisc = 0;
        UINT64 mcaddr = 0;

        _rdmsr64(MSR_IA32_MCi_STATUS(mcreg), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            BOOLEAN uncorrected_error;
            UINT32 mserr;
            UINT32 channel;
            UINT64 addrmask;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Recoverable=%s, Corrected error count=%d, Error code=%04X)", mcreg, mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 56)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);
                AsciiSPrint(gBuffer, BUF_SIZE, "Transaction error type: ");
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x001:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Address parity error");
                break;
            case 0x002:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected HA write data error");
                break;
            case 0x004:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected HA data byte enable error");
                break;
            case 0x008:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected patrol scrub error");
                break;
            case 0x010:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x020:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected spare error");
                break;
            case 0x040:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected spare error");
                break;
            case 0x080:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected memory read error");
                break;
            case 0x100:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "iMC, WDB, parity errors");
                break;
            case 0x200:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR4 command address parity error");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
                _rdmsr64(MSR_IA32_MCi_ADDR(mcreg), &mcaddr);

            if (mcstatus & MCI_STATUS_MISCV)
                _rdmsr64(MSR_IA32_MCi_MISC(mcreg), &mcmisc);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcreg, mcaddr);
            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcreg, mcmisc);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_MCi_STATUS(mcreg), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;

            channel = (UINT32)(mcstatus & 0xF);
            addrmask = LShiftU64(1, mcmisc & 0x3F);
            addrmask = ~(addrmask - 1);
#if 0
            MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, channel, -1);
#endif
        }
    }
}

/*
 * Xeon D 1500 Family memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-d-1500-datasheet-vol-2.html
 */
#define INTEL_BROADWELL_MCMTR 0x7C
#define INTEL_BROADWELL_TOLM 0xD0
#define INTEL_BROADWELL_TOHM_0 0xD4
#define INTEL_BROADWELL_TOHM_1 0xD8

#define INTEL_BROADWELL_DRAM_RULE(index) (0x60 + index * 8)
#define INTEL_BROADWELL_INTERLEAVE_LIST(index) (0x64 + index * 8)
#define INTEL_BROADWELL_TAD(index) (0x40 + index * 4)

#define INTEL_BROADWELL_HASYSDEFEATURE 0x80
#define INTEL_BROADWELL_HASYSDEFEATURE2 0x84
#define INTEL_BROADWELL_SAD_CONTROL 0xF4

#define INTEL_BROADWELL_TADWAYNESS(index) (0x80 + index * 4)
#define INTEL_BROADWELL_TADCHNILVOFFSET(index) (0x90 + index * 4)
#define INTEL_BROADWELL_RIRWAYNESSLIMIT(index) (0x108 + index * 4)
#define INTEL_BROADWELL_RIRILVOFFSET(index, rank) (0x120 + index * 16 + rank * 4)
#define INTEL_BROADWELL_SCRUBCTL 0xA0

#define INTEL_BROADWELL_CORRERRCNT_0 0x104
#define INTEL_BROADWELL_CORRERRCNT_1 0x108
#define INTEL_BROADWELL_CORRERRCNT_2 0x10C
#define INTEL_BROADWELL_CORRERRCNT_3 0x110

#define INTEL_BROADWELL_CORRERRTHRSHLD_0 0x11C
#define INTEL_BROADWELL_CORRERRTHRSHLD_1 0x120
#define INTEL_BROADWELL_CORRERRTHRSHLD_2 0x124
#define INTEL_BROADWELL_CORRERRTHRSHLD_3 0x128

#define INTEL_BROADWELL_CORRERRORSTATUS 0x134

#define INTEL_BROADWELL_DIMMTEMPSTAT_0 0x150
#define INTEL_BROADWELL_DIMMTEMPSTAT_1 0x154
#define INTEL_BROADWELL_DIMMTEMPSTAT_2 0x158

#define INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_LO 0x1C0
#define INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_HI 0x1C4
#define INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_LO 0x1C8
#define INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_HI 0x1CC
#define INTEL_BROADWELL_RSP_FUNC_RANK_BANK_MATCH 0x214
#define INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK 0x200
#define INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 0x204
#define INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_EXTRA 0x208

static void setup_broadwell(struct ecc_info *ctrl)
{
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
#if 0
    unsigned long smictrl = 0, smisparectl = 0;
#endif
    unsigned long pci_id = 0, mmcfg = 0, mmcfglim = 0;

    unsigned int correrrcnt = 0, correrrthrshld = 0;

    const int fnlist[] = {2, 3};

    UINT8 numdev = 1;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int rank;
    int ch, slot;

    int mcbank;
    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;

    MtSupportDebugWriteLine("Intel Broadwell-DE chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->mchbar = 0;

    // Check if channels 2-3 are available
    pci_conf_read(ctrl->bus, 22, 0, PCI_DEVICE_ID, 2, &pci_id);

    if (pci_id == 0x6F68) // If IMC1 exists, 2 channels are available. Otherwise, 4 channels are available.
        numdev = 1;
    else
        numdev = 2;

    ctrl->numch = numdev * 2;

    AsciiSPrint(gBuffer, BUF_SIZE, "numdev=%d, numfn=%d", numdev, numfn);
    MtSupportDebugWriteLine(gBuffer);

    /* Check for ECC & Scrub */

    pci_conf_read(ctrl->bus, ctrl->dev, 0, INTEL_BROADWELL_MCMTR, 4, &mc_mtr);

    AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE MCMTR=%08x", mc_mtr);
    MtSupportDebugWriteLine(gBuffer);

    if ((mc_mtr >> 2) & 0x01)
    {
        ctrl->mode = ECC_CORRECT;
        pci_conf_read(ctrl->bus, ctrl->dev, 1, INTEL_BROADWELL_SCRUBCTL, 4, &mc_scrubctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE SCRUBCTL=%08x", mc_scrubctl);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_scrubctl >> 31) & 0x01)
        {
            ctrl->mode = ECC_SCRUB;
        }
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(0, 5, 0, 0, 4, &pci_id);
    if (pci_id == 0x6f288086)
    {
        pci_conf_read(0, 5, 0, 0x90, 4, &mmcfg);
        mmcfg &= 0xFC000000;
        pci_conf_read(0, 5, 0, 0x98, 4, &mmcfglim);
        mmcfglim &= 0xFC000000;

        AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE MMCFGBase=%08x, MMCFGLim=%08x", mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE Device 5, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 15, 5, 0, 4, &pci_id);
        if (pci_id == 0x6ffd8086)
        {
            unsigned long mmcfg_rule = 0;
            pci_conf_read(ctrl->bus, 15, 5, 0xc0, 4, &mmcfg_rule);
            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0xFC000000;
                AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=%08x, MMCFG=%08x", ctrl->bus, 15, 5, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    if (mmcfg > 0 && mmcfglim > 0 && mmcfg <= mmcfglim) // Sanity check
    {
        ctrl->mchbar = mmcfg;

        for (i = 0; i < numdev; i++)
        {
            for (j = 0; j < numfn; j++)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1 + i; // CORRERRCNT registers are in devices 20 (19+1)
                    ch = i * numfn + j;
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error/threshold registers
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_CORRERRCNT_0 + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_CORRERRTHRSHLD_0 + 4 * rank));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d/Slot %d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", ch, slot, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0)
                        writemmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_CORRERRCNT_0 + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_CORRERRCNT_0 + 4 * rank));
                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
            }
        }
    }

    // ECC errors also reported in the MSR, read and clear any previous errors
    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

#if 0
    _rdmsr64(MSR_ERROR_CONTROL, &errctl);
#endif
    AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE MCG_CAP=" I64HEXFMT ", MCG_STATUS=" I64HEXFMT, mcgcap, mcgstatus);
    MtSupportDebugWriteLine(gBuffer);

    for (mcbank = 9; mcbank <= 16; mcbank++)
    {
        UINT64 mcstatus = 0;
        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);
#if 0
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_CTL2(mcbank), &mcctl2);
        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_CTL2=" I64HEXFMT, mcbank, mcctl2);
        MtSupportDebugWriteLine(gBuffer);

        if ((mcctl2 & 0x7FFFULL) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "IB-E Writing " I64HEXFMT " to MC%d_CTL2", (mcctl2 & ~0x7FFFULL) | 0x1, mcbank);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_CTL2(mcbank), (mcctl2 & ~0x7FFFULL) | 0x1);
        }
#endif
        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Broadwell-DE MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }

#if 0
    _rdmsr64(MSR_IA32_APIC_BASE, &apicbase);
    AsciiSPrint(gBuffer, BUF_SIZE, "APIC_BASE=" I64HEXFMT, apicbase);
    MtSupportDebugWriteLine(gBuffer);

    cmci = readmmio32((unsigned int *)((UINTN)0xFEE002F0));
    AsciiSPrint(gBuffer, BUF_SIZE, "LCT CMCI Register=%08x", cmci);
    MtSupportDebugWriteLine(gBuffer);
#endif
}

static void poll_broadwell(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;

    int mcreg;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    // unsigned int serr0, serr1, serr2;
    const int fnlist[] = {2, 3};

    UINT8 numdev = ctrl->numch / 2;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    UINT8 i, j;
    int rank;
    UINT8 ch, slot;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    if (ctrl->mchbar != 0)
    {
        for (i = 0; i < numdev; i++)
        {
            for (j = 0; j < numfn; j++)
            {
                for (rank = 0; rank < 4; rank++)
                {
                    int dev = ctrl->dev + 1 + i; // CORRERRCNT registers are in devices 20 (19+1)
                    ch = i * numfn + j;
                    slot = rank < 2 ? 0 : 1;

                    correrrcnt = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_CORRERRCNT_0 + 4 * rank));
#if 0
                    pci_conf_read(ctrl->bus, 16, dev, INTEL_E5IB_CORRERRCNT_0 + 4 * rank, 4, &correrrcnt);
#endif

                    if (correrrcnt != 0)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                    }
                }
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    // Poll MCE MSR registers as well for debug. But don't report any errors
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    for (mcreg = 9; mcreg <= 16; mcreg++)
    {
        UINT64 mcstatus = 0;
        UINT64 mcmisc = 0;
        UINT64 mcaddr = 0;

        _rdmsr64(MSR_IA32_MCi_STATUS(mcreg), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            BOOLEAN uncorrected_error;
            UINT32 mserr;
            UINT32 channel;
            UINT64 addrmask;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Recoverable=%s, Corrected error count=%d, Error code=%04X)", mcreg, mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 56)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);
                AsciiSPrint(gBuffer, BUF_SIZE, "Transaction error type: ");
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x001:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Address parity error");
                break;
            case 0x002:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected HA write data error");
                break;
            case 0x004:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected HA data byte enable error");
                break;
            case 0x008:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected patrol scrub error");
                break;
            case 0x010:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x020:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected spare error");
                break;
            case 0x040:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected spare error");
                break;
            case 0x080:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected memory read error");
                break;
            case 0x100:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "iMC, WDB, parity errors");
                break;
            case 0x200:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR4 command address parity error");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
                _rdmsr64(MSR_IA32_MCi_ADDR(mcreg), &mcaddr);

            if (mcstatus & MCI_STATUS_MISCV)
                _rdmsr64(MSR_IA32_MCi_MISC(mcreg), &mcmisc);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcreg, mcaddr);
            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcreg, mcmisc);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_MCi_STATUS(mcreg), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;

            channel = (UINT32)(mcstatus & 0xF);
            addrmask = LShiftU64(1, mcmisc & 0x3F);
            addrmask = ~(addrmask - 1);
#if 0
            MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, channel, -1);
#endif
        }
    }
}

int poll_temp_broadwell(struct ecc_info *ctrl)
{
    // unsigned int serr0, serr1, serr2;
    const int fnlist[] = {0, 1};
    UINT8 numdev = ctrl->numch / 2;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int ch, slot;

    if (ctrl->mchbar != 0)
    {
        for (i = 0; i < numdev; i++)
        {
            for (j = 0; j < numfn; j++)
            {
                for (slot = 0; slot < 2; slot++)
                {
                    unsigned dimmtempstat;
                    unsigned char dimm_temp;

                    int dev = ctrl->dev + 1 + i; // CORRERRCNT registers are in devices 20 + 21 (19+1)
                    ch = i * numfn + j;

                    dimmtempstat = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_BROADWELL_DIMMTEMPSTAT_0 + 4 * slot));
                    AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_broadwell - [Bus:%02X Dev:%02X Fun:%02X] {Ch: %d Sl: %d} DIMMTEMPSTAT=%08x", ctrl->bus, dev, fnlist[j], ch, slot, dimmtempstat);
                    MtSupportDebugWriteLine(gBuffer);

                    dimm_temp = dimmtempstat & 0xff;

                    ctrl->dimmtemp[ch * ctrl->numsl + slot] = dimm_temp;
                }
            }
        }
    }
    return 0;
}

int decode_broadwell(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{

    return -1;
}

// Reference: Intel Xeon Processor D-1500 Product Family External Design Specification(EDS), Volume Two : Core and Uncore Registers (Doc. No.: 544041, Rev.: 2.5)
BOOLEAN inject_broadwell(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;

    int fn;

    UINT64 lt_lock_memory = 0;
    ulong capid0 = 0;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    //  The BIOS must unlock the memory by writing all 0s to this MSR if the following conditions exist:
    // - CPUID.(EAX=01h):EAX[31:0] == 000306Fxh (where 'x' is any stepping number)
    // - CPUID.(EAX=01h):ECX[6] == 1 (that is, Intel TXT capable)
    // - PCH is TXT capable (Refer to the PCH BIOS Spec and EDS for the capability detection details)
    // - The platform is selected to be Intel TXT disabled.
    // For all NBSPs of each socket, before memory initialization and after QPI init is completed: MSR 2E6h == 0
    // NOTE: Attempts to read this MSR will cause a #GP fault in any configuration. Writes to this MSR on a system with non TXT capable PCH will cause a #GP fault.
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - CPUID.(EAX=01h):EAX[31:0] = %08x", cpu_id.vers.flat);
    MtSupportDebugWriteLine(gBuffer);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - CPUID.(EAX=01h):ECX[31:0] = %08x", cpu_id.fid.uint32_array[1]);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, 30, 3, 0x84, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - PCU CAPID0 = %08x (Intel TXT = %d)", capid0, (capid0 >> 19) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid0 >> 19) & 0x1) == 0) // if Intel TXT is disabled
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - writing 0 to LT_UNLOCK_MEMORY");
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_LT_UNLOCK_MEMORY, 0); // Unlock

        _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
        MtSupportDebugWriteLine(gBuffer);

        if (lt_lock_memory & 0x1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - writing " I64HEXFMT " to LT_LOCK_MEMORY", lt_lock_memory & ~0x1ULL);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_LT_LOCK_MEMORY, lt_lock_memory & ~0x1ULL); // Unlock

            _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - new LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
            MtSupportDebugWriteLine(gBuffer);
        }
    }

    if (lt_lock_memory & 0x1)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - **WARNING** ECC injection is locked and unavailable");
        MtSupportDebugWriteLine(gBuffer);
        return FALSE;
    }
    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        for (fn = 2; fn <= 3; fn++)
        {
            UINT64 addr_match = 0, new_addr_match = 0x100000;
            UINT64 addr_mask = 0, new_addr_mask = ~new_addr_match;

            unsigned long value, new_value;

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_LO));
            addr_match = (UINT64)value << 3;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_LO, value);
            MtSupportDebugWriteLine(gBuffer);

            new_value = (unsigned long)RShiftU64(new_addr_match, 3); // addr_match_lower - Addr Match Lower: 32-bits (Match Addr[34:3])

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_LO, new_value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_LO), new_value);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_HI));
            addr_match |= ((UINT64)value & 0x7FF) << 35;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_HI, value);
            MtSupportDebugWriteLine(gBuffer);

            new_value = value;
            new_value &= ~0x1FFF;
            new_value |= (unsigned long)RShiftU64(new_addr_match, 35) & 0x7FF; // Addr Match Higher : 11-Bits (Match Addr[45:35])
            new_value |= (1 << 11);                                            //  rsp_func_addr_match_en - Enabling the Address Match Response Function when set.
            new_value |= (1 << 12);                                            //  rsp_func_addr_match_always - The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if this field is set. Continuous address matching.

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_HI, new_value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MATCH_HI), new_value);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_LO));
            addr_mask = (UINT64)value << 3;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_LO, value);
            MtSupportDebugWriteLine(gBuffer);

            new_value = (unsigned long)RShiftU64(new_addr_mask, 3); // addr_mask_lower - Address Mask to deselect (when set) the corresponding Addr[34:3] for the address match.

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_LO, new_value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_LO), new_value);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_HI));
            addr_mask |= ((UINT64)value & 0x7FF) << 35;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_HI, value);
            MtSupportDebugWriteLine(gBuffer);

            new_value = value;
            new_value &= ~0x7FF;
            new_value |= (unsigned long)RShiftU64(new_addr_mask, 35) & 0x7FF; // addr_mask_higher - Address Mask to deselect (when set) the corresponding Addr[45:35] for the address match.

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_HI, new_value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_ADDR_MASK_HI), new_value);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_RANK_BANK_MATCH));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_RANK_BANK_MATCH=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_RANK_BANK_MATCH, value);
            MtSupportDebugWriteLine(gBuffer);

            if ((value & (1 << 31)) == 0) // en - Enable rank and bank matching
            {
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_RANK_BANK_MATCH), value | (1 << 31));
            }

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK, value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK), 1);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK, value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK), 1);

            value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_EXTRA));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_EXTRA, value);
            MtSupportDebugWriteLine(gBuffer);

            new_value = value;
            new_value &= 0xC3FFE0E0;
            new_value |= 0x3 << 28;
            new_value |= 0x3 << 26;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, 19, fn, INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_EXTRA, new_value);
            MtSupportDebugWriteLine(gBuffer);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (19 * 0x8000) + (fn * 0x1000) + INTEL_BROADWELL_RSP_FUNC_CRC_ERR_INJ_EXTRA), new_value);
        }
    }
    return TRUE;
}

/*
 * Skylake SP (Skylake Scalable Performance)
 *
 * Reference: Skylake Server Processor External Design Specification (EDS), Volume Two: Registers, Part A (Doc. No.: 546832, Rev.: 1.5)
 */
#define INTEL_SKYLAKE_SP_MEMORY 0xD8
#define INTEL_SKYLAKE_SP_MCMTR 0x87C
#define INTEL_SKYLAKE_SP_SCRUBCTL 0x914

#define INTEL_SKYLAKE_SP_MC0_DP_CHKN_BIT 0x700
#define INTEL_SKYLAKE_SP_DIS_CORR_ERR_LOG 0x704
#define INTEL_SKYLAKE_SP_CPGC_GLOBALERR 0xb04
#define INTEL_SKYLAKE_SP_CPCG_ERR_ECC 0x554

#define INTEL_SKYLAKE_SP_CORRERRCNT_0 0x104
#define INTEL_SKYLAKE_SP_CORRERRCNT_1 0x108
#define INTEL_SKYLAKE_SP_CORRERRCNT_2 0x10C
#define INTEL_SKYLAKE_SP_CORRERRCNT_3 0x110

#define INTEL_SKYLAKE_SP_CORRERRTHRSHLD_0 0x11C
#define INTEL_SKYLAKE_SP_CORRERRTHRSHLD_1 0x120
#define INTEL_SKYLAKE_SP_CORRERRTHRSHLD_2 0x124
#define INTEL_SKYLAKE_SP_CORRERRTHRSHLD_3 0x128

#define INTEL_SKYLAKE_SP_CORRERRORSTATUS 0x134
#define INTEL_SKYLAKE_SP_RETRY_RD_ERR_LOG 0x154

#define INTEL_SKYLAKE_SP_TCDBP 0x200

#define INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_LO 0x1C0
#define INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_HI 0x1C4
#define INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_LO 0x1C8
#define INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_HI 0x1CC
#define INTEL_SKYLAKE_SP_RSP_FUNC_RANK_BANK_MATCH 0x1D0
#define INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK 0x200
#define INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 0x204
#define INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA 0x208

#define INTEL_SKYLAKE_SP_CPUBUSNO 0xCC
#define INTEL_SKYLAKE_SP_CPUBUSNO1 0xD0

#define INTEL_SKYLAKE_SP_MC_BIOS_REQ 0x98
#define INTEL_SKYLAKE_SP_MC_BIOS_DATA 0x9C
#define INTEL_SKYLAKE_SP_CAPID0 0x84
#define INTEL_SKYLAKE_SP_CAPID1 0x88
#define INTEL_SKYLAKE_SP_CAPID2 0x8C
#define INTEL_SKYLAKE_SP_CAPID3 0x90
#define INTEL_SKYLAKE_SP_DEFEATURES0 0xe4

#define MSR_CPU_BUS_NUMBER 0x300

typedef struct
{
    unsigned char cpubusno[6];
} skylake_sp_data;

static void setup_skylake_sp(struct ecc_info *ctrl)
{
    unsigned long val = 0;
    unsigned long capid3 = 0;
    unsigned long defeatures0 = 0;
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
    unsigned long pci_id = 0;
    UINT64 mmcfg = 0, mmcfglim = 0;

    unsigned int correrrcnt = 0, correrrthrshld = 0;

    const int fnlist[] = {3, 7};

    UINT8 numdev = 2;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int rank;
    int ch, slot;

    int mcbank;
    UINT64 cpubusno_cfg = 0;
    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;

    ctrl->userdata = AllocateZeroPool(sizeof(skylake_sp_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    skylake_sp_data *sklspdata = (skylake_sp_data *)ctrl->userdata;

    MtSupportDebugWriteLine("Intel Skylake-SP chipset init");

    AsciiSPrint(gBuffer, BUF_SIZE, "numdev=%d, numfn=%d", numdev, numfn);
    MtSupportDebugWriteLine(gBuffer);

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 3; // 3 channels per IMC
    ctrl->numsl = 2;
    ctrl->chmode = 0;
    ctrl->mchbar = 0;

    for (unsigned int bus = 0x0; bus < 0x100; bus += 0x10)
    {
        pci_conf_read(bus, 8, 2, INTEL_SKYLAKE_SP_CPUBUSNO, 4, &val);
        if (val == 0xffffffff)
            continue;

        AsciiFPrint(DEBUG_FILE_HANDLE, "Skylake-SP [Bus 0x%02X] CPUBUSNO=%08x", bus, val);

        if (BitExtract(val, 23, 16) == ctrl->bus)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "Skylake-SP [Bus 0x%02X] Found match for CPUBUSNO2 (%02X)", bus, ctrl->bus);

            cpubusno_cfg = val;

            pci_conf_read(bus, 8, 2, INTEL_SKYLAKE_SP_CPUBUSNO1, 4, &val);

            AsciiFPrint(DEBUG_FILE_HANDLE, "Skylake-SP [Bus 0x%02X] CPUBUSNO1=%08x", bus, val);

            cpubusno_cfg = ((UINT64)val << 32) | cpubusno_cfg;

            AsciiFPrint(DEBUG_FILE_HANDLE, "Skylake-SP CPUBUSNO=" I64HEXFMT, cpubusno_cfg);

            break;
        }
    }

    if (cpubusno_cfg == 0)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Skylake-SP - Unable to find CPUBUSNO");
        return;
    }

    for (i = 0; i < ARRAY_SIZE(sklspdata->cpubusno); i++)
    {
        sklspdata->cpubusno[i] = (unsigned char)(RShiftU64(cpubusno_cfg, i * 8) & 0xff);
    }

    pci_conf_read(sklspdata->cpubusno[1], 30, 3, INTEL_SKYLAKE_SP_CAPID3, 4, &capid3);
    unsigned long chn_disable = BitExtract(capid3, 5, 0);
    ctrl->chmode = ctrl->numch - numsetbits32(BitExtract(chn_disable, 3 * ctrl->ctrlno + 2, 3 * ctrl->ctrlno)); // Bits 5:0 correspond to MC1, Channel 2/1/0, and MC0, Channel 2/1/0, respectively.
    AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP - CAPID3 = %08x (DISABLE_ECC = %d, CHN_DISABLE = %x)", capid3, (capid3 >> 10) & 0x1, chn_disable);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid3 >> 10) & 0x1) == 0) // DISABLE_ECC = 0
    {
        ctrl->mode = ECC_CORRECT;
    }

    pci_conf_read(sklspdata->cpubusno[2], 8, 0, INTEL_SKYLAKE_SP_DEFEATURES0, 4, &defeatures0);
    AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP - DEFEATURES0 = %08x (EccOnRetry = %d)", defeatures0, (defeatures0 >> 25) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(sklspdata->cpubusno[0], 5, 0, 0, 4, &pci_id);
    if (pci_id == 0x20248086)
    {
        unsigned long mmcfg_hi = 0, mmcfg_lo = 0;
        unsigned long mmcfglim_hi = 0, mmcfglim_lo = 0;
        pci_conf_read(sklspdata->cpubusno[0], 5, 0, 0x90, 4, &mmcfg_lo);
        pci_conf_read(sklspdata->cpubusno[0], 5, 0, 0x94, 4, &mmcfg_hi);
        mmcfg = LShiftU64(mmcfg_hi, 32) | mmcfg_lo;
        mmcfg &= 0x7FFFFFC000000ULL;

        pci_conf_read(sklspdata->cpubusno[0], 5, 0, 0x98, 4, &mmcfglim_lo);
        pci_conf_read(sklspdata->cpubusno[0], 5, 0, 0x9c, 4, &mmcfglim_hi);
        mmcfglim = LShiftU64(mmcfglim_hi, 32) | mmcfglim_lo;
        mmcfglim &= 0x7FFFFFC000000ULL;

        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP MMCFGBase=" I64HEXFMT ", MMCFGLim=" I64HEXFMT, mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP Device 5, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(sklspdata->cpubusno[1], 29, 1, 0, 4, &pci_id);
        if (pci_id == 0x20558086)
        {
            unsigned long mmcfg_rule_hi = 0;
            unsigned long mmcfg_rule_lo = 0;
            UINT64 mmcfg_rule;

            pci_conf_read(sklspdata->cpubusno[1], 29, 1, 0xc0, 4, &mmcfg_rule_lo);
            pci_conf_read(sklspdata->cpubusno[1], 29, 1, 0xc4, 4, &mmcfg_rule_hi);

            mmcfg_rule = LShiftU64(mmcfg_rule_hi, 32) | mmcfg_rule_lo;

            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0x3FFFFC000000ULL;
                AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=" I64HEXFMT ", MMCFG=" I64HEXFMT, 0x17, 29, 1, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    /* Check for ECC & Scrub */
    if (mmcfg > 0 && mmcfglim > 0 && mmcfg <= mmcfglim) // Sanity check
    {
        ctrl->mchbar = mmcfg;

        mc_mtr = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (0 * 0x1000) + INTEL_SKYLAKE_SP_MCMTR));
        chn_disable = BitExtract(mc_mtr, 20, 18);
        ctrl->chmode = MIN(ctrl->chmode, (unsigned int)(ctrl->numch - numsetbits32(chn_disable)));

        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP MCMTR=%08x (chn_disable=%x)", mc_mtr, chn_disable);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_mtr >> 2) & 0x01)
        {
            // ctrl->mode = ECC_CORRECT;
        }

        unsigned long memory = 0;
        pci_conf_read(ctrl->bus, ctrl->dev == 10 ? 8 : 9, 0, INTEL_SKYLAKE_SP_MEMORY, 4, &memory);
        unsigned long DDR4ChnlPopulation = BitExtract(memory, 2, 0);
        ctrl->chmode = MIN(ctrl->chmode, (unsigned int)numsetbits32(DDR4ChnlPopulation));

        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP Memory=%08x (DDR4ChnlPopulation=%x)", memory, DDR4ChnlPopulation);
        MtSupportDebugWriteLine(gBuffer);

        mc_scrubctl = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (0 * 0x1000) + INTEL_SKYLAKE_SP_SCRUBCTL));

        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP SCRUBCTL=%08x", mc_scrubctl);
        MtSupportDebugWriteLine(gBuffer);

        if ((mc_scrubctl >> 31) & 0x01)
        {
            ctrl->mode = ECC_SCRUB;
        }

        ch = 0;
        for (i = 0; i < numdev && ch < ctrl->numch; i++)
        {
            for (j = 0; j < numfn && ch < ctrl->numch; j++)
            {
                int dev = ctrl->dev + i; // CORRERRCNT registers are in devices 10-13

                // Read corrected error/threshold registers
                val = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_DIS_CORR_ERR_LOG));

                AsciiSPrint(gBuffer, BUF_SIZE, "[Ch %d] dis_corr_err_log=%08x", ch, val);
                MtSupportDebugWriteLine(gBuffer);

                val = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_MC0_DP_CHKN_BIT));

                AsciiSPrint(gBuffer, BUF_SIZE, "[Ch %d] MC0_DP_CHKN_BIT=%08x", ch, val);
                MtSupportDebugWriteLine(gBuffer);

                for (rank = 0; rank < 4; rank++)
                {
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error/threshold registers
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_CORRERRCNT_0 + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_CORRERRTHRSHLD_0 + 4 * rank));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d/Slot %d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", ch, slot, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                        writemmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_CORRERRCNT_0 + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)((UINTN)mmcfg + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_CORRERRCNT_0 + 4 * rank));
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
                ch++;
            }
        }
    }

    // ECC errors also reported in the MSR, read and clear any previous errors
    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP MCG_CAP=" I64HEXFMT ", MCG_STATUS=" I64HEXFMT, mcgcap, mcgstatus);
    MtSupportDebugWriteLine(gBuffer);

    for (mcbank = 13; mcbank <= 18; mcbank++)
    {
        UINT64 mcctl = 0;
        UINT64 mcstatus = 0;

        _rdmsr64(MSR_IA32_MCi_CTL(mcbank), &mcctl);
        AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP MC%d_CTL=" I64HEXFMT, mcbank, mcctl);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Skylake-SP MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }
}

static void poll_skylake_sp(struct ecc_info *ctrl)
{
    UINT64 mcgstatus = 0;

    int mcreg;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    // unsigned int serr0, serr1, serr2;
    const int fnlist[] = {3, 7};

    UINT8 numdev = 2;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int rank;
    UINT8 ch, slot;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    if (ctrl->mchbar != 0)
    {
        ch = 0;
        for (i = 0; i < numdev && ch < ctrl->numch; i++)
        {
            for (j = 0; j < numfn && ch < ctrl->numch; j++)
            {
                int dev = ctrl->dev + i; // CORRERRCNT registers are in devices 10-13

                for (rank = 0; rank < 4; rank++)
                {
                    slot = rank < 2 ? 0 : 1;
                    correrrcnt = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_CORRERRCNT_0 + 4 * rank));

                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                    {
                        if ((correrrcnt & 0x00007FFF) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += correrrcnt & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            dimmerrcnt[ch * ctrl->numsl + slot] += (correrrcnt >> 16) & 0x00007FFF;

                        // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                    }
                }
                ch++;
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    // Poll MCE MSR registers as well for debug. But don't report any errors
    _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);

    for (mcreg = 13; mcreg <= 18; mcreg++)
    {
        UINT64 mcstatus = 0;
        UINT64 mcmisc = 0;
        UINT64 mcaddr = 0;

        _rdmsr64(MSR_IA32_MCi_STATUS(mcreg), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            BOOLEAN uncorrected_error;
            UINT32 mserr;
            UINT32 channel;
            UINT64 addrmask;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)", mcreg, mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);
                AsciiSPrint(gBuffer, BUF_SIZE, "Transaction error type: ");
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x001:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address parity error");
                break;
            case 0x002:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA write data parity error");
                break;
            case 0x004:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "HA write byte enable parity error");
                break;
            case 0x008:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected patrol scrub error");
                break;
            case 0x010:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x020:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected spare error");
                break;
            case 0x040:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected spare error");
                break;
            case 0x080:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Any HA read error");
                break;
            case 0x100:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "WDB read parity error");
                break;
            case 0x108:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR4 link down");
                break;
            case 0x200:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR4 command address parity error");
                break;
            case 0x0400:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected address parity error");
                break;
            case 0x0800:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Unrecognized request type");
                break;
            case 0x0801:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Read response to an invalid scoreboard entry");
                break;
            case 0x0802:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Unexpected read response");
                break;
            case 0x0803:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR4 completion to an invalid scoreboard entry");
                break;
            case 0x0804:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Completion to an invalid scoreboard entry");
                break;
            case 0x0805:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Completion FIFO overflow");
                break;
            case 0x0806:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Correctable parity error");
                break;
            case 0x0807:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrectable error");
                break;
            case 0x0808:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Interrupt received while outstanding interrupt was not ACKed");
                break;
            case 0x0809:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "ERID FIFO overflow");
                break;
            case 0x080a:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Error on Write credits");
                break;
            case 0x080b:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Error on Read credits");
                break;
            case 0x080c:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Scheduler error");
                break;
            case 0x080d:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDRT link retry");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
                _rdmsr64(MSR_IA32_MCi_ADDR(mcreg), &mcaddr);

            if (mcstatus & MCI_STATUS_MISCV)
                _rdmsr64(MSR_IA32_MCi_MISC(mcreg), &mcmisc);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcreg, mcaddr);
            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcreg, mcmisc);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_MCi_STATUS(mcreg), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;

            channel = (UINT32)(mcstatus & 0xF);
            addrmask = LShiftU64(1, mcmisc & 0x3F);
            addrmask = ~(addrmask - 1);
#if 0
            MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, channel, -1);
#endif
        }
    }
}

// Reference: Intel Xeon Processor D-1500 Product Family External Design Specification(EDS), Volume Two : Core and Uncore Registers (Doc. No.: 544041, Rev.: 2.5)
void inject_skylake_sp(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;

    UINT64 lt_lock_memory = 0;
    ulong capid0 = 0;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    //  The BIOS must unlock the memory by writing all 0s to this MSR if the following conditions exist:
    // - CPUID.(EAX=01h):EAX[31:0] == 000306Fxh (where 'x' is any stepping number)
    // - CPUID.(EAX=01h):ECX[6] == 1 (that is, Intel TXT capable)
    // - PCH is TXT capable (Refer to the PCH BIOS Spec and EDS for the capability detection details)
    // - The platform is selected to be Intel TXT disabled.
    // For all NBSPs of each socket, before memory initialization and after QPI init is completed: MSR 2E6h == 0
    // NOTE: Attempts to read this MSR will cause a #GP fault in any configuration. Writes to this MSR on a system with non TXT capable PCH will cause a #GP fault.
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - CPUID.(EAX=01h):EAX[31:0] = %08x", cpu_id.vers.flat);
    MtSupportDebugWriteLine(gBuffer);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - CPUID.(EAX=01h):ECX[31:0] = %08x", cpu_id.fid.uint32_array[1]);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, 30, 3, 0x84, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - PCU CAPID0 = %08x (Intel TXT = %d)", capid0, (capid0 >> 19) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid0 >> 19) & 0x1) == 0) // if Intel TXT is disabled
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - writing 0 to LT_UNLOCK_MEMORY");
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_LT_UNLOCK_MEMORY, 0); // Unlock

        _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
        MtSupportDebugWriteLine(gBuffer);

        if (lt_lock_memory & 0x1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - writing " I64HEXFMT " to LT_LOCK_MEMORY", lt_lock_memory & ~0x1ULL);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_LT_LOCK_MEMORY, lt_lock_memory & ~0x1ULL); // Unlock
        }
    }
    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        UINT64 addr_match = 0, new_addr_match = 0x100000;
        UINT64 addr_mask = 0, new_addr_mask = ~new_addr_match;

        unsigned long value, new_value;

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_LO));
        addr_match = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_match, 3); // addr_match_lower - Addr Match Lower: 32-bits (Match Addr[34:3])

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_LO), new_value);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_HI));
        addr_match |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x1FFF;
        new_value |= (unsigned long)RShiftU64(new_addr_match, 35) & 0x7FF; // Addr Match Higher : 11-Bits (Match Addr[45:35])
        new_value |= (1 << 11);                                            //  rsp_func_addr_match_en - Enabling the Address Match Response Function when set.
        new_value |= (1 << 12);                                            //  rsp_func_addr_match_always - The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if this field is set. Continuous address matching.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MATCH_HI), new_value);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_LO));
        addr_mask = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_mask, 3); // addr_mask_lower - Address Mask to deselect (when set) the corresponding Addr[34:3] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_LO), new_value);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_HI));
        addr_mask |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x7FF;
        new_value |= (unsigned long)RShiftU64(new_addr_mask, 35) & 0x7FF; // addr_mask_higher - Address Mask to deselect (when set) the corresponding Addr[45:35] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_ADDR_MASK_HI), new_value);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_RANK_BANK_MATCH));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_RANK_BANK_MATCH=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_RANK_BANK_MATCH, value);
        MtSupportDebugWriteLine(gBuffer);

        if ((value & (1 << 31)) == 0) // en - Enable rank and bank matching
        {
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_RANK_BANK_MATCH), value | (1 << 31));
        }

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK), 1);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK), 1);

        value = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= 0xC3FFE0E0;
        new_value |= 0x3 << 28;
        new_value |= 0x3 << 26;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_SKYLAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA), new_value);
    }
}

void poll_timings_skylake_sp(struct ecc_info *ctrl)
{
    const int fnlist[] = {2, 6};

    UINT8 numdev = 2;
    UINT8 numfn = sizeof(fnlist) / sizeof(fnlist[0]);
    int i, j;
    int ch;

    skylake_sp_data *sklspdata = (skylake_sp_data *)ctrl->userdata;

    unsigned long memory = 0;
    pci_conf_read(ctrl->bus, ctrl->dev == 10 ? 8 : 9, 0, INTEL_SKYLAKE_SP_MEMORY, 4, &memory);

    if (ctrl->mchbar)
    {
        ch = 0;
        for (i = 0; i < numdev && ch < ctrl->numch; i++)
        {
            for (j = 0; j < numfn && ch < ctrl->numch; j++, ch++)
            {
                int dev = ctrl->dev + i;

                unsigned long tcdbp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (dev * 0x8000) + (fnlist[j] * 0x1000) + INTEL_SKYLAKE_SP_TCDBP));

                unsigned char tCL = BitExtract(tcdbp, 13, 9);
                unsigned char tRCD = BitExtract(tcdbp, 4, 0);
                unsigned char tRAS = BitExtract(tcdbp, 24, 19);
                unsigned char tRP = BitExtract(tcdbp, 31, 27);

                AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake_sp - [Ch %d] TCDBP=%08x (%d-%d-%d-%d)", ch, tcdbp, tCL, tRCD, tRP, tRAS);

                if (BitExtract(memory, ch, ch) == 0)
                {
                    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake_sp - Ch %d does not have DDR4 populated", ch);
                    continue;
                }

                if (tCL < 9 ||
                    tRCD < 5)
                    continue;

                ctrl->tAA = tCL;
                ctrl->tRCD = tRCD;
                ctrl->tRAS = tRAS;
                ctrl->tRP = tRP;
            }
        }
    }

    if (sklspdata->cpubusno[1])
    {
        unsigned long mc_bios_req = 0;
        pci_conf_read(sklspdata->cpubusno[1], 30, 1, INTEL_SKYLAKE_SP_MC_BIOS_REQ, 4, &mc_bios_req);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake_sp - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 5, 0), BitExtract(mc_bios_req, 11, 8));

        unsigned int qclk_ratio = BitExtract(mc_bios_req, 5, 0);
        unsigned int qclk_ref = BitExtract(mc_bios_req, 11, 8);

#if 0
    unsigned long mc_bios_data = 0;
    pci_conf_read(sklspdata->cpubusno[1], 30, 1, INTEL_SKYLAKE_SP_MC_BIOS_DATA, 4, &mc_bios_data);

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake_sp - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 5, 0), BitExtract(mc_bios_data, 11, 8));

    unsigned int qclk_ratio = BitExtract(mc_bios_data, 5, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_data, 11, 8);
#endif

        if (qclk_ratio == 0)
        {
            unsigned long capid1;
            unsigned char DMFC = 0;

            pci_conf_read(sklspdata->cpubusno[1], 30, 3, INTEL_SKYLAKE_SP_CAPID1, 4, &capid1);
            DMFC = BitExtract(capid1, 29, 26);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake_sp - CAPID1=0x%08x (DMFC=%1x)", capid1, DMFC);

            switch (DMFC)
            {
            case 0b110:
                ctrl->memclk = 1600;
                break;
            case 0b101:
                ctrl->memclk = 1867;
                break;
            case 0b100:
                ctrl->memclk = 2133;
                break;
            case 0b011:
                ctrl->memclk = 2400;
                break;
            case 0b010:
                ctrl->memclk = 2667;
                break;
            }
        }
        else
        {
            // MCLK = Reference Clock x QCLK Ratio
            if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
                ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
            else // 1: 100.00Mhz
                ctrl->memclk = qclk_ratio * 100 / 2;
        }
    }
}

/*
 * Ryzen memory controller
 *
 *  Reference: Preliminary Processor Programming Reference(PPR) for AMD Family 17h Model 01h, Revision B1 Processors (54945 Rev 1.13)
 *
 */

#define UMC_BASE(ch) (0x50000 + ch * 0x100000)
#define UMC_ADDRCFG(ch, sl) (UMC_BASE(ch) + 0x30 + sl * 4)

#define UMC_UMCCONFIG(ch) (UMC_BASE(ch) + 0x100)
#define UMC_SDPCTRL(ch) (UMC_BASE(ch) + 0x104)
#define UMC_DRAMCONFIG(ch) (UMC_BASE(ch) + 0x200)
#define UMC_DRAMTIMING(ch, n) (UMC_BASE(ch) + 0x200 + n * 4)

#define UMC_PERFMONCTLCLK(ch) (UMC_BASE(ch) + 0xD00)
#define UMC_PERFMONCTRCLKLO(ch) (UMC_BASE(ch) + 0xD04)
#define UMC_PERFMONCTRCLKHI(ch) (UMC_BASE(ch) + 0xD08)
#define UMC_DEBUGMISC(ch) (UMC_BASE(ch) + 0xD6C)
#define UMC_UMCCAP(ch) (UMC_BASE(ch) + 0xDF0)
#define UMC_UMCCAPHI(ch) (UMC_BASE(ch) + 0xDF4)
#define UMC_ECCERRCNTSEL(ch) (UMC_BASE(ch) + 0xD80)
#define UMC_ECCERRCNT(ch) (UMC_BASE(ch) + 0xD84)
#define UMC_ECCCTRL(ch) (UMC_BASE(ch) + 0x14C)
#define UMC_ECCERRINJCTRL(ch) (UMC_BASE(ch) + 0xD88)
#define UMC_ECCERRINJ(ch, n) (UMC_BASE(ch) + 0xDB0 + n * 4)
#define UMC_MISCCFG(ch) (UMC_BASE(ch) + 0x1E0)

#define MSR_MCG_CTL 0x17B
#define MSR_MCAX_BASE(ch) (0xC0002000 | ((0x0F + ch) << 4))
#define MSR_MCA_CTL_UMC(ch) (MSR_MCAX_BASE(ch) | 0)    // 0x43C
#define MSR_MCA_STATUS_UMC(ch) (MSR_MCAX_BASE(ch) | 1) // 0x43D
#define MSR_MCA_ADDR_UMC(ch) (MSR_MCAX_BASE(ch) | 2)   // 0x43E
#define MSR_MCA_MISC0_UMC(ch) (MSR_MCAX_BASE(ch) | 3)  // 0x43F
#define MSR_MCA_CONFIG_UMC(ch) (MSR_MCAX_BASE(ch) | 4)
#define MSR_MCA_IPID_UMC(ch) (MSR_MCAX_BASE(ch) | 5)
#define MSR_MCA_SYND_UMC(ch) (MSR_MCAX_BASE(ch) | 6)
#define MSR_MCA_DESTAT_UMC(ch) (MSR_MCAX_BASE(ch) | 8)
#define MSR_MCA_DEADDR_UMC(ch) (MSR_MCAX_BASE(ch) | 9)
#define MSR_MCA_MISC1_UMC(ch) (MSR_MCAX_BASE(ch) | A)
#define MSR_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x0F + ch))
#define MSR_MMIO_CFG_BASE_ADDR 0xC0010058

#define RYZEN_CFG_ADDRESS_CNTL 0x84

#define RYZEN_MMIO_MISC_BASE 0xFED80E00
#define RYZEN_MMIO_MISC_GPPCLKCNTRL (RYZEN_MMIO_MISC_BASE + 0)
#define RYZEN_MMIO_MISC_CGPLLCNTRLREG(n) (RYZEN_MMIO_MISC_BASE + 0xA0 + 4 * n)

typedef struct
{
    unsigned long cfgaddrcntl;
    unsigned long prev_dramscrub;
    unsigned long prev_redirscrub;
    unsigned long UmcConfig[MAX_UMC];
    unsigned long FabricBlockInstanceInformation3[MAX_UMC];
    unsigned long SystemFabricIdMask0[MAX_UMC];
    unsigned long SystemFabricIdMask1[MAX_UMC];
    unsigned long SystemFabricIdMask2[MAX_UMC];
    unsigned long DramHoleControl[MAX_UMC];
    unsigned long DramOffset[MAX_UMC];
    unsigned long DfGlobalCtrl[MAX_UMC];
    unsigned long AddrHashPC[MAX_UMC];
    unsigned long AddrHashPC2[MAX_UMC];
    unsigned long AddrHashCS[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long DimmCfg[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long DramAddressCtl[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long DramAddressIntlv[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long DramBaseAddress[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long DramLimitAddress[MAX_UMC * MAX_SLOTS_PER_UMC];
    unsigned long CSBaseAddr[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long CSBaseAddrSec[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long CSAddrMask[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long CSAddrMaskSec[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long AddrCfg[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long AddrSel[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long ColSelLo[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long ColSelHi[MAX_UMC * MAX_CS_PER_UMC];
    unsigned long RmSel[MAX_UMC * MAX_CS_PER_UMC];
} ryzen_data;

static void setup_ryzen(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};

    unsigned long sdpctrl = 0;
    unsigned long umccap = 0;
    unsigned long umccaphi = 0;
    unsigned long eccctrl = 0;
    unsigned long eccerrcntsel = 0;

    UINT64 mcactlmask = 0;
    UINT64 mcacfg = 0;
    UINT64 mcactl = 0;
    UINT64 mcaipid = 0;
    UINT64 mcgctl = 0;
    UINT64 mcgcap = 0;
    UINT64 mcastatus = 0;
    UINT32 mcatype = 0;
    int mcabank = 0;
    unsigned node = 0;
    unsigned int bus = 0;
    int i;
    int cs;
    int sl;

    ctrl->userdata = AllocateZeroPool(sizeof(ryzen_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    // Need to switch to CPU0??
    // From AMD:
    //    Yes, I think polling for ECC errors should be done by CPU0 on each die (APIC domain). If you are using the Corrected ECC Error Counter registers, they are available to all dies - but any interrupt from them is sent to logical core 0, and only logical core 0 has access to the MCA. So you may end up with incomplete information if polling from a different CPU.

    MtSupportDebugWriteLine("AMD Ryzen chipset init");
    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    pci_conf_read(ctrl->bus, ctrl->dev, 0, RYZEN_CFG_ADDRESS_CNTL, 4, &ryzdata->cfgaddrcntl);

    AsciiSPrint(gBuffer, BUF_SIZE, "CfgAddressCntl = %08x (SecBusNum=%02X)", ryzdata->cfgaddrcntl, ryzdata->cfgaddrcntl & 0xFF);
    MtSupportDebugWriteLine(gBuffer);
    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Setting bus %02X -> %02X", bus, ryzdata->cfgaddrcntl & 0xFF);
        MtSupportDebugWriteLine(gBuffer);
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);
    }

    if (controllers[ctrl->index].device == 0x1492) // 30h-31h has 8 memory channels
        ctrl->numch = 8;
    else
        ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    if (cpu_id.max_xcpuid >= 0x80000007)
    {
        unsigned int v[4];
        _cpuid(0x80000007, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x80000007]:EBX[31:0] = %08x (ScalableMCA=%d)", v[1], (v[1] >> 3) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, (UINT32)(mcgcap & 0xFF));
        MtSupportDebugWriteLine(gBuffer);
    }

    for (i = 0; i < ctrl->numch; i++)
    {
        smn_read(bus, UMC_SDPCTRL(i), &sdpctrl);
        int SdpInit = BitExtract(sdpctrl, 31, 31);
        AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d]=%08x (SdpInit=%d)", i, sdpctrl, SdpInit);

        if (sdpctrl == 0xffffffff)
            continue;

        if (!SdpInit)
            continue;

        ctrl->chmode++;

        unsigned long DramConfig = 0;
        smn_read(bus, UMC_DRAMCONFIG(i), &DramConfig);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramConfiguration=%08x", i, DramConfig);

        unsigned long DebugMisc = 0;
        smn_read(bus, UMC_DEBUGMISC(i), &DebugMisc);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DebugMisc=%08x", i, DebugMisc);

        for (int n = 1; n <= 2; n++)
        {
            unsigned long DramTiming = 0;
            smn_read(bus, UMC_DRAMTIMING(i, n), &DramTiming);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramTiming%d=%08x", i, n, DramTiming);
        }

        smn_read(bus, UMC_UMCCAP(i), &umccap);

        AsciiSPrint(gBuffer, BUF_SIZE, "UmcCap[%d]=0x%08X", i, umccap);
        MtSupportDebugWriteLine(gBuffer);

        if ((umccap & (1 << 17)) == 0)
        {
            /* Fill in the correct memory capabilites */
            smn_read(bus, UMC_UMCCAPHI(i), &umccaphi);

            AsciiSPrint(gBuffer, BUF_SIZE, "UmcCapHi[%d]=0x%08X", i, umccaphi);
            MtSupportDebugWriteLine(gBuffer);

            unsigned long eccmode = ddim[(umccaphi >> 30) & 3];
            if (ctrl->mode == ECC_NONE)
                ctrl->mode = eccmode;

            if (eccmode == ECC_NONE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "EccChipKillCap = 0 and EccEnabled = 0 for ch %d", i);
                MtSupportDebugWriteLine(gBuffer);

                continue;
            }
        }
        else
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "EccDis = 1 for ch %d", i);
            MtSupportDebugWriteLine(gBuffer);

            continue;
        }

#ifndef WIN32
        /* Check UMC Machine Check Control Mask */
        _rdmsr64(MSR_MCA_CTL_MASK_UMC(i), &mcactlmask);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_MASK_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactlmask, (UINT32)(mcactlmask & 1));
        MtSupportDebugWriteLine(gBuffer);

        if (mcactlmask & 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_MASK_UMC[%d][DramEccErr]=0", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCA_CTL_MASK_UMC(i), mcactlmask & ~1ULL);
        }

        /* Check UMC Machine Check Configuration */
        _rdmsr64(MSR_MCA_CONFIG_UMC(i), &mcacfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CONFIG_UMC[%d]=" I64HEXFMT, i, mcacfg);
        MtSupportDebugWriteLine(gBuffer);

        /* Check UMC Machine Check Control */
        _rdmsr64(MSR_MCA_CTL_UMC(i), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_UMC[%d][DramEccErr]=1", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCA_CTL_UMC(i), mcactl | 1ULL);
        }

        /* Check UMC IP Identification */
        _rdmsr64(MSR_MCA_IPID_UMC(i), &mcaipid);

        mcatype = (UINT32)RShiftU64(mcaipid, 48) & 0xFFFF;

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_IPID_UMC[%d]=" I64HEXFMT " (McaType=%d)", i, mcaipid, mcatype);
        MtSupportDebugWriteLine(gBuffer);

        /* Enable NB ECC Logging by MSR Write */
        _rdmsr64(MSR_MCG_CTL, &mcgctl);

        mcabank = (MSR_MCA_CTL_UMC(i) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),
        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL=" I64HEXFMT " [Bit %d = %d]", mcgctl, mcabank, (UINT32)RShiftU64(mcgctl, mcabank) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (mcabank <= 22 && (mcgctl & LShiftU64(1, mcabank)) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCG_CTL to " I64HEXFMT, mcgctl | LShiftU64(1, mcabank));
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCG_CTL, mcgctl | LShiftU64(1, mcabank));
        }

        /* Check UMC DRAM ECC Control*/
        smn_read(bus, UMC_ECCCTRL(i), &eccctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCCTRL[%d]=%08x (RdEccEn=%d, WrEccEn=%d)", i, eccctrl, (eccctrl >> 10) & 0x1, eccctrl & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccctrl & ((1 << 10) | 1)) != ((1 << 10) | 1))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCCTRL[%d] to %08x", i, eccctrl | ((1 << 10) | 1));
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCCTRL(i), eccctrl | ((1 << 10) | 1));
        }

        smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTSEL[%d]=%08x (EccErrCntEn=%d)", i, eccerrcntsel, (eccerrcntsel >> 15) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (((eccerrcntsel >> 15) & 1) == 0)
        {
            eccerrcntsel |= (1 << 15);

            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCERRCNTSEL[%d] to %08x", i, eccerrcntsel);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel);
        }

        for (sl = 0; sl < ctrl->numsl; sl++)
        {
            unsigned long addrcfg = 0;
            smn_read(bus, UMC_ADDRCFG(i, sl), &addrcfg);
            AsciiSPrint(gBuffer, BUF_SIZE, "ADDRCFG[%d] DIMM%d: %08x (NumRM=%d)", i, sl, addrcfg, (addrcfg >> 4) & 0x3);
            MtSupportDebugWriteLine(gBuffer);
        }

        for (cs = 0; cs < 4; cs++)
        {
            int rm;
            /* Clear any previous error */
            for (rm = 0; rm < 1; rm++)
            {

                unsigned long eccerrcnt = 0;

                /* DRAM ECC Error Count Select register */
                smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
                if (eccerrcntsel == 0xffffffff)
                    continue;

                smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | (rm << 4) | cs);

                smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
                if (eccerrcnt == 0xffffffff)
                    continue;

                if (eccerrcnt & 0x0000ffff)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNT[%d] (RM %d CS %d): %08x", i, rm, cs, eccerrcnt);
                    MtSupportDebugWriteLine(gBuffer);

                    smn_write(bus, UMC_ECCERRCNT(i), eccerrcnt & 0xffff0000);
                }
            }
        }

        _rdmsr64(MSR_MCA_STATUS_UMC(i), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT, i, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_MCA_STATUS_UMC(i), 0);
#endif
    }
}

/*
 * Ryzen Zen 2 memory controller
 *
 *  Reference: Processor Programming Reference(PPR) for AMD Family 17h Model 71h, Revision B0 Processors (56176 Rev 3.05 May 10, 2019 )
 *
 */

#define MSR_ZEN2_PFEH_CFG 0xC0010120
#define MSR_ZEN2_PFEH_CLOAK_CFG 0xC0010121
#define MSR_ZEN2_PFEH_DEF_INT_MASK 0xC0010122

#define MSR_ZEN2_MCAX_BASE(ch) (0xC0002000 | ((0x11 + ch) << 4))
#define MSR_ZEN2_MCA_CTL_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 0)
#define MSR_ZEN2_MCA_STATUS_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 1)
#define MSR_ZEN2_MCA_ADDR_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 2)
#define MSR_ZEN2_MCA_MISC0_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 3)
#define MSR_ZEN2_MCA_CONFIG_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 4)
#define MSR_ZEN2_MCA_IPID_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 5)
#define MSR_ZEN2_MCA_SYND_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 6)
#define MSR_ZEN2_MCA_DESTAT_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 8)
#define MSR_ZEN2_MCA_DEADDR_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | 9)
#define MSR_ZEN2_MCA_MISC1_UMC(ch) (MSR_ZEN2_MCAX_BASE(ch) | A)
#define MSR_ZEN2_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x11 + ch))

#define MSR_ZEN2_MCA_BASE(bank) (0x00000400 + 4 * bank)
#define MSR_ZEN2_MCA_CTL(bank) (MSR_ZEN2_MCA_BASE(bank) + 0)
#define MSR_ZEN2_MCA_STATUS(bank) (MSR_ZEN2_MCA_BASE(bank) + 1)
#define MSR_ZEN2_MCA_ADDR(bank) (MSR_ZEN2_MCA_BASE(bank) + 2)
#define MSR_ZEN2_MCA_MISC0(bank) (MSR_ZEN2_MCA_BASE(bank) + 3)

#define ZEN2_DF_FICAA(set) (0x50 + set * 4)
#define ZEN2_DF_FICAD_LO(set) (0x80 + set * 8)
#define ZEN2_DF_FICAD_HI(set) (0x84 + set * 8)

#define ZEN2_CFG_DF_FBII3 0x50
#define ZEN2_CFG_DF_DRAMHOLECONTROL 0x104
#define ZEN2_CFG_DF_DRAMOFFSET 0x1B4
#define ZEN2_CFG_DF_DRAMBASEADDRESS(n) (0x110 + n * 8)
#define ZEN2_CFG_DF_DRAMLIMITADDRESS(n) (0x114 + n * 8)
#define ZEN2_CFG_DF_DFGLOBALCTRL 0x3F8
#define ZEN2_CFG_DF_SYSTEMFABRICIDMASK0 0x208
#define ZEN2_CFG_DF_SYSTEMFABRICIDMASK1 0x20C

#define ZEN2_UMC_BASEADDR(ch, cs) (UMC_BASE(ch) + 0x0 + cs * 4)
#define ZEN2_UMC_BASEADDRSEC(ch, cs) (UMC_BASE(ch) + 0x10 + cs * 4)
#define ZEN2_UMC_ADDRMASK(ch, sl) (UMC_BASE(ch) + 0x20 + sl * 4)
#define ZEN2_UMC_ADDRMASKSEC(ch, sl) (UMC_BASE(ch) + 0x28 + sl * 4)
#define ZEN2_UMC_ADDRCFG(ch, sl) (UMC_BASE(ch) + 0x30 + sl * 4)
#define ZEN2_UMC_DIMMCFG(ch, sl) (UMC_BASE(ch) + 0x80 + sl * 4)
#define ZEN2_UMC_ADDRHASHCS(ch, n) (UMC_BASE(ch) + 0xE8 + n * 4)

#define ZEN2_DF_FICAA_ALL_INSTANCE 0xFF

static int zen2_df_ind_reg_read(struct ecc_info *ctrl, UINT8 func, UINT16 reg, UINT8 instance_id, unsigned long *lo)
{
    unsigned long ficaa, ficad;

    pci_conf_read(ctrl->bus, ctrl->dev, 0x4, ZEN2_DF_FICAA(3), 4, &ficaa);

    ficaa &= ~0x00FF7FFD;
    if (instance_id != ZEN2_DF_FICAA_ALL_INSTANCE)
    {
        ficaa |= instance_id << 16;
        ficaa |= 1; // CfgRegInstAccEn. Reset: 0. 0=Target all instances. 1=Target the instance specified by CfgRegInstID.
    }

    ficaa |= (func & 0x7) << 11;
    ficaa |= BitExtract(reg, 10, 2) << 2;

    pci_conf_write(ctrl->bus, ctrl->dev, 0x4, ZEN2_DF_FICAA(3), 4, ficaa);
    Sleep(1);

    pci_conf_read(ctrl->bus, ctrl->dev, 0x4, ZEN2_DF_FICAD_LO(3), 4, &ficad);

    if (lo)
        *lo = ficad;

    return 0;
}

void setup_ryzen_zen2(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};

    unsigned long sdpctrl = 0;
    unsigned long umccap = 0;
    unsigned long umccaphi = 0;
    unsigned long eccctrl = 0;
    unsigned long eccerrcntsel = 0;
    UINT64 mcactlmask = 0;
    UINT64 mcacfg = 0;
    UINT64 mcactl = 0;
    UINT64 mcaipid = 0;
    UINT64 mcgctl = 0;
    UINT64 mcgcap = 0;
    UINT64 mcastatus = 0;
    UINT64 mcamisc0 = 0;
    UINT32 mcatype = 0;
    int mcabank = 0;
    int mcabankcnt = 0;
    unsigned node = 0;
    unsigned int bus = 0;
    int i;
    int cs;
    int LogicalProcessorCount = 1;

    MtSupportDebugWriteLine("AMD Ryzen Zen 2 chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(ryzen_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    // Need to switch to CPU0??
    // From AMD:
    //    Yes, I think polling for ECC errors should be done by CPU0 on each die (APIC domain). If you are using the Corrected ECC Error Counter registers, they are available to all dies - but any interrupt from them is sent to logical core 0, and only logical core 0 has access to the MCA. So you may end up with incomplete information if polling from a different CPU.

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    pci_conf_read(ctrl->bus, ctrl->dev, 0, RYZEN_CFG_ADDRESS_CNTL, 4, &ryzdata->cfgaddrcntl);

    AsciiSPrint(gBuffer, BUF_SIZE, "CfgAddressCntl = %08x (SecBusNum=%02X)", ryzdata->cfgaddrcntl, ryzdata->cfgaddrcntl & 0xFF);
    MtSupportDebugWriteLine(gBuffer);
    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Setting bus %02X -> %02X", bus, ryzdata->cfgaddrcntl & 0xFF);
        MtSupportDebugWriteLine(gBuffer);
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);
    }

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    if (controllers[ctrl->index].device == 0x1492 || // 30h-31h has 8 memory channels
        controllers[ctrl->index].device == 0x1652)   // 19h 08h has 8 memory channels
        ctrl->numch = 8;
    else if (controllers[ctrl->index].device == 0x167B) // 44h has 4 memory channels (Zen 3+)
        ctrl->numch = 4;
    else
        ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    unsigned int v[4];

    _cpuid(0x00000001, &v[0], &v[1], &v[2], &v[3]);

    LogicalProcessorCount = BitExtract(v[1], 23, 16);
    AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EBX[31:0] = %08x (LocalApicId=%d, NBC=%d, LogicalProcessorCount=%d)", v[1], BitExtract(v[1], 31, 24), BitExtract(v[1], 27, 24), LogicalProcessorCount);
    MtSupportDebugWriteLine(gBuffer);

    AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EDX[31:0] = %08x (MCA=%d)", v[3], (v[3] >> 14) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (cpu_id.max_xcpuid >= 0x80000007)
    {
        _cpuid(0x80000007, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x80000007]:EBX[31:0] = %08x (PfehSupportPresent=%d, ScalableMCA=%d)", v[1], (v[1] >> 4) & 0x1, (v[1] >> 3) & 0x1);
        MtSupportDebugWriteLine(gBuffer);
#ifndef WIN32
        if (((v[1] >> 4) & 0x1) != 0)
        {
            UINT64 pfehcfg = 0;
            UINT64 pfehcloakcfg = 0;

            _rdmsr64(MSR_ZEN2_PFEH_CFG, &pfehcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CFG=" I64HEXFMT " (PfehEnable=%d)", pfehcfg, pfehcfg & 0x1);
            MtSupportDebugWriteLine(gBuffer);

            if ((pfehcfg & 0x1) != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Disabling PFEH (PFEH_CFG=" I64HEXFMT ")", pfehcfg & ~0x1ULL);
                MtSupportDebugWriteLine(gBuffer);

                _wrmsr64(MSR_ZEN2_PFEH_CFG, pfehcfg & ~0x1ULL);
            }

            _rdmsr64(MSR_ZEN2_PFEH_CLOAK_CFG, &pfehcloakcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CLOAK_CFG=" I64HEXFMT "", pfehcloakcfg);
            MtSupportDebugWriteLine(gBuffer);
        }
#endif
    }

    if (cpu_id.max_xcpuid >= 0x8000001E)
    {
        _cpuid(0x8000001E, &v[0], &v[1], &v[2], &v[3]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "CPUID[0x8000001E]:ECX[31:0] = %08x (NodesPerProcessor=%d, NodeId=%d)", v[2], BitExtract(v[2], 10, 8), BitExtract(v[2], 7, 0));
    }

    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
    mcabankcnt = (int)(mcgcap & 0xFF);
    AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, mcabankcnt);
    MtSupportDebugWriteLine(gBuffer);

    for (i = 0; i < ctrl->numch; i++)
    {
        int oddch = i % 2;

        mcabank = (MSR_ZEN2_MCA_CTL_UMC(oddch) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),

        smn_read(bus, UMC_SDPCTRL(i), &sdpctrl);
        int SdpInit = BitExtract(sdpctrl, 31, 31);
        AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d]=%08x (SdpInit=%d)", i, sdpctrl, SdpInit);

        if (sdpctrl == 0xffffffff)
            continue;

        if (!SdpInit)
            continue;

        ctrl->chmode++;

        unsigned long DramConfig = 0;
        smn_read(bus, UMC_DRAMCONFIG(i), &DramConfig);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramConfiguration=%08x", i, DramConfig);

        unsigned long DebugMisc = 0;
        smn_read(bus, UMC_DEBUGMISC(i), &DebugMisc);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DebugMisc=%08x", i, DebugMisc);

        for (int n = 1; n <= 2; n++)
        {
            unsigned long DramTiming = 0;
            smn_read(bus, UMC_DRAMTIMING(i, n), &DramTiming);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramTiming%d=%08x", i, n, DramTiming);
        }

        smn_read(bus, UMC_UMCCAP(i), &umccap);

        AsciiSPrint(gBuffer, BUF_SIZE, "UmcCap[%d]=0x%08X", i, umccap);
        MtSupportDebugWriteLine(gBuffer);

        if ((umccap & (1 << 17)) == 0)
        {
            /* Fill in the correct memory capabilites */
            smn_read(bus, UMC_UMCCAPHI(i), &umccaphi);

            AsciiSPrint(gBuffer, BUF_SIZE, "UmcCapHi[%d]=0x%08X", i, umccaphi);
            MtSupportDebugWriteLine(gBuffer);

            unsigned long eccmode = ddim[(umccaphi >> 30) & 3];
            if (ctrl->mode == ECC_NONE)
                ctrl->mode = eccmode;

            if (eccmode == ECC_NONE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "EccChipKillCap = 0 and EccEnabled = 0 for ch %d", i);
                MtSupportDebugWriteLine(gBuffer);

                continue;
            }
        }
        else
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "EccDis = 1 for ch %d", i);
            MtSupportDebugWriteLine(gBuffer);

            continue;
        }

#ifndef WIN32
        /* Check UMC Machine Check Control Mask */
        _rdmsr64(MSR_ZEN2_MCA_CTL_MASK_UMC(oddch), &mcactlmask);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_MASK_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", oddch, mcactlmask, (UINT32)(mcactlmask & 1));
        MtSupportDebugWriteLine(gBuffer);

        if (mcactlmask & 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_MASK_UMC[%d][DramEccErr]=0", oddch);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN2_MCA_CTL_MASK_UMC(oddch), mcactlmask & ~1ULL);
        }

        /* Check UMC Machine Check Configuration */
        _rdmsr64(MSR_ZEN2_MCA_CONFIG_UMC(oddch), &mcacfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CONFIG_UMC[%d]=" I64HEXFMT, oddch, mcacfg);
        MtSupportDebugWriteLine(gBuffer);

        /* Check UMC Machine Check Control */
        _rdmsr64(MSR_ZEN2_MCA_CTL_UMC(oddch), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", oddch, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_UMC[%d][DramEccErr]=1", oddch);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN2_MCA_CTL_UMC(oddch), mcactl | 1ULL);
        }

        _rdmsr64(MSR_ZEN2_MCA_CTL(mcabank), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL[%d]=" I64HEXFMT " (DramEccErr=%d)", mcabank, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL[%d][DramEccErr]=1", mcabank);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN2_MCA_CTL(mcabank), mcactl | 1ULL);
        }

        /* Check UMC IP Identification */
        _rdmsr64(MSR_ZEN2_MCA_IPID_UMC(oddch), &mcaipid);

        mcatype = (UINT32)RShiftU64(mcaipid, 48) & 0xFFFF;

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_IPID_UMC[%d]=" I64HEXFMT " (McaType=%d)", oddch, mcaipid, mcatype);
        MtSupportDebugWriteLine(gBuffer);

        /* Enable NB ECC Logging by MSR Write */
        _rdmsr64(MSR_MCG_CTL, &mcgctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL=" I64HEXFMT " [Bit %d = %d]", mcgctl, mcabank, (UINT32)RShiftU64(mcgctl, mcabank) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (mcabank < mcabankcnt && (mcgctl & LShiftU64(1, mcabank)) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCG_CTL to " I64HEXFMT, mcgctl | LShiftU64(1, mcabank));
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCG_CTL, mcgctl | LShiftU64(1, mcabank));
        }

        /* Check UMC DRAM ECC Control*/
        smn_read(bus, UMC_ECCCTRL(i), &eccctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCCTRL[%d]=%08x (RdEccEn=%d, WrEccEn=%d)", i, eccctrl, (eccctrl >> 10) & 0x1, eccctrl & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccctrl & ((1 << 10) | 1)) != ((1 << 10) | 1))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCCTRL[%d] to %08x", i, eccctrl | ((1 << 10) | 1));
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCCTRL(i), eccctrl | ((1 << 10) | 1));
        }

        smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTSEL[%d]=%08x (EccErrCntEn=%d)", i, eccerrcntsel, (eccerrcntsel >> 15) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (((eccerrcntsel >> 15) & 1) == 0)
        {
            eccerrcntsel |= (1 << 15);

            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCERRCNTSEL[%d] to %08x", i, eccerrcntsel);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel);
        }

        for (cs = 0; cs < 4; cs++)
        {
            int rm;
            /* Clear any previous error */
            for (rm = 0; rm < 1; rm++)
            {

                unsigned long eccerrcnt = 0;

                /* DRAM ECC Error Count Select register */
                smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
                if (eccerrcntsel == 0xffffffff)
                    continue;

                smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | (rm << 4) | cs);

                smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
                if (eccerrcnt == 0xffffffff)
                    continue;

                if (eccerrcnt & 0x0000ffff)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNT[%d] (RM %d CS %d): %08x", i, rm, cs, eccerrcnt);
                    MtSupportDebugWriteLine(gBuffer);

                    smn_write(bus, UMC_ECCERRCNT(i), eccerrcnt & 0xffff0000);
                }
            }
        }

        _rdmsr64(MSR_ZEN2_MCA_STATUS_UMC(oddch), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT, oddch, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN2_MCA_STATUS_UMC(oddch), 0);

        _rdmsr64(MSR_ZEN2_MCA_STATUS(mcabank), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS[%d]=" I64HEXFMT, mcabank, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN2_MCA_STATUS(mcabank), 0);

        _rdmsr64(MSR_ZEN2_MCA_MISC0(mcabank), &mcamisc0);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT, mcabank, mcamisc0);
        MtSupportDebugWriteLine(gBuffer);
#endif
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "chmode=%d", ctrl->chmode);

    unsigned long long MmioCfgBaseAddr;
    unsigned long long mmiobase;
    int mmiocfgen;
    _rdmsr64(MSR_MMIO_CFG_BASE_ADDR, &MmioCfgBaseAddr);

    mmiocfgen = (int)BitExtractULL(MmioCfgBaseAddr, 0, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "MmioCfgBaseAddr=" I64HEXFMT " (Enable=%d)", MmioCfgBaseAddr, mmiocfgen);

    mmiobase = LShiftU64(BitExtractULL(MmioCfgBaseAddr, 47, 20), 20);
    if (mmiobase > 0 && mmiocfgen) // Sanity check
    {
        ctrl->mchbar = mmiobase;
        AsciiFPrint(DEBUG_FILE_HANDLE, "MCHBAR=%p", ctrl->mchbar);
    }
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_FBII3, mc, &ryzdata->FabricBlockInstanceInformation3[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] FabricBlockInstanceInformation3=%08x", mc, ryzdata->FabricBlockInstanceInformation3[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_DRAMHOLECONTROL, mc, &ryzdata->DramHoleControl[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramHoleControl=%08x", mc, ryzdata->DramHoleControl[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_DRAMOFFSET, mc, &ryzdata->DramOffset[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramOffset=%08x", mc, ryzdata->DramOffset[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_DFGLOBALCTRL, mc, &ryzdata->DfGlobalCtrl[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DfGlobalCtrl=%08x", mc, ryzdata->DfGlobalCtrl[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen2_df_ind_reg_read(ctrl, 1, ZEN2_CFG_DF_SYSTEMFABRICIDMASK0, mc, &ryzdata->SystemFabricIdMask0[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask0=%08x", mc, ryzdata->SystemFabricIdMask0[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen2_df_ind_reg_read(ctrl, 1, ZEN2_CFG_DF_SYSTEMFABRICIDMASK1, mc, &ryzdata->SystemFabricIdMask1[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask1=%08x", mc, ryzdata->SystemFabricIdMask1[mc]);
        MtSupportDebugWriteLine(gBuffer);

        for (UINT16 n = 0; n < 2; n++)
        {
            int nind = mc * 2 + n;

            zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_DRAMBASEADDRESS(n), mc, &ryzdata->DramBaseAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramBaseAddress=%08x", mc, n, ryzdata->DramBaseAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen2_df_ind_reg_read(ctrl, 0, ZEN2_CFG_DF_DRAMLIMITADDRESS(n), mc, &ryzdata->DramLimitAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramLimitAddress=%08x", mc, n, ryzdata->DramLimitAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            smn_read(bus, ZEN2_UMC_ADDRHASHCS(mc, n), &ryzdata->AddrHashCS[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d,n%d] AddrHashCS: %08x", mc, n, ryzdata->AddrHashCS[nind]);
        }

        for (cs = 0; cs < 4; cs++)
        {
            int csind = mc * 4 + cs;
            smn_read(bus, ZEN2_UMC_BASEADDR(mc, cs), &ryzdata->CSBaseAddr[csind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddr: %08x", mc, cs, ryzdata->CSBaseAddr[csind]);
            smn_read(bus, ZEN2_UMC_BASEADDRSEC(mc, cs), &ryzdata->CSBaseAddrSec[csind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddrSec: %08x", mc, cs, ryzdata->CSBaseAddrSec[csind]);

            int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
            if (CSEnable)
            {
                int dimm = cs / 2;
                ctrl->numranks[mc * 2 + dimm]++;
            }
        }

        for (int sl = 0; sl < ctrl->numsl; sl++)
        {
            int sind = mc * ctrl->numsl + sl;
            smn_read(bus, ZEN2_UMC_ADDRMASK(mc, sl), &ryzdata->CSAddrMask[sind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] AddrMask: %08x", mc, sl, ryzdata->CSAddrMask[sind]);
            smn_read(bus, ZEN2_UMC_ADDRMASKSEC(mc, sl), &ryzdata->CSAddrMaskSec[sind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] AddrMaskSec: %08x", mc, sl, ryzdata->CSAddrMaskSec[sind]);
            smn_read(bus, ZEN2_UMC_ADDRCFG(mc, sl), &ryzdata->AddrCfg[sind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] addrCfg: %08x", mc, sl, ryzdata->AddrCfg[sind]);
            smn_read(bus, ZEN2_UMC_DIMMCFG(mc, sl), &ryzdata->DimmCfg[sind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] DimmCfg: %08x", mc, sl, ryzdata->DimmCfg[sind]);
            if (BitExtract(ryzdata->DimmCfg[sind], 7, 7))
                ctrl->chipwidth[mc * 2 + sl] = 16;
            else if (BitExtract(ryzdata->DimmCfg[sind], 6, 6))
                ctrl->chipwidth[mc * 2 + sl] = 4;
            else
                ctrl->chipwidth[mc * 2 + sl] = 8;
        }
    }
}

/*
 * Ryzen Zen 4 memory controller
 *
 *  Reference: Preliminary Processor Programming Reference (PPR) for AMD Family 19h Model 78h, Revision A0 Processors (57396 Rev 1.50 - Jul 27, 2022 )
 *
 */
#define ZEN4_DF_FICAA(set) (0x80 + set * 4)
#define ZEN4_DF_FICAD_LO(set) (0xA0 + set * 8)
#define ZEN4_DF_FICAD_HI(set) (0xA4 + set * 8)

#define ZEN4_DF_DRAMBASEADDRESS 0x200
#define ZEN4_DF_DRAMLIMITADDRESS 0x204
#define ZEN4_DF_DRAMADDRESSCTL0 0x208
#define ZEN4_DF_DRAMADDRESSINTLV 0x20C
#define ZEN4_DF_DRAMADDRESSCTL1 0x218

#define ZEN4_IND_CFG_DF_FBII3 0x50
#define ZEN4_IND_CFG_DF_DRAMHOLECONTROL 0x104
#define ZEN4_IND_CFG_DF_DRAMOFFSET 0x140
#define ZEN4_61H_IND_CFG_DF_DRAMBASEADDRESS(n) (0xE00 + n * 0x10)
#define ZEN4_61H_IND_CFG_DF_DRAMLIMITADDRESS(n) (0xE04 + n * 0x10)
#define ZEN4_61H_IND_CFG_DF_DRAMADDRESSCTL(n) (0xE08 + n * 0x10)
#define ZEN4_61H_IND_CFG_DF_DRAMADDRESSINTLV(n) (0xE0C + n * 0x10)
#define ZEN4_78H_IND_CFG_DF_DRAMBASEADDRESS(n) (0x200 + n * 0x10)
#define ZEN4_78H_IND_CFG_DF_DRAMLIMITADDRESS(n) (0x204 + n * 0x10)
#define ZEN4_78H_IND_CFG_DF_DRAMADDRESSCTL(n) (0x208 + n * 0x10)
#define ZEN4_78H_IND_CFG_DF_DRAMADDRESSINTLV(n) (0x20C + n * 0x10)

#define ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK0 0x1B0
#define ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK1 0x1B4
#define ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK2 0x1B8

#define ZEN4_UMC_BASEADDR(ch, cs) (UMC_BASE(ch) + 0x0 + cs * 4)
#define ZEN4_UMC_BASEADDRSEC(ch, cs) (UMC_BASE(ch) + 0x10 + cs * 4)
#define ZEN4_UMC_ADDRMASK(ch, cs) (UMC_BASE(ch) + 0x20 + cs * 4)
#define ZEN4_UMC_ADDRMASKSEC(ch, cs) (UMC_BASE(ch) + 0x30 + cs * 4)
#define ZEN4_UMC_ADDRCFG(ch, cs) (UMC_BASE(ch) + 0x40 + cs * 4)
#define ZEN4_UMC_ADDRSEL(ch, cs) (UMC_BASE(ch) + 0x50 + cs * 4)
#define ZEN4_UMC_COLSELLO(ch, cs) (UMC_BASE(ch) + 0x60 + cs * 8)
#define ZEN4_UMC_COLSELHI(ch, cs) (UMC_BASE(ch) + 0x64 + cs * 8)
#define ZEN4_UMC_RMSEL(ch, cs) (UMC_BASE(ch) + 0x80 + cs * 4)
#define ZEN4_UMC_DIMMCFG(ch, sl) (UMC_BASE(ch) + 0x90 + sl * 4)
#define ZEN4_UMC_ADDRHASHPC(ch) (UMC_BASE(ch) + 0xC0)
#define ZEN4_UMC_ADDRHASHPC2(ch) (UMC_BASE(ch) + 0xC4)
#define ZEN4_UMC_ADDRHASHCS(ch, n) (UMC_BASE(ch) + 0xC8 + n * 4)

#define ZEN4_UMC_BEQCTRL0(ch) (UMC_BASE(ch) + 0x11C)

#define ZEN4_UMC_ECCERRCNTCTRL(ch) (UMC_BASE(ch) + 0xD88)
#define ZEN4_UMC_ECCERRINJCTRL(ch) (UMC_BASE(ch) + 0xD8C)

#define ZEN4_UMC_DRAMSCRUBCTRL(ch) (UMC_BASE(ch) + 0x174)
#define ZEN4_UMC_DRAMSCRUBBASEADDR(ch) (UMC_BASE(ch) + 0x178)
#define ZEN4_UMC_DRAMSCRUBLIMITADDR(ch) (UMC_BASE(ch) + 0x17C)

#define MSR_ZEN4_SYS_CFG 0xc0010010
#define MSR_ZEN4_TOP_MEM 0xc001001a
#define MSR_ZEN4_TOM2 0xc001001d

#define MSR_ZEN4_PFEH_CFG 0xC0010120
#define MSR_ZEN4_PFEH_CLOAK_CFG 0xC0010121
#define MSR_ZEN4_PFEH_DEF_INT_MASK 0xC0010122

#define MSR_ZEN4_61H_MCAX_BASE(ch) (0xC0002000 | ((0x15 + ch) << 4))
#define MSR_ZEN4_61H_MCA_CTL_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 0)
#define MSR_ZEN4_61H_MCA_STATUS_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 1)
#define MSR_ZEN4_61H_MCA_ADDR_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 2)
#define MSR_ZEN4_61H_MCA_MISC0_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 3)
#define MSR_ZEN4_61H_MCA_CONFIG_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 4)
#define MSR_ZEN4_61H_MCA_IPID_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 5)
#define MSR_ZEN4_61H_MCA_SYND_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 6)
#define MSR_ZEN4_61H_MCA_DESTAT_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 8)
#define MSR_ZEN4_61H_MCA_DEADDR_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 9)
#define MSR_ZEN4_61H_MCA_MISC1_UMC(ch) (MSR_ZEN4_61H_MCAX_BASE(ch) | 0xA)
#define MSR_ZEN4_61H_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x15 + ch))

#define MSR_ZEN4_78H_MCAX_BASE(ch) (0xC0002000 | ((0x0F + ch) << 4))
#define MSR_ZEN4_78H_MCA_CTL_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 0)
#define MSR_ZEN4_78H_MCA_STATUS_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 1)
#define MSR_ZEN4_78H_MCA_ADDR_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 2)
#define MSR_ZEN4_78H_MCA_MISC0_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 3)
#define MSR_ZEN4_78H_MCA_CONFIG_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 4)
#define MSR_ZEN4_78H_MCA_IPID_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 5)
#define MSR_ZEN4_78H_MCA_SYND_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 6)
#define MSR_ZEN4_78H_MCA_DESTAT_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 8)
#define MSR_ZEN4_78H_MCA_DEADDR_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 9)
#define MSR_ZEN4_78H_MCA_MISC1_UMC(ch) (MSR_ZEN4_78H_MCAX_BASE(ch) | 0xA)
#define MSR_ZEN4_78H_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x0F + ch))

#define MSR_ZEN4_MCA_BASE(bank) (0x00000400 + 4 * bank)
#define MSR_ZEN4_MCA_CTL(bank) (MSR_ZEN4_MCA_BASE(bank) + 0)
#define MSR_ZEN4_MCA_STATUS(bank) (MSR_ZEN4_MCA_BASE(bank) + 1)
#define MSR_ZEN4_MCA_ADDR(bank) (MSR_ZEN4_MCA_BASE(bank) + 2)
#define MSR_ZEN4_MCA_MISC0(bank) (MSR_ZEN4_MCA_BASE(bank) + 3)

#define ZEN4_CFG_ADDRESS_CNTL 0xC04

#define ZEN4_DF_FICAA_ALL_INSTANCE 0xFF

#define ZEN4_UMCCONFIG_DDRTYPE_DDR5 0x1
#define ZEN4_UMCCONFIG_DDRTYPE_LPDDR5 0x6

static int zen4_df_ind_reg_read(struct ecc_info *ctrl, UINT8 func, UINT16 reg, UINT8 instance_id, unsigned long *lo)
{
    unsigned long ficaa, ficad;

    pci_conf_read(ctrl->bus, ctrl->dev, 0x4, ZEN4_DF_FICAA(3), 4, &ficaa);

    ficaa &= ~0x00FF7FFF;
    if (instance_id != ZEN4_DF_FICAA_ALL_INSTANCE)
    {
        ficaa |= instance_id << 16;
        ficaa |= 1; // CfgRegInstAccEn. Reset: 0. 0=Target all instances. 1=Target the instance specified by CfgRegInstID.
    }

    ficaa |= (func & 0x7) << 11;
    ficaa |= BitExtract(reg, 11, 2) << 1;

    pci_conf_write(ctrl->bus, ctrl->dev, 0x4, ZEN4_DF_FICAA(3), 4, ficaa);
    Sleep(1);

    pci_conf_read(ctrl->bus, ctrl->dev, 0x4, ZEN4_DF_FICAD_LO(3), 4, &ficad);

    if (lo)
        *lo = ficad;

    return 0;
}

void setup_ryzen_zen4_61h(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};

    unsigned long sdpctrl = 0;
    unsigned long umccap = 0;
    unsigned long umccaphi = 0;
    unsigned long eccctrl = 0;
    unsigned long eccerrcntsel = 0;
    unsigned long eccerrcntctrl = 0;
    UINT64 mcactlmask = 0;
    UINT64 mcacfg = 0;
    UINT64 mcactl = 0;
    UINT64 mcaipid = 0;
    UINT64 mcgctl = 0;
    UINT64 mcgcap = 0;
    UINT64 mcastatus = 0;
    UINT64 mcamisc0 = 0;
    UINT32 mcatype = 0;
    int mcabank = 0;
    int mcabankcnt = 0;
    unsigned node = 0;
    unsigned int bus = 0;
    int i;
    int cs;
    int LogicalProcessorCount = 1;

    MtSupportDebugWriteLine("AMD Ryzen Zen 4 chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(ryzen_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    // Need to switch to CPU0??
    // From AMD:
    //    Yes, I think polling for ECC errors should be done by CPU0 on each die (APIC domain). If you are using the Corrected ECC Error Counter registers, they are available to all dies - but any interrupt from them is sent to logical core 0, and only logical core 0 has access to the MCA. So you may end up with incomplete information if polling from a different CPU.

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    unsigned long long MmioCfgBaseAddr;
    unsigned long long mmiobase;
    int mmiocfgen;
    _rdmsr64(MSR_MMIO_CFG_BASE_ADDR, &MmioCfgBaseAddr);

    mmiocfgen = (int)BitExtractULL(MmioCfgBaseAddr, 0, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "MmioCfgBaseAddr=" I64HEXFMT " (Enable=%d)", MmioCfgBaseAddr, mmiocfgen);

    mmiobase = LShiftU64(BitExtractULL(MmioCfgBaseAddr, 47, 20), 20);
    if (mmiobase > 0 && mmiocfgen) // Sanity check
    {
        ctrl->mchbar = mmiobase;
        AsciiFPrint(DEBUG_FILE_HANDLE, "MCHBAR=%p", ctrl->mchbar);

        zen4_df_ind_reg_read(ctrl, 0, ZEN4_CFG_ADDRESS_CNTL, 0x0A, &ryzdata->cfgaddrcntl);

        AsciiSPrint(gBuffer, BUF_SIZE, "CfgAddressCntl = %08x (SecBusNum=%02X)", ryzdata->cfgaddrcntl, ryzdata->cfgaddrcntl & 0xFF);
        MtSupportDebugWriteLine(gBuffer);
        if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting bus %02X -> %02X", bus, ryzdata->cfgaddrcntl & 0xFF);
            MtSupportDebugWriteLine(gBuffer);
            bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);
        }
    }

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    if (controllers[ctrl->index].device == 0x14AF) // 10h-1fh has 12 UMC
        ctrl->numch = 12;
    else
        ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (cpu_id.max_xcpuid >= 0x80000007)
    {
        unsigned int v[4];

        _cpuid(0x00000001, &v[0], &v[1], &v[2], &v[3]);

        LogicalProcessorCount = BitExtract(v[1], 23, 16);
        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EBX[31:0] = %08x (LocalApicId=%d, NBC=%d, LogicalProcessorCount=%d)", v[1], BitExtract(v[1], 31, 24), BitExtract(v[1], 27, 24), LogicalProcessorCount);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EDX[31:0] = %08x (MCA=%d)", v[3], (v[3] >> 14) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        _cpuid(0x80000007, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x80000007]:EBX[31:0] = %08x (PfehSupportPresent=%d, ScalableMCA=%d)", v[1], (v[1] >> 4) & 0x1, (v[1] >> 3) & 0x1);
        MtSupportDebugWriteLine(gBuffer);
#ifndef WIN32
        if (((v[1] >> 4) & 0x1) != 0)
        {
            UINT64 pfehcfg = 0;
            UINT64 pfehcloakcfg = 0;

            _rdmsr64(MSR_ZEN4_PFEH_CFG, &pfehcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CFG=" I64HEXFMT " (PfehEnable=%d)", pfehcfg, (int)BitExtractULL(pfehcfg, 0, 0));
            MtSupportDebugWriteLine(gBuffer);

            if ((pfehcfg & 0x1) != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Disabling PFEH (PFEH_CFG=" I64HEXFMT ")", pfehcfg & ~0x1ULL);
                MtSupportDebugWriteLine(gBuffer);

                _wrmsr64(MSR_ZEN4_PFEH_CFG, pfehcfg & ~0x1ULL);
            }

            _rdmsr64(MSR_ZEN4_PFEH_CLOAK_CFG, &pfehcloakcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CLOAK_CFG=" I64HEXFMT, pfehcloakcfg);
            MtSupportDebugWriteLine(gBuffer);
        }
#endif
        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        mcabankcnt = (int)(mcgcap & 0xFF);
        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, mcabankcnt);
        MtSupportDebugWriteLine(gBuffer);
    }

    for (i = 0; i < ctrl->numch; i++)
    {
        int oddch = i % 2;

        unsigned int v[4];
        _cpuid(0x00000001, &v[0], &v[1], &v[2], &v[3]);
        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EBX[31:0] = %08x (LocalApicId=%d, NBC=%d, LogicalProcessorCount=%d)", v[1], BitExtract(v[1], 31, 24), BitExtract(v[1], 27, 24), LogicalProcessorCount);
        MtSupportDebugWriteLine(gBuffer);

        mcabank = (MSR_ZEN4_61H_MCA_CTL_UMC(oddch) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),

        smn_read(bus, UMC_SDPCTRL(i), &sdpctrl);
        int SdpInit = BitExtract(sdpctrl, 31, 31);
        AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d]=%08x (SdpInit=%d)", i, sdpctrl, SdpInit);

        if (sdpctrl == 0xffffffff)
            continue;

        if (!SdpInit)
            continue;

        ctrl->chmode++;

        unsigned long DramConfig = 0;
        smn_read(bus, UMC_DRAMCONFIG(i), &DramConfig);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramConfiguration=%08x", i, DramConfig);

        unsigned long DebugMisc = 0;
        smn_read(bus, UMC_DEBUGMISC(i), &DebugMisc);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DebugMisc=%08x", i, DebugMisc);

        for (int n = 1; n <= 2; n++)
        {
            unsigned long DramTiming = 0;
            smn_read(bus, UMC_DRAMTIMING(i, n), &DramTiming);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramTiming%d=%08x", i, n, DramTiming);
        }

        smn_read(bus, UMC_UMCCAP(i), &umccap);

        AsciiSPrint(gBuffer, BUF_SIZE, "UmcCap[%d]=0x%08X", i, umccap);
        MtSupportDebugWriteLine(gBuffer);

        if ((umccap & (1 << 17)) == 0)
        {
            /* Fill in the correct memory capabilites */
            smn_read(bus, UMC_UMCCAPHI(i), &umccaphi);

            AsciiSPrint(gBuffer, BUF_SIZE, "UmcCapHi[%d]=0x%08X", i, umccaphi);
            MtSupportDebugWriteLine(gBuffer);

            unsigned long eccmode = ddim[(umccaphi >> 30) & 3];
            if (ctrl->mode == ECC_NONE)
                ctrl->mode = eccmode;

            if (eccmode == ECC_NONE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "EccChipKillCap = 0 and EccEnabled = 0 for ch %d", i);
                MtSupportDebugWriteLine(gBuffer);

                continue;
            }
        }
        else
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "EccDis = 1 for ch %d", i);
            MtSupportDebugWriteLine(gBuffer);

            continue;
        }

#ifndef WIN32
        /* Check UMC Machine Check Control Mask */
        _rdmsr64(MSR_ZEN4_61H_MCA_CTL_MASK_UMC(oddch), &mcactlmask);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_MASK_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactlmask, (UINT32)(mcactlmask & 1));
        MtSupportDebugWriteLine(gBuffer);

        if (mcactlmask & 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_MASK_UMC[%d][DramEccErr]=0", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_61H_MCA_CTL_MASK_UMC(oddch), mcactlmask & ~1ULL);
        }

        /* Check UMC Machine Check Configuration */
        _rdmsr64(MSR_ZEN4_61H_MCA_CONFIG_UMC(oddch), &mcacfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CONFIG_UMC[%d]=" I64HEXFMT, i, mcacfg);
        MtSupportDebugWriteLine(gBuffer);

        /* Check UMC Machine Check Control */
        _rdmsr64(MSR_ZEN4_61H_MCA_CTL_UMC(oddch), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_UMC[%d][DramEccErr]=1", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_61H_MCA_CTL_UMC(oddch), mcactl | 1ULL);
        }

        _rdmsr64(MSR_ZEN4_MCA_CTL(mcabank), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL[%d]=" I64HEXFMT " (DramEccErr=%d)", mcabank, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL[%d][DramEccErr]=1", mcabank);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_MCA_CTL(mcabank), mcactl | 1ULL);
        }

        /* Check UMC IP Identification */
        _rdmsr64(MSR_ZEN4_61H_MCA_IPID_UMC(oddch), &mcaipid);

        mcatype = (UINT32)RShiftU64(mcaipid, 48) & 0xFFFF;

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_IPID_UMC[%d]=" I64HEXFMT " (McaType=%d)", i, mcaipid, mcatype);
        MtSupportDebugWriteLine(gBuffer);

        /* Enable NB ECC Logging by MSR Write */
        _rdmsr64(MSR_MCG_CTL, &mcgctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL=" I64HEXFMT " [Bit %d = %d]", mcgctl, mcabank, (UINT32)RShiftU64(mcgctl, mcabank) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (mcabank < mcabankcnt && (mcgctl & LShiftU64(1, mcabank)) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCG_CTL to " I64HEXFMT, mcgctl | LShiftU64(1, mcabank));
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCG_CTL, mcgctl | LShiftU64(1, mcabank));
        }

        /* Check UMC DRAM ECC Control*/
        smn_read(bus, UMC_ECCCTRL(i), &eccctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCCTRL[%d]=%08x (RdEccEn=%d, WrEccEn=%d)", i, eccctrl, (eccctrl >> 10) & 0x1, eccctrl & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccctrl & ((1 << 10) | 1)) != ((1 << 10) | 1))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCCTRL[%d] to %08x", i, eccctrl | ((1 << 10) | 1));
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCCTRL(i), eccctrl | ((1 << 10) | 1));
        }

        smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTSEL[%d]=%08x", i, eccerrcntsel);
        MtSupportDebugWriteLine(gBuffer);

        smn_read(bus, ZEN4_UMC_ECCERRCNTCTRL(i), &eccerrcntctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTCTRL[%d]=%08x (EccErrCntEn=%d)", i, eccerrcntctrl, eccerrcntctrl & 1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccerrcntctrl & 1) == 0)
        {
            eccerrcntctrl |= 1;

            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCERRCNTCTRL[%d] to %08x", i, eccerrcntctrl);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, ZEN4_UMC_ECCERRCNTCTRL(i), eccerrcntctrl);
        }

        for (int index = 0; index < 64; index++)
        {
            unsigned long eccerrcnt = 0;

            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | index);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNT[%d] (SubCh/CS/Plr %d): %08x", i, index, eccerrcnt);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, UMC_ECCERRCNT(i), eccerrcnt & 0xffff0000);
            }
        }

        _rdmsr64(MSR_ZEN4_61H_MCA_STATUS_UMC(oddch), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT, i, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN4_61H_MCA_STATUS_UMC(oddch), 0);

        _rdmsr64(MSR_ZEN4_MCA_STATUS(mcabank), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS[%d]=" I64HEXFMT, mcabank, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN4_MCA_STATUS(mcabank), 0);

        _rdmsr64(MSR_ZEN4_MCA_MISC0(mcabank), &mcamisc0);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT, mcabank, mcamisc0);
        MtSupportDebugWriteLine(gBuffer);
#endif
    }

#ifndef WIN32
    UINT64 tom, msr_val;

    /*
     * Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since
     * those are Read-As-Zero.
     */
    _rdmsr64(MSR_ZEN4_TOP_MEM, &tom);
    AsciiSPrint(gBuffer, BUF_SIZE, "TOP_MEM=" I64HEXFMT, tom);
    MtSupportDebugWriteLine(gBuffer);

    /* Check first whether TOP_MEM2 is enabled: */
    _rdmsr64(MSR_ZEN4_SYS_CFG, &msr_val);
    AsciiSPrint(gBuffer, BUF_SIZE, "SYS_CFG=" I64HEXFMT " (MtrrTom2En=%d)", msr_val, (int)BitExtractULL(msr_val, 21, 21));
    MtSupportDebugWriteLine(gBuffer);

    if (msr_val & (1 << 21))
    {
        _rdmsr64(MSR_ZEN4_TOM2, &tom);
        AsciiSPrint(gBuffer, BUF_SIZE, "TOM2=" I64HEXFMT, tom);
        MtSupportDebugWriteLine(gBuffer);
    }
#endif
    /*
    Coherent Slave 0 (UMC0)00h 00h
    Coherent Slave 1 (UMC1)01h 01h
    */
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        smn_read(bus, UMC_UMCCONFIG(mc), &ryzdata->UmcConfig[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] UmcConfig=%08x (DramReady=%d)", mc, ryzdata->UmcConfig[mc], BitExtract(ryzdata->UmcConfig[mc], 31, 31));
        MtSupportDebugWriteLine(gBuffer);

        // DramReady. Read-write. Reset: 0. 0=Disable. 1=Enable. Specifies the memory sub-system is initialized and ready for system traffic.
        if (BitExtract(ryzdata->UmcConfig[mc], 31, 31) == 0)
            continue;

        zen4_df_ind_reg_read(ctrl, 0, ZEN4_IND_CFG_DF_FBII3, mc, &ryzdata->FabricBlockInstanceInformation3[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] FabricBlockInstanceInformation3=%08x", mc, ryzdata->FabricBlockInstanceInformation3[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 7, ZEN4_IND_CFG_DF_DRAMHOLECONTROL, mc, &ryzdata->DramHoleControl[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramHoleControl=%08x", mc, ryzdata->DramHoleControl[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 7, ZEN4_IND_CFG_DF_DRAMOFFSET, mc, &ryzdata->DramOffset[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramOffset=%08x", mc, ryzdata->DramOffset[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK0, mc, &ryzdata->SystemFabricIdMask0[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask0=%08x", mc, ryzdata->SystemFabricIdMask0[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK1, mc, &ryzdata->SystemFabricIdMask1[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask1=%08x", mc, ryzdata->SystemFabricIdMask1[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK2, mc, &ryzdata->SystemFabricIdMask2[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask2=%08x", mc, ryzdata->SystemFabricIdMask2[mc]);
        MtSupportDebugWriteLine(gBuffer);

        unsigned long beqctrl0 = 0;
        smn_read(bus, ZEN4_UMC_BEQCTRL0(mc), &beqctrl0);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d] BeqCtrl0: %08x (VcmEn=%d)", mc, beqctrl0, BitExtract(beqctrl0, 3, 3));

        smn_read(bus, ZEN4_UMC_ADDRHASHPC(mc), &ryzdata->AddrHashPC[mc]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d] AddrHashPC: %08x", mc, ryzdata->AddrHashPC[mc]);

        smn_read(bus, ZEN4_UMC_ADDRHASHPC2(mc), &ryzdata->AddrHashPC2[mc]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d] AddrHashPC2: %08x", mc, ryzdata->AddrHashPC2[mc]);

        for (UINT16 n = 0; n < 2; n++)
        {
            int nind = mc * 2 + n;

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_61H_IND_CFG_DF_DRAMBASEADDRESS(n), mc, &ryzdata->DramBaseAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramBaseAddress=%08x", mc, n, ryzdata->DramBaseAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_61H_IND_CFG_DF_DRAMLIMITADDRESS(n), mc, &ryzdata->DramLimitAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramLimitAddress=%08x", mc, n, ryzdata->DramLimitAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_61H_IND_CFG_DF_DRAMADDRESSCTL(n), mc, &ryzdata->DramAddressCtl[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressCtl=%08x", mc, n, ryzdata->DramAddressCtl[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_61H_IND_CFG_DF_DRAMADDRESSINTLV(n), mc, &ryzdata->DramAddressIntlv[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressIntlv=%08x", mc, n, ryzdata->DramAddressIntlv[nind]);
            MtSupportDebugWriteLine(gBuffer);

            smn_read(bus, ZEN4_UMC_ADDRHASHCS(mc, n), &ryzdata->AddrHashCS[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d,n%d] AddrHashCS: %08x", mc, n, ryzdata->AddrHashCS[nind]);

            smn_read(bus, ZEN4_UMC_DIMMCFG(mc, n), &ryzdata->DimmCfg[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] DimmCfg: %08x", mc, n, ryzdata->DimmCfg[nind]);
            if (BitExtract(ryzdata->DimmCfg[nind], 7, 7))
                ctrl->chipwidth[mc * 2 + n] = 16;
            else if (BitExtract(ryzdata->DimmCfg[nind], 6, 6))
                ctrl->chipwidth[mc * 2 + n] = 4;
            else
                ctrl->chipwidth[mc * 2 + n] = 8;
        }

        for (cs = 0; cs < 4; cs++)
        {
            int csind = mc * 4 + cs;
            smn_read(bus, ZEN4_UMC_BASEADDR(mc, cs), &ryzdata->CSBaseAddr[csind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddr: %08x", mc, cs, ryzdata->CSBaseAddr[csind]);

            int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
            if (CSEnable)
            {
                smn_read(bus, ZEN4_UMC_BASEADDRSEC(mc, cs), &ryzdata->CSBaseAddrSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddrSec: %08x", mc, cs, ryzdata->CSBaseAddrSec[csind]);
                smn_read(bus, ZEN4_UMC_ADDRMASK(mc, cs), &ryzdata->CSAddrMask[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMask: %08x", mc, cs, ryzdata->CSAddrMask[csind]);
                smn_read(bus, ZEN4_UMC_ADDRMASKSEC(mc, cs), &ryzdata->CSAddrMaskSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMaskSec: %08x", mc, cs, ryzdata->CSAddrMaskSec[csind]);
                smn_read(bus, ZEN4_UMC_ADDRCFG(mc, cs), &ryzdata->AddrCfg[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrCfg: %08x", mc, cs, ryzdata->AddrCfg[csind]);
                smn_read(bus, ZEN4_UMC_ADDRSEL(mc, cs), &ryzdata->AddrSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrSel: %08x", mc, cs, ryzdata->AddrSel[csind]);
                smn_read(bus, ZEN4_UMC_COLSELLO(mc, cs), &ryzdata->ColSelLo[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelLo: %08x", mc, cs, ryzdata->ColSelLo[csind]);
                smn_read(bus, ZEN4_UMC_COLSELHI(mc, cs), &ryzdata->ColSelHi[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelHi: %08x", mc, cs, ryzdata->ColSelHi[csind]);
                smn_read(bus, ZEN4_UMC_RMSEL(mc, cs), &ryzdata->RmSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] RmSel: %08x", mc, cs, ryzdata->RmSel[csind]);

                int dimm = cs / 2;
                ctrl->numranks[mc * 2 + dimm]++;
            }
        }
    }
}

void setup_ryzen_zen4_78h(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};

    unsigned long sdpctrl = 0;
    unsigned long umccap = 0;
    unsigned long umccaphi = 0;
    unsigned long eccctrl = 0;
    unsigned long eccerrcntsel = 0;
    unsigned long eccerrcntctrl = 0;
    UINT64 mcactlmask = 0;
    UINT64 mcacfg = 0;
    UINT64 mcactl = 0;
    UINT64 mcaipid = 0;
    UINT64 mcgctl = 0;
    UINT64 mcgcap = 0;
    UINT64 mcastatus = 0;
    UINT64 mcamisc0 = 0;
    UINT32 mcatype = 0;
    int mcabank = 0;
    int mcabankcnt = 0;
    unsigned node = 0;
    unsigned int bus = 0;
    int i;
    int cs;

    MtSupportDebugWriteLine("AMD Ryzen Zen 4 chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(ryzen_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    // Need to switch to CPU0??
    // From AMD:
    //    Yes, I think polling for ECC errors should be done by CPU0 on each die (APIC domain). If you are using the Corrected ECC Error Counter registers, they are available to all dies - but any interrupt from them is sent to logical core 0, and only logical core 0 has access to the MCA. So you may end up with incomplete information if polling from a different CPU.

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    unsigned long long MmioCfgBaseAddr;
    unsigned long long mmiobase;
    int mmiocfgen;
    _rdmsr64(MSR_MMIO_CFG_BASE_ADDR, &MmioCfgBaseAddr);

    mmiocfgen = (int)BitExtractULL(MmioCfgBaseAddr, 0, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "MmioCfgBaseAddr=" I64HEXFMT " (Enable=%d)", MmioCfgBaseAddr, mmiocfgen);

    mmiobase = LShiftU64(BitExtractULL(MmioCfgBaseAddr, 47, 20), 20);
    if (mmiobase > 0 && mmiocfgen) // Sanity check
    {
        ctrl->mchbar = mmiobase;
        AsciiFPrint(DEBUG_FILE_HANDLE, "MCHBAR=%p", ctrl->mchbar);

        zen4_df_ind_reg_read(ctrl, 0, ZEN4_CFG_ADDRESS_CNTL, 0x0F, &ryzdata->cfgaddrcntl);

        AsciiSPrint(gBuffer, BUF_SIZE, "CfgAddressCntl = %08x (SecBusNum=%02X)", ryzdata->cfgaddrcntl, ryzdata->cfgaddrcntl & 0xFF);
        MtSupportDebugWriteLine(gBuffer);
        if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting bus %02X -> %02X", bus, ryzdata->cfgaddrcntl & 0xFF);
            MtSupportDebugWriteLine(gBuffer);
            bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);
        }
    }

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 4;
    ctrl->numsl = 1;
    ctrl->chmode = 0;

    if (cpu_id.max_xcpuid >= 0x80000007)
    {
        unsigned int v[4];

        _cpuid(0x00000001, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EDX[31:0] = %08x (MCA=%d)", v[3], (v[3] >> 14) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        _cpuid(0x80000007, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x80000007]:EBX[31:0] = %08x (PfehSupportPresent=%d, ScalableMCA=%d)", v[1], (v[1] >> 4) & 0x1, (v[1] >> 3) & 0x1);
        MtSupportDebugWriteLine(gBuffer);
#ifndef WIN32
        if (((v[1] >> 4) & 0x1) != 0)
        {
            UINT64 pfehcfg = 0;
            UINT64 pfehcloakcfg = 0;

            _rdmsr64(MSR_ZEN4_PFEH_CFG, &pfehcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CFG=" I64HEXFMT " (PfehEnable=%d)", pfehcfg, (int)BitExtractULL(pfehcfg, 0, 0));
            MtSupportDebugWriteLine(gBuffer);

            if ((pfehcfg & 0x1) != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Disabling PFEH (PFEH_CFG=" I64HEXFMT ")", pfehcfg & ~0x1ULL);
                MtSupportDebugWriteLine(gBuffer);

                _wrmsr64(MSR_ZEN4_PFEH_CFG, pfehcfg & ~0x1ULL);
            }

            _rdmsr64(MSR_ZEN4_PFEH_CLOAK_CFG, &pfehcloakcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CLOAK_CFG=" I64HEXFMT, pfehcloakcfg);
            MtSupportDebugWriteLine(gBuffer);
        }
#endif
        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        mcabankcnt = (int)(mcgcap & 0xFF);
        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, mcabankcnt);
        MtSupportDebugWriteLine(gBuffer);
    }

    for (i = 0; i < ctrl->numch; i++)
    {
        mcabank = (MSR_ZEN4_78H_MCA_CTL_UMC(i) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),

        smn_read(bus, UMC_SDPCTRL(i), &sdpctrl);
        int SdpInit = BitExtract(sdpctrl, 31, 31);
        AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d]=%08x (SdpInit=%d)", i, sdpctrl, SdpInit);

        if (sdpctrl == 0xffffffff)
            continue;

        if (!SdpInit)
            continue;

        ctrl->chmode++;

        unsigned long DramConfig = 0;
        smn_read(bus, UMC_DRAMCONFIG(i), &DramConfig);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramConfiguration=%08x", i, DramConfig);

        unsigned long DebugMisc = 0;
        smn_read(bus, UMC_DEBUGMISC(i), &DebugMisc);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DebugMisc=%08x", i, DebugMisc);

        for (int n = 1; n <= 2; n++)
        {
            unsigned long DramTiming = 0;
            smn_read(bus, UMC_DRAMTIMING(i, n), &DramTiming);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramTiming%d=%08x", i, n, DramTiming);
        }

        smn_read(bus, UMC_UMCCAP(i), &umccap);

        AsciiSPrint(gBuffer, BUF_SIZE, "UmcCap[%d]=0x%08X", i, umccap);
        MtSupportDebugWriteLine(gBuffer);

        if ((umccap & (1 << 17)) == 0)
        {
            /* Fill in the correct memory capabilites */
            smn_read(bus, UMC_UMCCAPHI(i), &umccaphi);

            AsciiSPrint(gBuffer, BUF_SIZE, "UmcCapHi[%d]=0x%08X", i, umccaphi);
            MtSupportDebugWriteLine(gBuffer);

            unsigned long eccmode = ddim[(umccaphi >> 30) & 3];
            if (ctrl->mode == ECC_NONE)
                ctrl->mode = eccmode;

            if (eccmode == ECC_NONE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "EccChipKillCap = 0 and EccEnabled = 0 for ch %d", i);
                MtSupportDebugWriteLine(gBuffer);

                continue;
            }
        }
        else
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "EccDis = 1 for ch %d", i);
            MtSupportDebugWriteLine(gBuffer);

            continue;
        }

#ifndef WIN32
        /* Check UMC Machine Check Control Mask */
        _rdmsr64(MSR_ZEN4_78H_MCA_CTL_MASK_UMC(i), &mcactlmask);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_MASK_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactlmask, (UINT32)(mcactlmask & 1));
        MtSupportDebugWriteLine(gBuffer);

        if (mcactlmask & 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_MASK_UMC[%d][DramEccErr]=0", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_78H_MCA_CTL_MASK_UMC(i), mcactlmask & ~1ULL);
        }

        /* Check UMC Machine Check Configuration */
        _rdmsr64(MSR_ZEN4_78H_MCA_CONFIG_UMC(i), &mcacfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CONFIG_UMC[%d]=" I64HEXFMT, i, mcacfg);
        MtSupportDebugWriteLine(gBuffer);

        /* Check UMC Machine Check Control */
        _rdmsr64(MSR_ZEN4_78H_MCA_CTL_UMC(i), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_UMC[%d][DramEccErr]=1", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_78H_MCA_CTL_UMC(i), mcactl | 1ULL);
        }

        _rdmsr64(MSR_ZEN4_MCA_CTL(mcabank), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL[%d]=" I64HEXFMT " (DramEccErr=%d)", mcabank, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL[%d][DramEccErr]=1", mcabank);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN4_MCA_CTL(mcabank), mcactl | 1ULL);
        }

        /* Check UMC IP Identification */
        _rdmsr64(MSR_ZEN4_78H_MCA_IPID_UMC(i), &mcaipid);

        mcatype = (UINT32)RShiftU64(mcaipid, 48) & 0xFFFF;

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_IPID_UMC[%d]=" I64HEXFMT " (McaType=%d)", i, mcaipid, mcatype);
        MtSupportDebugWriteLine(gBuffer);

        /* Enable NB ECC Logging by MSR Write */
        _rdmsr64(MSR_MCG_CTL, &mcgctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL=" I64HEXFMT " [Bit %d = %d]", mcgctl, mcabank, (UINT32)RShiftU64(mcgctl, mcabank) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (mcabank < mcabankcnt && (mcgctl & LShiftU64(1, mcabank)) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCG_CTL to " I64HEXFMT, mcgctl | LShiftU64(1, mcabank));
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCG_CTL, mcgctl | LShiftU64(1, mcabank));
        }

        /* Check UMC DRAM ECC Control*/
        smn_read(bus, UMC_ECCCTRL(i), &eccctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCCTRL[%d]=%08x (RdEccEn=%d, WrEccEn=%d)", i, eccctrl, (eccctrl >> 10) & 0x1, eccctrl & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccctrl & ((1 << 10) | 1)) != ((1 << 10) | 1))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCCTRL[%d] to %08x", i, eccctrl | ((1 << 10) | 1));
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCCTRL(i), eccctrl | ((1 << 10) | 1));
        }

        smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTSEL[%d]=%08x", i, eccerrcntsel);
        MtSupportDebugWriteLine(gBuffer);

        smn_read(bus, ZEN4_UMC_ECCERRCNTCTRL(i), &eccerrcntctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTCTRL[%d]=%08x (EccErrCntEn=%d)", i, eccerrcntctrl, eccerrcntctrl & 1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccerrcntctrl & 1) == 0)
        {
            eccerrcntctrl |= 1;

            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCERRCNTCTRL[%d] to %08x", i, eccerrcntctrl);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, ZEN4_UMC_ECCERRCNTCTRL(i), eccerrcntctrl);
        }

        for (cs = 0; cs < 4; cs++)
        {
            unsigned long eccerrcnt = 0;

            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | cs);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNT[%d] (SubCh/CS/Plr %d): %08x", i, cs, eccerrcnt);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, UMC_ECCERRCNT(i), eccerrcnt & 0xffff0000);
            }
        }

        _rdmsr64(MSR_ZEN4_78H_MCA_STATUS_UMC(i), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT, i, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN4_78H_MCA_STATUS_UMC(i), 0);

        _rdmsr64(MSR_ZEN4_MCA_STATUS(mcabank), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS[%d]=" I64HEXFMT, mcabank, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN4_MCA_STATUS(mcabank), 0);

        _rdmsr64(MSR_ZEN4_MCA_MISC0(mcabank), &mcamisc0);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT, mcabank, mcamisc0);
        MtSupportDebugWriteLine(gBuffer);
#endif
    }

#ifndef WIN32
    UINT64 tom, msr_val;

    /*
     * Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since
     * those are Read-As-Zero.
     */
    _rdmsr64(MSR_ZEN4_TOP_MEM, &tom);
    AsciiSPrint(gBuffer, BUF_SIZE, "TOP_MEM=" I64HEXFMT, tom);
    MtSupportDebugWriteLine(gBuffer);

    /* Check first whether TOP_MEM2 is enabled: */
    _rdmsr64(MSR_ZEN4_SYS_CFG, &msr_val);
    AsciiSPrint(gBuffer, BUF_SIZE, "SYS_CFG=" I64HEXFMT " (MtrrTom2En=%d)", msr_val, (int)BitExtractULL(msr_val, 21, 21));
    MtSupportDebugWriteLine(gBuffer);

    if (msr_val & (1 << 21))
    {
        _rdmsr64(MSR_ZEN4_TOM2, &tom);
        AsciiSPrint(gBuffer, BUF_SIZE, "TOM2=" I64HEXFMT, tom);
        MtSupportDebugWriteLine(gBuffer);
    }
#endif
    /*
    Coherent Slave 0 (UMC0)00h 00h
    Coherent Slave 1 (UMC1)01h 01h
    Coherent Slave 2 (UMC2)02h 02h
    Coherent Slave 3 (UMC3)03h 03h
    */
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        smn_read(bus, UMC_UMCCONFIG(mc), &ryzdata->UmcConfig[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] UmcConfig=%08x (DramReady=%d)", mc, ryzdata->UmcConfig[mc], BitExtract(ryzdata->UmcConfig[mc], 31, 31));
        MtSupportDebugWriteLine(gBuffer);

        // DramReady. Read-write. Reset: 0. 0=Disable. 1=Enable. Specifies the memory sub-system is initialized and ready for system traffic.
        if (BitExtract(ryzdata->UmcConfig[mc], 31, 31) == 0)
            continue;

        zen4_df_ind_reg_read(ctrl, 0, ZEN4_IND_CFG_DF_FBII3, mc, &ryzdata->FabricBlockInstanceInformation3[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] FabricBlockInstanceInformation3=%08x", mc, ryzdata->FabricBlockInstanceInformation3[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 7, ZEN4_IND_CFG_DF_DRAMHOLECONTROL, mc, &ryzdata->DramHoleControl[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramHoleControl=%08x", mc, ryzdata->DramHoleControl[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 7, ZEN4_IND_CFG_DF_DRAMOFFSET, mc, &ryzdata->DramOffset[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramOffset=%08x", mc, ryzdata->DramOffset[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK0, mc, &ryzdata->SystemFabricIdMask0[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask0=%08x", mc, ryzdata->SystemFabricIdMask0[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK1, mc, &ryzdata->SystemFabricIdMask1[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask1=%08x", mc, ryzdata->SystemFabricIdMask1[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen4_df_ind_reg_read(ctrl, 4, ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK2, mc, &ryzdata->SystemFabricIdMask2[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask2=%08x", mc, ryzdata->SystemFabricIdMask2[mc]);
        MtSupportDebugWriteLine(gBuffer);

        for (UINT16 n = 0; n < 2; n++)
        {
            int nind = mc * 2 + n;

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_78H_IND_CFG_DF_DRAMBASEADDRESS(n), mc, &ryzdata->DramBaseAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramBaseAddress=%08x", mc, n, ryzdata->DramBaseAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_78H_IND_CFG_DF_DRAMLIMITADDRESS(n), mc, &ryzdata->DramLimitAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramLimitAddress=%08x", mc, n, ryzdata->DramLimitAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_78H_IND_CFG_DF_DRAMADDRESSCTL(n), mc, &ryzdata->DramAddressCtl[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressCtl=%08x", mc, n, ryzdata->DramAddressCtl[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen4_df_ind_reg_read(ctrl, 7, ZEN4_78H_IND_CFG_DF_DRAMADDRESSINTLV(n), mc, &ryzdata->DramAddressIntlv[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressIntlv=%08x", mc, n, ryzdata->DramAddressIntlv[nind]);
            MtSupportDebugWriteLine(gBuffer);

            smn_read(bus, ZEN4_UMC_ADDRHASHCS(mc, n), &ryzdata->AddrHashCS[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d,n%d] AddrHashCS: %08x", mc, n, ryzdata->AddrHashCS[nind]);

            smn_read(bus, ZEN4_UMC_DIMMCFG(mc, n), &ryzdata->DimmCfg[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] DimmCfg: %08x", mc, n, ryzdata->DimmCfg[nind]);
            if (BitExtract(ryzdata->DimmCfg[nind], 7, 7))
                ctrl->chipwidth[mc * 2 + n] = 16;
            else if (BitExtract(ryzdata->DimmCfg[nind], 6, 6))
                ctrl->chipwidth[mc * 2 + n] = 4;
            else
                ctrl->chipwidth[mc * 2 + n] = 8;
        }

        for (cs = 0; cs < 4; cs++)
        {
            int csind = mc * 4 + cs;
            smn_read(bus, ZEN4_UMC_BASEADDR(mc, cs), &ryzdata->CSBaseAddr[csind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddr: %08x", mc, cs, ryzdata->CSBaseAddr[csind]);

            int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
            if (CSEnable)
            {
                smn_read(bus, ZEN4_UMC_BASEADDRSEC(mc, cs), &ryzdata->CSBaseAddrSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddrSec: %08x", mc, cs, ryzdata->CSBaseAddrSec[csind]);
                smn_read(bus, ZEN4_UMC_ADDRMASK(mc, cs), &ryzdata->CSAddrMask[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMask: %08x", mc, cs, ryzdata->CSAddrMask[csind]);
                smn_read(bus, ZEN4_UMC_ADDRMASKSEC(mc, cs), &ryzdata->CSAddrMaskSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMaskSec: %08x", mc, cs, ryzdata->CSAddrMaskSec[csind]);
                smn_read(bus, ZEN4_UMC_ADDRCFG(mc, cs), &ryzdata->AddrCfg[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrCfg: %08x", mc, cs, ryzdata->AddrCfg[csind]);
                smn_read(bus, ZEN4_UMC_ADDRSEL(mc, cs), &ryzdata->AddrSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrSel: %08x", mc, cs, ryzdata->AddrSel[csind]);
                smn_read(bus, ZEN4_UMC_COLSELLO(mc, cs), &ryzdata->ColSelLo[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelLo: %08x", mc, cs, ryzdata->ColSelLo[csind]);
                smn_read(bus, ZEN4_UMC_COLSELHI(mc, cs), &ryzdata->ColSelHi[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelHi: %08x", mc, cs, ryzdata->ColSelHi[csind]);
                smn_read(bus, ZEN4_UMC_RMSEL(mc, cs), &ryzdata->RmSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] RmSel: %08x", mc, cs, ryzdata->RmSel[csind]);

                int dimm = cs / 2;
                ctrl->numranks[mc * 2 + dimm]++;
            }
        }
    }
}

static void zen4_decode_addr(struct ecc_info *ctrl, unsigned long long addr, int *pmc, int *pch, int *pcs, unsigned long long *pnormaddr)
{
    int mc = -1, ch = -1, cs = -1;
    unsigned long long normaddr = 0;
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    for (int umc = 0; umc < ctrl->numch; umc++)
    {
        for (UINT16 n = 0; n < 2; n++)
        {
            int nind = umc * 2 + n;

            int AddrRngVal = BitExtract(ryzdata->DramAddressCtl[nind], 0, 0);
            if (AddrRngVal == 0)
                continue;

            unsigned long long mcbase = LShiftU64(BitExtract(ryzdata->DramBaseAddress[nind], 19, 0), 28);
            unsigned long long mclimit = LShiftU64(BitExtract(ryzdata->DramLimitAddress[nind], 19, 0), 28) | (LShiftU64(1, 28) - 1);
            unsigned short DstFabricID = BitExtract(ryzdata->DramAddressCtl[nind], 21, 16);

            if ((addr >= mcbase) && (addr <= mclimit))
            {
                const unsigned long INTLV_CHANBITS_MAP[] = {0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                unsigned long intlv_socketbits = BitExtract(ryzdata->DramAddressIntlv[nind], 18, 18);
                unsigned long intlv_diebits = BitExtract(ryzdata->DramAddressIntlv[nind], 13, 12);
                unsigned long IntLvNumChan = BitExtract(ryzdata->DramAddressIntlv[nind], 8, 4);
                unsigned long intlv_chanbits = IntLvNumChan < 0xC ? INTLV_CHANBITS_MAP[IntLvNumChan] : IntLvNumChan - 0xB;

                int intlv_lsb = BitExtract(ryzdata->DramAddressIntlv[nind], 2, 0) + 8;

                normaddr = addr;

                // sys addr -> norm  addr

                // hash addr
                mc = DstFabricID & (ctrl->numch - 1);
                if (intlv_chanbits != 0)
                {
                    int chhash = IntLvNumChan >= 0xC;
                    int HashIntlvCtl64K = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 8, 8);
                    int HashIntlvCtl2M = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 9, 9);
                    int HashIntlvCtl1G = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 10, 10);

                    for (int i = 0; i < (int)intlv_chanbits; i++)
                    {
                        int hashbit = (int)BitExtractULL(normaddr, intlv_lsb + i, intlv_lsb + i);
                        if (HashIntlvCtl64K)
                            hashbit ^= BitExtractULL(normaddr, 16 + i, 16 + i);
                        if (HashIntlvCtl2M)
                            hashbit ^= BitExtractULL(normaddr, 21 + i, 21 + i);
                        if (HashIntlvCtl1G)
                            hashbit ^= BitExtractULL(normaddr, 30 + i, 30 + i);

                        if (BitExtractULL(normaddr, intlv_lsb + i, intlv_lsb + i) != hashbit)
                            normaddr ^= LShiftU64(1, intlv_lsb + i);

                        mc ^= (hashbit << i);
                    }
                }

                // check dram hole
                int LgcyMmioHoleEn = BitExtract(ryzdata->DramAddressCtl[nind], 1, 1);

                if (LgcyMmioHoleEn)
                {
                    unsigned long long DramHoleBase = LShiftU64(BitExtractULL(ryzdata->DramHoleControl[umc], 31, 24), 24);
                    unsigned long long DramHoleSize = 0x100000000ULL - DramHoleBase;

                    if (normaddr >= (DramHoleBase + DramHoleSize))
                    {
                        normaddr -= DramHoleSize;
                    }
                }

                // subtract base addr
                normaddr -= mcbase;

                // normalize address
                if (intlv_chanbits != 0)
                {
                    // remove cs id
                    int num_intlv_bits = intlv_socketbits + intlv_diebits + intlv_chanbits;
                    unsigned short cs_id = (unsigned short)BitExtractULL(normaddr, intlv_lsb + num_intlv_bits - 1, intlv_lsb);
                    (void)cs_id;

                    normaddr = LShiftU64(BitExtractULL(normaddr, 63, intlv_lsb + num_intlv_bits), intlv_lsb) | BitExtractULL(normaddr, intlv_lsb - 1, 0);
                }

                // add dramoffset
                int HiAddrOffsetEn = BitExtract(ryzdata->DramOffset[umc], 0, 0);
                if (HiAddrOffsetEn)
                {
                    unsigned long long HiAddrOffset = LShiftU64(BitExtract(ryzdata->DramOffset[umc], 20, 1), 28);
                    if (n == 1)
                    {
                        normaddr += HiAddrOffset;
                    }
                }

                // look up cs
                for (int i = 0; i < 4; i++)
                {
                    int csind = mc * 4 + i;
                    int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
                    if (CSEnable == 0)
                        continue;

                    unsigned long long CSBase = LShiftU64(BitExtractULL(ryzdata->CSBaseAddr[csind], 31, 1), 9);
                    unsigned long long CSMask = LShiftU64(~BitExtractULL(ryzdata->CSAddrMask[csind], 31, 1), 9);

                    int ch_bit = BitExtract(ryzdata->RmSel[csind], 19, 16) + 5;

                    if ((normaddr & CSMask) == (CSBase & CSMask))
                    {
                        int XorEn_n0 = BitExtract(ryzdata->AddrHashCS[mc * 2], 0, 0);
                        unsigned long long NormAddrXor_n0 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2], 31, 1), 9);
                        int XorEn_n1 = BitExtract(ryzdata->AddrHashCS[mc * 2 + 1], 0, 0);
                        unsigned long long NormAddrXor_n1 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2 + 1], 31, 1), 9);
                        int XorEn_ch = BitExtract(ryzdata->AddrHashPC[mc], 0, 0);

                        if (XorEn_n0 | XorEn_n1)
                        {
                            unsigned long long xorbits_n0 = 0;
                            unsigned long long xorbits_n1 = 0;
                            if (XorEn_n0)
                                xorbits_n0 = normaddr & NormAddrXor_n0;
                            if (XorEn_n1)
                                xorbits_n1 = normaddr & NormAddrXor_n1;

                            int cshash_n0 = 0;
                            int cshash_n1 = 0;
                            for (int bit = 0; bit < 63; bit++)
                            {
                                cshash_n0 ^= (int)(RShiftU64(xorbits_n0, bit) & 1);
                                cshash_n1 ^= (int)(RShiftU64(xorbits_n1, bit) & 1);
                            }
                            cs = i ^ ((cshash_n1 << 1) | cshash_n0);
                        }
                        else
                        {
                            cs = i;
                        }

                        if (XorEn_ch)
                        {
                            unsigned long long RowXor = BitExtract(ryzdata->AddrHashPC[mc], 31, 14);
                            unsigned long long ColXor = BitExtract(ryzdata->AddrHashPC[mc], 13, 1);
                            unsigned long long BankXor = BitExtract(ryzdata->AddrHashPC2[mc], 4, 0);
                            int num_row_bits = BitExtract(ryzdata->AddrCfg[csind], 11, 8) + 10;
                            int row_lsb = BitExtract(ryzdata->AddrSel[csind], 27, 24) + 12;
                            unsigned long long rowaddr = BitExtractULL(normaddr, row_lsb + num_row_bits - 1, row_lsb);
                            unsigned long long xorbits_row = rowaddr & RowXor;

                            int chhash_row = 0;
                            for (int bit = 0; bit < num_row_bits; bit++)
                                chhash_row ^= (int)(RShiftU64(xorbits_row, bit) & 1);

                            ch = (int)BitExtractULL(normaddr, ch_bit, ch_bit) ^ chhash_row;

                            (void)ColXor;
                            (void)BankXor;

                            AsciiFPrint(DEBUG_FILE_HANDLE, "zen4_decode_addr - A(%p,%d,%d,%p,%d,%d)", RowXor, num_row_bits, row_lsb, rowaddr, chhash_row, ch);
                        }
                        else
                        {
                            if (controllers[ctrl->index].device == 0x14F2) // 78h-7bh: Each 32-bit channel of a DDR5 module is controlled by a single UMC in this SOC
                                ch = (mc & 1) ^ 1;
                            else
                                ch = (int)BitExtractULL(normaddr, ch_bit, ch_bit);
                        }

                        AsciiFPrint(DEBUG_FILE_HANDLE, "zen4_decode_addr - B(%d,%d,%p,%p,%d)", cs, ch, CSBase, CSMask, XorEn_n0 | XorEn_n1);

                        break;
                    }
                }
                break;
            }
        }
        if (mc >= 0)
            break;
    }
    if (pmc)
        *pmc = mc;
    if (pch)
        *pch = ch;
    if (pcs)
        *pcs = cs;
    if (pnormaddr)
        *pnormaddr = normaddr;
}

/*
 * Ryzen Zen 5 memory controller
 *
 *  Reference: Processor Programming Reference (PPR) for AMD Family 1Ah Model 02h, Revision C1 Processors (57238 Rev 0.24 - Sep 29, 2024)
 *  Reference: Processor Programming Reference (PPR) for AMD Family 1Ah Model 68h, Revision A0 Processors (57928 Rev 1.50 - Nov 8, 2024)
 *
 */
#define ZEN5_IND_CFG_DF_FBII3 ZEN4_IND_CFG_DF_FBII3
#define ZEN5_IND_CFG_DF_DRAMHOLECONTROL ZEN4_IND_CFG_DF_DRAMHOLECONTROL
#define ZEN5_IND_CFG_DF_DRAMOFFSET ZEN4_IND_CFG_DF_DRAMOFFSET

#define ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK0 ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK0
#define ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK1 ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK1
#define ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK2 ZEN4_IND_CFG_DF_SYSTEMFABRICIDMASK2

#define ZEN5_IND_CFG_DF_DRAMBASEADDRESS(n) ZEN4_78H_IND_CFG_DF_DRAMBASEADDRESS(n)
#define ZEN5_IND_CFG_DF_DRAMLIMITADDRESS(n) ZEN4_78H_IND_CFG_DF_DRAMLIMITADDRESS(n)
#define ZEN5_IND_CFG_DF_DRAMADDRESSCTL(n) ZEN4_78H_IND_CFG_DF_DRAMADDRESSCTL(n)
#define ZEN5_IND_CFG_DF_DRAMADDRESSINTLV(n) ZEN4_78H_IND_CFG_DF_DRAMADDRESSINTLV(n)

#define ZEN5_UMC_BASEADDR(ch, cs) ZEN4_UMC_BASEADDR(ch, cs)
#define ZEN5_UMC_BASEADDRSEC(ch, cs) ZEN4_UMC_BASEADDRSEC(ch, cs)
#define ZEN5_UMC_ADDRMASK(ch, cs) ZEN4_UMC_ADDRMASK(ch, cs)
#define ZEN5_UMC_ADDRMASKSEC(ch, cs) ZEN4_UMC_ADDRMASKSEC(ch, cs)
#define ZEN5_UMC_ADDRCFG(ch, cs) ZEN4_UMC_ADDRCFG(ch, cs)
#define ZEN5_UMC_ADDRSEL(ch, cs) ZEN4_UMC_ADDRSEL(ch, cs)
#define ZEN5_UMC_COLSELLO(ch, cs) ZEN4_UMC_COLSELLO(ch, cs)
#define ZEN5_UMC_COLSELHI(ch, cs) ZEN4_UMC_COLSELHI(ch, cs)
#define ZEN5_UMC_RMSEL(ch, cs) ZEN4_UMC_RMSEL(ch, cs)
#define ZEN5_UMC_DIMMCFG(ch, sl) ZEN4_UMC_DIMMCFG(ch, sl)
#define ZEN5_UMC_ADDRHASHPC(ch) ZEN4_UMC_ADDRHASHPC(ch)
#define ZEN5_UMC_ADDRHASHPC2(ch) ZEN4_UMC_ADDRHASHPC2(ch)
#define ZEN5_UMC_ADDRHASHCS(ch, n) ZEN4_UMC_ADDRHASHCS(ch, n)

#define ZEN5_UMC_BEQCTRL0(ch) ZEN4_UMC_BEQCTRL0(ch)

#define ZEN5_UMC_ECCERRCNTCTRL(ch) ZEN4_UMC_ECCERRCNTCTRL(ch)
#define ZEN5_UMC_ECCERRINJCTRL(ch) ZEN4_UMC_ECCERRINJCTRL(ch)

#define ZEN5_UMC_DRAMSCRUBCTRL(ch) ZEN4_UMC_DRAMSCRUBCTRL(ch)
#define ZEN5_UMC_DRAMSCRUBBASEADDR(ch) ZEN4_UMC_DRAMSCRUBBASEADDR(ch)
#define ZEN5_UMC_DRAMSCRUBLIMITADDR(ch) ZEN4_UMC_DRAMSCRUBLIMITADDR(ch)

#define MSR_ZEN5_40H_MCAX_BASE(ch) (0xC0002000 | ((0x15 + (ch & 1)) << 4))
#define MSR_ZEN5_40H_MCA_CTL_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 0)
#define MSR_ZEN5_40H_MCA_STATUS_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 1)
#define MSR_ZEN5_40H_MCA_ADDR_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 2)
#define MSR_ZEN5_40H_MCA_MISC0_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 3)
#define MSR_ZEN5_40H_MCA_CONFIG_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 4)
#define MSR_ZEN5_40H_MCA_IPID_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 5)
#define MSR_ZEN5_40H_MCA_SYND_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 6)
#define MSR_ZEN5_40H_MCA_DESTAT_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 8)
#define MSR_ZEN5_40H_MCA_DEADDR_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 9)
#define MSR_ZEN5_40H_MCA_MISC1_UMC(ch) (MSR_ZEN5_40H_MCAX_BASE(ch) | 0xA)
#define MSR_ZEN5_40H_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x15 + (ch & 1)))

#define MSR_ZEN5_68H_MCAX_BASE(ch) (0xC0002000 | ((0x0F + ch) << 4))
#define MSR_ZEN5_68H_MCA_CTL_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 0)
#define MSR_ZEN5_68H_MCA_STATUS_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 1)
#define MSR_ZEN5_68H_MCA_ADDR_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 2)
#define MSR_ZEN5_68H_MCA_MISC0_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 3)
#define MSR_ZEN5_68H_MCA_CONFIG_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 4)
#define MSR_ZEN5_68H_MCA_IPID_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 5)
#define MSR_ZEN5_68H_MCA_SYND_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 6)
#define MSR_ZEN5_68H_MCA_DESTAT_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 8)
#define MSR_ZEN5_68H_MCA_DEADDR_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 9)
#define MSR_ZEN5_68H_MCA_MISC1_UMC(ch) (MSR_ZEN5_68H_MCAX_BASE(ch) | 0xA)
#define MSR_ZEN5_68H_MCA_CTL_MASK_UMC(ch) (0xC0010400 | (0x0F + ch))

#define CPUID_EXTMODEL_EQ(model, target) ((model & 0xF0) == target)
#define MSR_ZEN5_MCA_CTL_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_CTL_UMC(ch) : MSR_ZEN5_40H_MCA_CTL_UMC(ch))
#define MSR_ZEN5_MCA_STATUS_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_STATUS_UMC(ch) : MSR_ZEN5_40H_MCA_STATUS_UMC(ch))
#define MSR_ZEN5_MCA_ADDR_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_ADDR_UMC(ch) : MSR_ZEN5_40H_MCA_ADDR_UMC(ch))
#define MSR_ZEN5_MCA_MISC0_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_MISC0_UMC(ch) : MSR_ZEN5_40H_MCA_MISC0_UMC(ch))
#define MSR_ZEN5_MCA_CONFIG_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_CONFIG_UMC(ch) : MSR_ZEN5_40H_MCA_CONFIG_UMC(ch))
#define MSR_ZEN5_MCA_IPID_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_IPID_UMC(ch) : MSR_ZEN5_40H_MCA_IPID_UMC(ch))
#define MSR_ZEN5_MCA_SYND_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_SYND_UMC(ch) : MSR_ZEN5_40H_MCA_SYND_UMC(ch))
#define MSR_ZEN5_MCA_DESTAT_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_DESTAT_UMC(ch) : MSR_ZEN5_40H_MCA_DESTAT_UMC(ch))
#define MSR_ZEN5_MCA_DEADDR_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_DEADDR_UMC(ch) : MSR_ZEN5_40H_MCA_DEADDR_UMC(ch))
#define MSR_ZEN5_MCA_MISC1_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_MISC1_UMC(ch) : MSR_ZEN5_40H_MCA_MISC1_UMC(ch))
#define MSR_ZEN5_MCA_CTL_MASK_UMC(model, ch) (CPUID_EXTMODEL_EQ(model, 0x60) ? MSR_ZEN5_68H_MCA_CTL_MASK_UMC(ch) : MSR_ZEN5_40H_MCA_CTL_MASK_UMC(ch))

#define MSR_ZEN5_MCA_BASE(bank) (0x00000400 + 4 * bank)
#define MSR_ZEN5_MCA_CTL(bank) (MSR_ZEN5_MCA_BASE(bank) + 0)
#define MSR_ZEN5_MCA_STATUS(bank) (MSR_ZEN5_MCA_BASE(bank) + 1)
#define MSR_ZEN5_MCA_ADDR(bank) (MSR_ZEN5_MCA_BASE(bank) + 2)
#define MSR_ZEN5_MCA_MISC0(bank) (MSR_ZEN5_MCA_BASE(bank) + 3)

#define MSR_ZEN5_SYS_CFG MSR_ZEN4_SYS_CFG
#define MSR_ZEN5_TOP_MEM MSR_ZEN4_TOP_MEM
#define MSR_ZEN5_TOM2 MSR_ZEN4_TOM2

#define MSR_ZEN5_PFEH_CFG MSR_ZEN4_PFEH_CFG
#define MSR_ZEN5_PFEH_CLOAK_CFG MSR_ZEN4_PFEH_CLOAK_CFG
#define MSR_ZEN5_PFEH_DEF_INT_MASK MSR_ZEN4_PFEH_DEF_INT_MASK

#define ZEN5_CFG_ADDRESS_CNTL ZEN4_CFG_ADDRESS_CNTL

#define ZEN5_UMCCONFIG_DDRTYPE_DDR5 0x1
#define ZEN5_UMCCONFIG_DDRTYPE_LPDDR5 0x6

#define zen5_df_ind_reg_read zen4_df_ind_reg_read

void setup_ryzen_zen5(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};

    unsigned long sdpctrl = 0;
    unsigned long umccap = 0;
    unsigned long umccaphi = 0;
    unsigned long eccctrl = 0;
    unsigned long eccerrcntsel = 0;
    unsigned long eccerrcntctrl = 0;
    UINT64 mcactlmask = 0;
    UINT64 mcacfg = 0;
    UINT64 mcactl = 0;
    UINT64 mcaipid = 0;
    UINT64 mcgctl = 0;
    UINT64 mcgcap = 0;
    UINT64 mcastatus = 0;
    UINT64 mcamisc0 = 0;
    UINT32 mcatype = 0;
    int mcabank = 0;
    int mcabankcnt = 0;
    unsigned node = 0;
    unsigned int bus = 0;
    int i;
    int cs;
    unsigned int model = CPUID_MODEL(&cpu_id);

    MtSupportDebugWriteLine("AMD Ryzen Zen 5 chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(ryzen_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    // Need to switch to CPU0??
    // From AMD:
    //    Yes, I think polling for ECC errors should be done by CPU0 on each die (APIC domain). If you are using the Corrected ECC Error Counter registers, they are available to all dies - but any interrupt from them is sent to logical core 0, and only logical core 0 has access to the MCA. So you may end up with incomplete information if polling from a different CPU.

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    unsigned long long MmioCfgBaseAddr;
    unsigned long long mmiobase;
    int mmiocfgen;
    _rdmsr64(MSR_MMIO_CFG_BASE_ADDR, &MmioCfgBaseAddr);

    mmiocfgen = (int)BitExtractULL(MmioCfgBaseAddr, 0, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "MmioCfgBaseAddr=" I64HEXFMT " (Enable=%d)", MmioCfgBaseAddr, mmiocfgen);

    mmiobase = LShiftU64(BitExtractULL(MmioCfgBaseAddr, 47, 20), 20);
    if (mmiobase > 0 && mmiocfgen) // Sanity check
    {
        ctrl->mchbar = mmiobase;
        AsciiFPrint(DEBUG_FILE_HANDLE, "MCHBAR=%p", ctrl->mchbar);

        zen5_df_ind_reg_read(ctrl, 0, ZEN5_CFG_ADDRESS_CNTL, 0x10, &ryzdata->cfgaddrcntl);

        AsciiSPrint(gBuffer, BUF_SIZE, "CfgAddressCntl = %08x (SecBusNum=%02X)", ryzdata->cfgaddrcntl, ryzdata->cfgaddrcntl & 0xFF);
        MtSupportDebugWriteLine(gBuffer);
        if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting bus %02X -> %02X", bus, ryzdata->cfgaddrcntl & 0xFF);
            MtSupportDebugWriteLine(gBuffer);
            bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);
        }
    }

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    if (CPUID_EXTMODEL_EQ(model, 0x60)) // Kraken Point
        ctrl->numch = 4;
    else if (CPUID_EXTMODEL_EQ(model, 0x00) || CPUID_EXTMODEL_EQ(model, 0x10)) // Turin
        ctrl->numch = 12;
    else // Granite Ridge (44h)
        ctrl->numch = 2;

    ctrl->numsl = 1;
    ctrl->chmode = 0;

    if (cpu_id.max_xcpuid >= 0x80000007)
    {
        unsigned int v[4];

        _cpuid(0x00000001, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x00000001]:EDX[31:0] = %08x (MCA=%d)", v[3], (v[3] >> 14) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        _cpuid(0x80000007, &v[0], &v[1], &v[2], &v[3]);

        AsciiSPrint(gBuffer, BUF_SIZE, "CPUID[0x80000007]:EBX[31:0] = %08x (PfehSupportPresent=%d, ScalableMCA=%d)", v[1], (v[1] >> 4) & 0x1, (v[1] >> 3) & 0x1);
        MtSupportDebugWriteLine(gBuffer);
#ifndef WIN32
        if (((v[1] >> 4) & 0x1) != 0)
        {
            UINT64 pfehcfg = 0;
            UINT64 pfehcloakcfg = 0;

            _rdmsr64(MSR_ZEN5_PFEH_CFG, &pfehcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CFG=" I64HEXFMT " (PfehEnable=%d)", pfehcfg, (int)BitExtractULL(pfehcfg, 0, 0));
            MtSupportDebugWriteLine(gBuffer);

            if ((pfehcfg & 0x1) != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Disabling PFEH (PFEH_CFG=" I64HEXFMT ")", pfehcfg & ~0x1ULL);
                MtSupportDebugWriteLine(gBuffer);

                _wrmsr64(MSR_ZEN5_PFEH_CFG, pfehcfg & ~0x1ULL);
            }

            _rdmsr64(MSR_ZEN5_PFEH_CLOAK_CFG, &pfehcloakcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "PFEH_CLOAK_CFG=" I64HEXFMT, pfehcloakcfg);
            MtSupportDebugWriteLine(gBuffer);
        }
#endif
        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        mcabankcnt = (int)(mcgcap & 0xFF);
        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, mcabankcnt);
        MtSupportDebugWriteLine(gBuffer);
    }

    for (i = 0; i < ctrl->numch; i++)
    {
        mcabank = (MSR_ZEN5_MCA_CTL_UMC(model, i) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),

        smn_read(bus, UMC_SDPCTRL(i), &sdpctrl);
        int SdpInit = BitExtract(sdpctrl, 31, 31);
        AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d]=%08x (SdpInit=%d)", i, sdpctrl, SdpInit);

        if (sdpctrl == 0xffffffff)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "SdpCtrl[%d] is invalid. Skipping...", i, sdpctrl, SdpInit);
            continue;
        }

        if (!SdpInit)
            continue;

        ctrl->chmode++;

        unsigned long DramConfig = 0;
        smn_read(bus, UMC_DRAMCONFIG(i), &DramConfig);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramConfiguration=%08x", i, DramConfig);

        unsigned long DebugMisc = 0;
        smn_read(bus, UMC_DEBUGMISC(i), &DebugMisc);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DebugMisc=%08x", i, DebugMisc);

        for (int n = 1; n <= 2; n++)
        {
            unsigned long DramTiming = 0;
            smn_read(bus, UMC_DRAMTIMING(i, n), &DramTiming);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DramTiming%d=%08x", i, n, DramTiming);
        }

        smn_read(bus, UMC_UMCCAP(i), &umccap);

        AsciiSPrint(gBuffer, BUF_SIZE, "UmcCap[%d]=0x%08X", i, umccap);
        MtSupportDebugWriteLine(gBuffer);

        if ((umccap & (1 << 17)) == 0)
        {
            /* Fill in the correct memory capabilites */
            smn_read(bus, UMC_UMCCAPHI(i), &umccaphi);

            AsciiSPrint(gBuffer, BUF_SIZE, "UmcCapHi[%d]=0x%08X", i, umccaphi);
            MtSupportDebugWriteLine(gBuffer);

            unsigned long eccmode = ddim[(umccaphi >> 30) & 3];
            if (ctrl->mode == ECC_NONE)
                ctrl->mode = eccmode;

            if (eccmode == ECC_NONE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "EccChipKillCap = 0 and EccEnabled = 0 for ch %d", i);
                MtSupportDebugWriteLine(gBuffer);

                continue;
            }
        }
        else
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "EccDis = 1 for ch %d", i);
            MtSupportDebugWriteLine(gBuffer);

            continue;
        }

#ifndef WIN32
        /* Check UMC Machine Check Control Mask */
        _rdmsr64(MSR_ZEN5_MCA_CTL_MASK_UMC(model, i), &mcactlmask);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_MASK_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactlmask, (UINT32)(mcactlmask & 1));
        MtSupportDebugWriteLine(gBuffer);

        if (mcactlmask & 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_MASK_UMC[%d][DramEccErr]=0", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN5_MCA_CTL_MASK_UMC(model, i), mcactlmask & ~1ULL);
        }

        /* Check UMC Machine Check Configuration */
        _rdmsr64(MSR_ZEN5_MCA_CONFIG_UMC(model, i), &mcacfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CONFIG_UMC[%d]=" I64HEXFMT, i, mcacfg);
        MtSupportDebugWriteLine(gBuffer);

        /* Check UMC Machine Check Control */
        _rdmsr64(MSR_ZEN5_MCA_CTL_UMC(model, i), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL_UMC[%d]=" I64HEXFMT " (DramEccErr=%d)", i, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL_UMC[%d][DramEccErr]=1", i);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN5_MCA_CTL_UMC(model, i), mcactl | 1ULL);
        }

        _rdmsr64(MSR_ZEN5_MCA_CTL(mcabank), &mcactl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_CTL[%d]=" I64HEXFMT " (DramEccErr=%d)", mcabank, mcactl, (UINT32)(mcactl & 1));
        MtSupportDebugWriteLine(gBuffer);

        if ((mcactl & 1) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCA_CTL[%d][DramEccErr]=1", mcabank);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_ZEN5_MCA_CTL(mcabank), mcactl | 1ULL);
        }

        /* Check UMC IP Identification */
        _rdmsr64(MSR_ZEN5_MCA_IPID_UMC(model, i), &mcaipid);

        mcatype = (UINT32)RShiftU64(mcaipid, 48) & 0xFFFF;

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_IPID_UMC[%d]=" I64HEXFMT " (McaType=%d)", i, mcaipid, mcatype);
        MtSupportDebugWriteLine(gBuffer);

        /* Enable NB ECC Logging by MSR Write */
        _rdmsr64(MSR_MCG_CTL, &mcgctl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL=" I64HEXFMT " [Bit %d = %d]", mcgctl, mcabank, (UINT32)RShiftU64(mcgctl, mcabank) & 0x1);
        MtSupportDebugWriteLine(gBuffer);

        if (mcabank < mcabankcnt && (mcgctl & LShiftU64(1, mcabank)) == 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCG_CTL to " I64HEXFMT, mcgctl | LShiftU64(1, mcabank));
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_MCG_CTL, mcgctl | LShiftU64(1, mcabank));
        }

        /* Check UMC DRAM ECC Control*/
        smn_read(bus, UMC_ECCCTRL(i), &eccctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCCTRL[%d]=%08x (RdEccEn=%d, WrEccEn=%d)", i, eccctrl, BitExtract(eccctrl, 10, 10), BitExtract(eccctrl, 0, 0));
        MtSupportDebugWriteLine(gBuffer);

        if (BitExtract(eccctrl, 10, 10) != 1 && BitExtract(eccctrl, 0, 0) != 1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCCTRL[%d] to %08x", i, eccctrl | ((1 << 10) | 1));
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCCTRL(i), eccctrl | ((1 << 10) | 1));
        }

        smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTSEL[%d]=%08x", i, eccerrcntsel);
        MtSupportDebugWriteLine(gBuffer);

        smn_read(bus, ZEN5_UMC_ECCERRCNTCTRL(i), &eccerrcntctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNTCTRL[%d]=%08x (EccErrCntEn=%d)", i, eccerrcntctrl, eccerrcntctrl & 1);
        MtSupportDebugWriteLine(gBuffer);

        if ((eccerrcntctrl & 1) == 0)
        {
            eccerrcntctrl |= 1;

            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ECCERRCNTCTRL[%d] to %08x", i, eccerrcntctrl);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, ZEN5_UMC_ECCERRCNTCTRL(i), eccerrcntctrl);
        }

        for (cs = 0; cs < 2; cs++)
        {
            unsigned long eccerrcnt = 0;

            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | cs);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "ECCERRCNT[%d] (SubCh/CS/Plr %d): %08x", i, cs, eccerrcnt);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, UMC_ECCERRCNT(i), eccerrcnt & 0xffff0000);
            }
        }

        _rdmsr64(MSR_ZEN5_MCA_STATUS_UMC(model, i), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT, i, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN5_MCA_STATUS_UMC(model, i), 0);

        _rdmsr64(MSR_ZEN5_MCA_STATUS(mcabank), &mcastatus);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS[%d]=" I64HEXFMT, mcabank, mcastatus);
        MtSupportDebugWriteLine(gBuffer);

        if (mcastatus != 0)
            _wrmsr64(MSR_ZEN5_MCA_STATUS(mcabank), 0);

        _rdmsr64(MSR_ZEN5_MCA_MISC0(mcabank), &mcamisc0);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT, mcabank, mcamisc0);
        MtSupportDebugWriteLine(gBuffer);
#endif
    }

#ifndef WIN32
    UINT64 tom, msr_val;

    /*
     * Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since
     * those are Read-As-Zero.
     */
    _rdmsr64(MSR_ZEN5_TOP_MEM, &tom);
    AsciiSPrint(gBuffer, BUF_SIZE, "TOP_MEM=" I64HEXFMT, tom);
    MtSupportDebugWriteLine(gBuffer);

    /* Check first whether TOP_MEM2 is enabled: */
    _rdmsr64(MSR_ZEN5_SYS_CFG, &msr_val);
    AsciiSPrint(gBuffer, BUF_SIZE, "SYS_CFG=" I64HEXFMT " (MtrrTom2En=%d)", msr_val, (int)BitExtractULL(msr_val, 21, 21));
    MtSupportDebugWriteLine(gBuffer);

    if (BitExtractULL(msr_val, 21, 21) == 1)
    {
        _rdmsr64(MSR_ZEN5_TOM2, &tom);
        AsciiSPrint(gBuffer, BUF_SIZE, "TOM2=" I64HEXFMT, tom);
        MtSupportDebugWriteLine(gBuffer);
    }
#endif
    /*
    Coherent Slave 0 (UMC0)00h 00h
    Coherent Slave 1 (UMC1)01h 01h
    Coherent Slave 2 (UMC2)02h 02h
    Coherent Slave 3 (UMC3)03h 03h
    */
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        smn_read(bus, UMC_UMCCONFIG(mc), &ryzdata->UmcConfig[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] UmcConfig=%08x (DramReady=%d)", mc, ryzdata->UmcConfig[mc], BitExtract(ryzdata->UmcConfig[mc], 31, 31));
        MtSupportDebugWriteLine(gBuffer);

        // DramReady. Read-write. Reset: 0. 0=Disable. 1=Enable. Specifies the memory sub-system is initialized and ready for system traffic.
        if (BitExtract(ryzdata->UmcConfig[mc], 31, 31) == 0)
            continue;

        zen5_df_ind_reg_read(ctrl, 0, ZEN5_IND_CFG_DF_FBII3, mc, &ryzdata->FabricBlockInstanceInformation3[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] FabricBlockInstanceInformation3=%08x", mc, ryzdata->FabricBlockInstanceInformation3[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMHOLECONTROL, mc, &ryzdata->DramHoleControl[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramHoleControl=%08x", mc, ryzdata->DramHoleControl[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMOFFSET, mc, &ryzdata->DramOffset[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] DramOffset=%08x", mc, ryzdata->DramOffset[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen5_df_ind_reg_read(ctrl, 4, ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK0, mc, &ryzdata->SystemFabricIdMask0[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask0=%08x", mc, ryzdata->SystemFabricIdMask0[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen5_df_ind_reg_read(ctrl, 4, ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK1, mc, &ryzdata->SystemFabricIdMask1[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask1=%08x", mc, ryzdata->SystemFabricIdMask1[mc]);
        MtSupportDebugWriteLine(gBuffer);

        zen5_df_ind_reg_read(ctrl, 4, ZEN5_IND_CFG_DF_SYSTEMFABRICIDMASK2, mc, &ryzdata->SystemFabricIdMask2[mc]);
        AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] SystemFabricIdMask2=%08x", mc, ryzdata->SystemFabricIdMask2[mc]);
        MtSupportDebugWriteLine(gBuffer);

        for (UINT16 n = 0; n < 3; n++)
        {
            int nind = mc * 3 + n;

            zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMBASEADDRESS(n), mc, &ryzdata->DramBaseAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramBaseAddress=%08x", mc, n, ryzdata->DramBaseAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMLIMITADDRESS(n), mc, &ryzdata->DramLimitAddress[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramLimitAddress=%08x", mc, n, ryzdata->DramLimitAddress[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMADDRESSCTL(n), mc, &ryzdata->DramAddressCtl[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressCtl=%08x", mc, n, ryzdata->DramAddressCtl[nind]);
            MtSupportDebugWriteLine(gBuffer);

            zen5_df_ind_reg_read(ctrl, 7, ZEN5_IND_CFG_DF_DRAMADDRESSINTLV(n), mc, &ryzdata->DramAddressIntlv[nind]);
            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d,n%d] DramAddressIntlv=%08x", mc, n, ryzdata->DramAddressIntlv[nind]);
            MtSupportDebugWriteLine(gBuffer);

            smn_read(bus, ZEN5_UMC_ADDRHASHCS(mc, n), &ryzdata->AddrHashCS[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d,n%d] AddrHashCS: %08x", mc, n, ryzdata->AddrHashCS[nind]);

            smn_read(bus, ZEN5_UMC_DIMMCFG(mc, n), &ryzdata->DimmCfg[nind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, DIMM%d] DimmCfg: %08x", mc, n, ryzdata->DimmCfg[nind]);
            if (BitExtract(ryzdata->DimmCfg[nind], 7, 7))
                ctrl->chipwidth[mc * 2 + n] = 16;
            else if (BitExtract(ryzdata->DimmCfg[nind], 6, 6))
                ctrl->chipwidth[mc * 2 + n] = 4;
            else
                ctrl->chipwidth[mc * 2 + n] = 8;
        }

        for (cs = 0; cs < 4; cs++)
        {
            int csind = mc * 4 + cs;
            smn_read(bus, ZEN5_UMC_BASEADDR(mc, cs), &ryzdata->CSBaseAddr[csind]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddr: %08x", mc, cs, ryzdata->CSBaseAddr[csind]);

            int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
            if (CSEnable)
            {
                smn_read(bus, ZEN5_UMC_BASEADDRSEC(mc, cs), &ryzdata->CSBaseAddrSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] BaseAddrSec: %08x", mc, cs, ryzdata->CSBaseAddrSec[csind]);
                smn_read(bus, ZEN5_UMC_ADDRMASK(mc, cs), &ryzdata->CSAddrMask[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMask: %08x", mc, cs, ryzdata->CSAddrMask[csind]);
                smn_read(bus, ZEN5_UMC_ADDRMASKSEC(mc, cs), &ryzdata->CSAddrMaskSec[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrMaskSec: %08x", mc, cs, ryzdata->CSAddrMaskSec[csind]);
                smn_read(bus, ZEN5_UMC_ADDRCFG(mc, cs), &ryzdata->AddrCfg[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrCfg: %08x", mc, cs, ryzdata->AddrCfg[csind]);
                smn_read(bus, ZEN5_UMC_ADDRSEL(mc, cs), &ryzdata->AddrSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] AddrSel: %08x", mc, cs, ryzdata->AddrSel[csind]);
                smn_read(bus, ZEN5_UMC_COLSELLO(mc, cs), &ryzdata->ColSelLo[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelLo: %08x", mc, cs, ryzdata->ColSelLo[csind]);
                smn_read(bus, ZEN5_UMC_COLSELHI(mc, cs), &ryzdata->ColSelHi[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] ColSelHi: %08x", mc, cs, ryzdata->ColSelHi[csind]);
                smn_read(bus, ZEN5_UMC_RMSEL(mc, cs), &ryzdata->RmSel[csind]);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[UMC%d, CS%d] RmSel: %08x", mc, cs, ryzdata->RmSel[csind]);

                int dimm = cs / 2;
                ctrl->numranks[mc * 2 + dimm]++;
            }
        }
    }
}

static void zen5_decode_addr(struct ecc_info *ctrl, unsigned long long addr, int *pmc, int *pch, int *pcs, unsigned long long *pnormaddr)
{
    int mc = -1, ch = -1, cs = -1;
    unsigned long long normaddr = 0;
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    for (int umc = 0; umc < ctrl->numch; umc++)
    {
        for (UINT16 n = 0; n < 3; n++)
        {
            int nind = umc * 3 + n;

            int AddrRngVal = BitExtract(ryzdata->DramAddressCtl[nind], 0, 0);
            if (AddrRngVal == 0)
                continue;

            unsigned long long mcbase = LShiftU64(BitExtract(ryzdata->DramBaseAddress[nind], 19, 0), 28);
            unsigned long long mclimit = LShiftU64(BitExtract(ryzdata->DramLimitAddress[nind], 19, 0), 28) | (LShiftU64(1, 28) - 1);
            unsigned short DstFabricID = BitExtract(ryzdata->DramAddressCtl[nind], 21, 16);

            if ((addr >= mcbase) && (addr <= mclimit))
            {
                const unsigned long INTLV_CHANBITS_MAP[] = {0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                unsigned long intlv_socketbits = BitExtract(ryzdata->DramAddressIntlv[nind], 18, 18);
                unsigned long intlv_diebits = BitExtract(ryzdata->DramAddressIntlv[nind], 13, 12);
                unsigned long IntLvNumChan = BitExtract(ryzdata->DramAddressIntlv[nind], 9, 4);
                unsigned long intlv_chanbits = IntLvNumChan < 0xC ? INTLV_CHANBITS_MAP[IntLvNumChan] : IntLvNumChan - 0xB;

                int intlv_lsb = BitExtract(ryzdata->DramAddressIntlv[nind], 2, 0) + 8;

                normaddr = addr;

                // sys addr -> norm  addr

                // hash addr
                mc = DstFabricID & (ctrl->numch - 1);
                if (intlv_chanbits != 0)
                {
                    int chhash = IntLvNumChan >= 0xC;
                    int HashIntlvCtl4K = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 7, 7);
                    int HashIntlvCtl64K = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 8, 8);
                    int HashIntlvCtl2M = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 9, 9);
                    int HashIntlvCtl1G = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 10, 10);
                    int HashIntlvCtl1T = chhash && BitExtract(ryzdata->DramAddressCtl[nind], 15, 15);

                    for (int i = 0; i < (int)intlv_chanbits; i++)
                    {
                        int hashbit = (int)BitExtractULL(normaddr, intlv_lsb + i, intlv_lsb + i);
                        if (HashIntlvCtl4K)
                            hashbit ^= BitExtractULL(normaddr, 12 + i, 12 + i);
                        if (HashIntlvCtl64K)
                            hashbit ^= BitExtractULL(normaddr, 16 + i, 16 + i);
                        if (HashIntlvCtl2M)
                            hashbit ^= BitExtractULL(normaddr, 21 + i, 21 + i);
                        if (HashIntlvCtl1G)
                            hashbit ^= BitExtractULL(normaddr, 30 + i, 30 + i);
                        if (HashIntlvCtl1T)
                            hashbit ^= BitExtractULL(normaddr, 40 + i, 40 + i);

                        if (BitExtractULL(normaddr, intlv_lsb + i, intlv_lsb + i) != hashbit)
                            normaddr ^= LShiftU64(1, intlv_lsb + i);

                        mc ^= (hashbit << i);
                    }
                }

                // check dram hole
                int LgcyMmioHoleEn = BitExtract(ryzdata->DramAddressCtl[nind], 1, 1);

                if (LgcyMmioHoleEn)
                {
                    unsigned long long DramHoleBase = LShiftU64(BitExtractULL(ryzdata->DramHoleControl[umc], 31, 24), 24);
                    unsigned long long DramHoleSize = 0x100000000ULL - DramHoleBase;

                    if (normaddr >= (DramHoleBase + DramHoleSize))
                    {
                        normaddr -= DramHoleSize;
                    }
                }

                // subtract base addr
                normaddr -= mcbase;

                // normalize address
                if (intlv_chanbits != 0)
                {
                    // remove cs id
                    int num_intlv_bits = intlv_socketbits + intlv_diebits + intlv_chanbits;
                    unsigned short cs_id = (unsigned short)BitExtractULL(normaddr, intlv_lsb + num_intlv_bits - 1, intlv_lsb);
                    (void)cs_id;

                    normaddr = LShiftU64(BitExtractULL(normaddr, 63, intlv_lsb + num_intlv_bits), intlv_lsb) | BitExtractULL(normaddr, intlv_lsb - 1, 0);
                }

                // add dramoffset
                int HiAddrOffsetEn = BitExtract(ryzdata->DramOffset[umc], 0, 0);
                if (HiAddrOffsetEn)
                {
                    unsigned long long HiAddrOffset = LShiftU64(BitExtract(ryzdata->DramOffset[umc], 20, 1), 28);
                    if (n > 0)
                    {
                        normaddr += HiAddrOffset;
                    }
                }

                // look up cs
                for (int i = 0; i < 4; i++)
                {
                    int csind = mc * 4 + i;
                    int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
                    if (CSEnable == 0)
                        continue;

                    unsigned long long CSBase = LShiftU64(BitExtractULL(ryzdata->CSBaseAddr[csind], 31, 1), 9);
                    unsigned long long CSMask = LShiftU64(~BitExtractULL(ryzdata->CSAddrMask[csind], 31, 1), 9);

                    int ch_bit = BitExtract(ryzdata->RmSel[csind], 19, 16) + 5;

                    if ((normaddr & CSMask) == (CSBase & CSMask))
                    {
                        int XorEn_n0 = BitExtract(ryzdata->AddrHashCS[mc * 2], 0, 0);
                        unsigned long long NormAddrXor_n0 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2], 31, 1), 9);
                        int XorEn_n1 = BitExtract(ryzdata->AddrHashCS[mc * 2 + 1], 0, 0);
                        unsigned long long NormAddrXor_n1 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2 + 1], 31, 1), 9);
                        int XorEn_ch = BitExtract(ryzdata->AddrHashPC[mc], 0, 0);

                        if (XorEn_n0 | XorEn_n1)
                        {
                            unsigned long long xorbits_n0 = 0;
                            unsigned long long xorbits_n1 = 0;
                            if (XorEn_n0)
                                xorbits_n0 = normaddr & NormAddrXor_n0;
                            if (XorEn_n1)
                                xorbits_n1 = normaddr & NormAddrXor_n1;

                            int cshash_n0 = 0;
                            int cshash_n1 = 0;
                            for (int bit = 0; bit < 63; bit++)
                            {
                                cshash_n0 ^= (int)(RShiftU64(xorbits_n0, bit) & 1);
                                cshash_n1 ^= (int)(RShiftU64(xorbits_n1, bit) & 1);
                            }
                            cs = i ^ ((cshash_n1 << 1) | cshash_n0);
                        }
                        else
                        {
                            cs = i;
                        }

                        if (XorEn_ch)
                        {
                            unsigned long long RowXor = BitExtract(ryzdata->AddrHashPC[mc], 31, 14);
                            unsigned long long ColXor = BitExtract(ryzdata->AddrHashPC[mc], 13, 1);
                            unsigned long long BankXor = BitExtract(ryzdata->AddrHashPC2[mc], 4, 0);
                            int num_row_bits = BitExtract(ryzdata->AddrCfg[csind], 11, 8) + 10;
                            int row_lsb = BitExtract(ryzdata->AddrSel[csind], 27, 24) + 12;
                            unsigned long long rowaddr = BitExtractULL(normaddr, row_lsb + num_row_bits - 1, row_lsb);
                            unsigned long long xorbits_row = rowaddr & RowXor;

                            int chhash_row = 0;
                            for (int bit = 0; bit < num_row_bits; bit++)
                                chhash_row ^= (int)(RShiftU64(xorbits_row, bit) & 1);

                            ch = (int)BitExtractULL(normaddr, ch_bit, ch_bit) ^ chhash_row;

                            (void)ColXor;
                            (void)BankXor;

                            AsciiFPrint(DEBUG_FILE_HANDLE, "zen5_decode_addr - A(%p,%d,%d,%p,%d,%d)", RowXor, num_row_bits, row_lsb, rowaddr, chhash_row, ch);
                        }
                        else
                        {
                            if (1) // 78h-7bh: Each 32-bit channel of a DDR5 module is controlled by a single UMC in this SOC
                                ch = (mc & 1) ^ 1;
                            else
                                ch = (int)BitExtractULL(normaddr, ch_bit, ch_bit);
                        }

                        AsciiFPrint(DEBUG_FILE_HANDLE, "zen5_decode_addr - B(%d,%d,%p,%p,%d)", cs, ch, CSBase, CSMask, XorEn_n0 | XorEn_n1);

                        break;
                    }
                }
                break;
            }
        }
        if (mc >= 0)
            break;
    }
    if (pmc)
        *pmc = mc;
    if (pch)
        *pch = ch;
    if (pcs)
        *pcs = cs;
    if (pnormaddr)
        *pnormaddr = normaddr;
}

/*
 * Athlon64/Opteron memory controller
 *
 * Reference: http://support.amd.com/TechDocs/26094.pdf
 */
static void setup_amd64(struct ecc_info *ctrl)
{

    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_RESERVED, ECC_CHIPKILL};
    unsigned long nbxcfg;
    unsigned int mcgsrl;
    unsigned int mcgsth;
    unsigned long mcanb;
    unsigned long dramcl;

    MtSupportDebugWriteLine("AMD64 chipset init");

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;

    /* Check First if ECC DRAM Modules are used */
    pci_conf_read(0, 24, 2, 0x90, 4, &dramcl);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRAM config low=%08x", dramcl);
    MtSupportDebugWriteLine(gBuffer);

    if (((cpu_id.max_xcpuid /*cpu_id.ext */ >> 16) & 0xF) >= 4)
    {
        /* NEW K8 0Fh Family 90 nm */

        if ((dramcl >> 19) & 1)
        {
            /* Fill in the correct memory capabilites */
            pci_conf_read(0, 24, 3, 0x44, 4, &nbxcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB config=%08x", nbxcfg);
            MtSupportDebugWriteLine(gBuffer);

            ctrl->mode = ddim[(nbxcfg >> 22) & 3];
        }
        else
        {
            ctrl->mode = ECC_NONE;
        }
        /* Enable NB ECC Logging by MSR Write */
        rdmsr(0x017B, mcgsrl, mcgsth);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL low=%08x", mcgsrl);
        MtSupportDebugWriteLine(gBuffer);

        wrmsr(0x017B, 0x10, mcgsth);

        /* Clear any previous error */
        pci_conf_read(0, 24, 3, 0x4C, 4, &mcanb);
        pci_conf_write(0, 24, 3, 0x4C, 4, mcanb & 0x7FFFFFFF);
    }
    else
    {
        /* OLD K8 130 nm */

        if ((dramcl >> 17) & 1)
        {
            /* Fill in the correct memory capabilites */
            pci_conf_read(0, 24, 3, 0x44, 4, &nbxcfg);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB config=%08x", nbxcfg);
            MtSupportDebugWriteLine(gBuffer);

            ctrl->mode = ddim[(nbxcfg >> 22) & 3];
        }
        else
        {
            ctrl->mode = ECC_NONE;
        }
        /* Enable NB ECC Logging by MSR Write */
        rdmsr(0x017B, mcgsrl, mcgsth);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL low=%08x", mcgsrl);
        MtSupportDebugWriteLine(gBuffer);

        wrmsr(0x017B, 0x10, mcgsth);

        /* Clear any previous error */
        pci_conf_read(0, 24, 3, 0x4C, 4, &mcanb);
        pci_conf_write(0, 24, 3, 0x4C, 4, mcanb & 0x7F801EFC);
    }
}

// Reference: BIOS and Kernel Developer's Guide (BKDG) For AMD Family 10h Processors
// 31116 Rev 3.62 - January 11, 2013
#define AMD_10H_DRAM_CONTROL(ch) (ch * 0x100 + 0x78)
#define AMD_10H_DRAM_INIT(ch) (ch * 0x100 + 0x7C)
#define AMD_10H_DRAM_MRS(ch) (ch * 0x100 + 0x84)
#define AMD_10H_DRAM_TIMING_LO(ch) (ch * 0x100 + 0x88)
#define AMD_10H_DRAM_TIMING_HI(ch) (ch * 0x100 + 0x8C)
#define AMD_10H_DRAM_CONFIG_LO(ch) (ch * 0x100 + 0x90)
#define AMD_10H_DRAM_CONFIG_HI(ch) (ch * 0x100 + 0x94)
#define AMD_10H_MCA_NB_CONFIG 0x44
#define AMD_10H_MCA_NB_STATUS_LO 0x48
#define AMD_10H_MCA_NB_STATUS_HI 0x4C
#define AMD_10H_DRAM_CTRL_SELECT_LO 0x110

#define MSR_MCi_CTL_MASK(i) (0xC0010044 + i)

static void setup_amd10h(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_NONE, ECC_CHIPKILL};
    unsigned long nbcfg;
    // unsigned long nbxcfg;
    unsigned int mcgsrl;
    unsigned int mcgsth;
    UINT64 mc4ctl;
    UINT64 mc4ctlmask;
    unsigned long mcanb;
    unsigned long dramcfgl, dramcfgh;

    MtSupportDebugWriteLine("AMD 10h and greater chipset init");

    /* All AMD64 support Chipkill */
    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    unsigned long long MmioCfgBaseAddr;
    unsigned long long mmiobase;
    int mmiocfgen;
    _rdmsr64(MSR_MMIO_CFG_BASE_ADDR, &MmioCfgBaseAddr);

    mmiocfgen = (int)BitExtractULL(MmioCfgBaseAddr, 0, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "MmioCfgBaseAddr=" I64HEXFMT " (Enable=%d)", MmioCfgBaseAddr, mmiocfgen);

    mmiobase = LShiftU64(BitExtractULL(MmioCfgBaseAddr, 47, 20), 20);
    if (mmiobase > 0 && mmiocfgen) // Sanity check
    {
        ctrl->mchbar = mmiobase;
        AsciiFPrint(DEBUG_FILE_HANDLE, "MCHBAR=%p", ctrl->mchbar);
    }

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        /* Check First if ECC DRAM Modules are used */
        dramcfgl = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_CONFIG_LO(ch));
        AsciiSPrint(gBuffer, BUF_SIZE, "[DCT%d] DRAM config low=%08x", ch, dramcfgl);
        MtSupportDebugWriteLine(gBuffer);

        if (BitExtract(dramcfgl, 19, 19))
        { // DimmEccEn: DIMM ECC enable
            /* Fill in the correct memory capabilites */
            pci_conf_read(ctrl->bus, ctrl->dev, 3, AMD_10H_MCA_NB_CONFIG, 4, &nbcfg);

            // pci_conf_read(0, 24, 3, 0x88, 4, &nbcfg); // NB config 1 low NB_CFG1_LO
            // 27 DisDramScrub. Read-write; Per-node. Reset: 0. 1=Disable DRAM ECC scrubbing

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB config=%08x", nbcfg);
            MtSupportDebugWriteLine(gBuffer);

            ctrl->mode = ddim[BitExtract(nbcfg, 23, 22)];

            if (BitExtract(nbcfg, 31, 31) == 0) // NbMcaLogEn: Northbridge MCA log enable
            {
                MtSupportDebugWriteLine("NbMcaLogEn is disabled. Enabling...");
                pci_conf_write(ctrl->bus, ctrl->dev, 3, AMD_10H_MCA_NB_CONFIG, 4, nbcfg | (1UL << 31));
            }
#if 0
            /* Fill in the correct memory capabilites */
            pci_conf_read(0, 24, 3, 0x180, 4, &nbxcfg); // ECC checking is based on x8 ECC symbols (D18F3x180[EccSymbolSize]) and can be used for chipkill

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA Extended NB config=%08x [EccSymbolSize=%s]", nbxcfg, nbxcfg & (1 << 25) ? L"x8" : L"x4");
            MtSupportDebugWriteLine(gBuffer);
#endif
        }

        dramcfgh = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_CONFIG_HI(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM config high=%08x", ch, dramcfgh);

        if (BitExtract(dramcfgh, 3, 3)) // MemClkFreqVal: memory clock frequency valid.
            ctrl->chmode++;

        unsigned long val;
        val = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_CONTROL(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM control=%08x", ch, val);

        val = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_INIT(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM init=%08x", ch, val);

        val = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_MRS(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM MRS=%08x", ch, val);

        val = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_TIMING_LO(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM timing low=%08x", ch, val);

        val = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_TIMING_HI(ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[DCT%d] DRAM timing high=%08x", ch, val);
    }

    _rdmsr64(MSR_IA32_MCi_CTL(4), &mc4ctl);

    AsciiSPrint(gBuffer, BUF_SIZE, "MC4_CTL=" I64HEXFMT, mc4ctl);
    MtSupportDebugWriteLine(gBuffer);

    _rdmsr64(MSR_MCi_CTL_MASK(4), &mc4ctlmask);

    AsciiSPrint(gBuffer, BUF_SIZE, "MC4_CTL_MASK=" I64HEXFMT, mc4ctlmask);
    MtSupportDebugWriteLine(gBuffer);

    /* Enable NB ECC Logging by MSR Write */
    rdmsr(MSR_MCG_CTL, mcgsrl, mcgsth);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CTL low=%08x", mcgsrl);
    MtSupportDebugWriteLine(gBuffer);

    wrmsr(MSR_MCG_CTL, mcgsrl | (1 << 4), mcgsth); // NBE: Northbridge register bank enable

    /* Clear any previous error */
    pci_conf_read(ctrl->bus, ctrl->dev, 3, AMD_10H_MCA_NB_STATUS_HI, 4, &mcanb);

    if (mcanb)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Status High=%08x. Clearing previous error...", mcanb);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_write(ctrl->bus, ctrl->dev, 3, AMD_10H_MCA_NB_STATUS_HI, 4, mcanb & 0x7FFFFFFF);
    }
}

static void poll_timings_k10(struct ecc_info *ctrl)
{
    ulong dramtiming_lo, dramctrlsel_lo, dramconfig_hi;
    unsigned long memclk = 0;
    unsigned char tcas, trcd, trp, tras, trc;

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_TIMING_LO(ch), 4, &dramtiming_lo);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_k10 - [DCT%d] DRAM_TIMING_LO=%08x", ch, dramtiming_lo);
        dramctrlsel_lo = pciex_conf_read32((UINTN)ctrl->mchbar, ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_CTRL_SELECT_LO);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_k10 - [DCT%d] DRAM_CTRL_SELECT_LO=%08x", ch, dramctrlsel_lo);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, AMD_10H_DRAM_CONFIG_HI(ch), 4, &dramconfig_hi);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_k10 - [DCT%d] DRAM_CONFIG_HI=%08x", ch, dramconfig_hi);

        int MemClkFreqVal = BitExtract(dramconfig_hi, 3, 3);
        if (MemClkFreqVal == 0)
            continue;

        int ddr3mode = BitExtract(dramconfig_hi, 8, 8);

        if (ddr3mode)
        {
            // CAS Latency (tCAS)
            tcas = BitExtract(dramtiming_lo, 3, 0) + 4;
            // RAS-To-CAS (tRCD)
            trcd = BitExtract(dramtiming_lo, 6, 4) + 5;
            // RAS Precharge (tRP)
            trp = BitExtract(dramtiming_lo, 9, 7) + 5;
            // RAS Active to precharge (tRAS)
            tras = BitExtract(dramtiming_lo, 15, 12) + 15;
            // Row Cycle Time (tRC)
            trc = BitExtract(dramtiming_lo, 20, 16) + 11;

            switch (BitExtract(dramconfig_hi, 2, 0))
            {
            case 0b010:
                memclk = 333;
                break;
            case 0b011:
                memclk = 400;
                break;
            case 0b100:
                memclk = 533;
                break;
            case 0b101:
                memclk = 667;
                break;
            case 0b110:
                memclk = 800;
                break;
            default:
                break;
            }
        }
        else
        {
            // CAS Latency (tCAS)
            tcas = BitExtract(dramtiming_lo, 3, 0) + 1;
            // RAS-To-CAS (tRCD)
            trcd = BitExtract(dramtiming_lo, 6, 4) + 3;
            // RAS Precharge (tRP)
            trp = BitExtract(dramtiming_lo, 9, 8) + 3;
            // RAS Active to precharge (tRAS)
            tras = BitExtract(dramtiming_lo, 15, 12) + 13;
            // Row Cycle Time (tRC)
            trc = BitExtract(dramtiming_lo, 19, 16) + 11;

            switch (BitExtract(dramconfig_hi, 2, 0))
            {
            case 0b000:
                memclk = 200;
                break;
            case 0b001:
                memclk = 266;
                break;
            case 0b010:
                memclk = 333;
                break;
            case 0b011:
                memclk = 400;
                break;
            case 0b100:
                memclk = 533;
                break;
            default:
                break;
            }
        }

        ctrl->memclk = memclk;

        ctrl->tAA = tcas;
        ctrl->tRCD = trcd;
        ctrl->tRAS = tras;
        ctrl->tRP = trp;
        ctrl->tRC = trc;
    }
}

static void poll_ryzen(struct ecc_info *ctrl)
{
    unsigned long eccerrcnt;
    unsigned node = 0;
    unsigned int bus = 0;
    UINT64 mcastatus = 0, mcaaddr = 0, mcasynd = 0;
    UINT64 mcadestat = 0, mcadeaddr = 0;
    UINT64 addr, lsb;
    unsigned long syndrome, syndlen;
    int rank;
    int uncorrected;

    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (UINT8 ch = 0; ch < ctrl->numch; ch++)
    {
        int slot;
        int cs;
        for (cs = 0; cs < 4; cs++)
        {
            int rm;

            slot = cs < 2 ? 0 : 1;
            for (rm = 0; rm < 1; rm++)
            {
                unsigned long eccerrcntsel = 0;

                /* DRAM ECC Error Count Select register */
                smn_read(bus, UMC_ECCERRCNTSEL(ch), &eccerrcntsel);
                if (eccerrcntsel == 0xffffffff)
                    continue;

                smn_write(bus, UMC_ECCERRCNTSEL(ch), eccerrcntsel | (rm << 4) | cs);

                smn_read(bus, UMC_ECCERRCNT(ch), &eccerrcnt);
                if (eccerrcnt == 0xffffffff)
                    continue;

                if (eccerrcnt & 0x0000ffff)
                    dimmerrcnt[ch * ctrl->numsl + slot] += eccerrcnt & 0x0000ffff;
            }
        }

        // compare with previous dimm error count
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", ctrl->ctrlno * ctrl->numch + ch, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }

        _rdmsr64(MSR_MCA_STATUS_UMC(ch), &mcastatus);

        if (mcastatus & (1ULL << 63))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT " (Overflow=%d, UC=%d, CECC=%d, UECC=%d, Deferred=%d, Scrub=%d, ErrorCode=%04X)",
                        ch,
                        mcastatus,
                        (unsigned long)BitExtractULL(mcastatus, 62, 62),
                        (unsigned long)BitExtractULL(mcastatus, 61, 61),
                        (unsigned long)BitExtractULL(mcastatus, 46, 46),
                        (unsigned long)BitExtractULL(mcastatus, 45, 45),
                        (unsigned long)BitExtractULL(mcastatus, 44, 44),
                        (unsigned long)BitExtractULL(mcastatus, 40, 40),
                        (unsigned long)(mcastatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            uncorrected = (int)(RShiftU64(mcastatus, 45) & 1);

            _rdmsr64(MSR_MCA_DESTAT_UMC(ch), &mcadestat);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DESTAT_UMC[%d]=" I64HEXFMT, ch, mcadestat);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_MCA_DEADDR_UMC(ch), &mcadeaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DEADDR_UMC[%d]=" I64HEXFMT, ch, mcadeaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Read the address */
            _rdmsr64(MSR_MCA_ADDR_UMC(ch), &mcaaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_ADDR_UMC[%d]=" I64HEXFMT, ch, mcaaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location */
            lsb = (mcaaddr >> 56) & 0x3F;
            addr = mcaaddr & ((1ULL << 56) - 1);
            addr &= ~(lsb - 1);

            /* Read the syndrome */
            _rdmsr64(MSR_MCA_SYND_UMC(ch), &mcasynd);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_SYND_UMC[%d]=" I64HEXFMT " (Chip Select=%d, Rank multiply=%d, Symbol=%d)", ch, mcasynd, (unsigned long)(mcasynd & 0x7), (unsigned long)(mcasynd >> 4) & 0x7, (unsigned long)(RShiftU64(mcasynd, 8) & 0x3f));
            MtSupportDebugWriteLine(gBuffer);

            syndlen = (mcasynd >> 18) & 0x3F;
            syndrome = (mcasynd >> 32) & 0xFFFF;
            syndrome &= (unsigned long)(LShiftU64(1, syndlen) - 1);
            rank = mcasynd & 0x7;

            /* Report the error */
            MtSupportReportECCError((UINTN)addr, uncorrected == 0, syndrome, -1, ch, rank < 2 ? 0 : 1);

            /* Clear the error registers */
            _wrmsr64(MSR_MCA_STATUS_UMC(ch), 0);
        }
    }
}

static void zen2_decode_addr(struct ecc_info *ctrl, unsigned long long addr, int *pmc, int *pch, int *pcs, unsigned long long *pnormaddr)
{
    int mc = -1, ch = -1, cs = -1;
    unsigned long long normaddr = 0;
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    for (int umc = 0; umc < ctrl->numch; umc++)
    {
        for (UINT16 n = 0; n < 2; n++)
        {
            int nind = umc * 2 + n;

            int AddrRngVal = BitExtract(ryzdata->DramBaseAddress[nind], 0, 0);
            if (AddrRngVal == 0)
                continue;

            unsigned long long mcbase = LShiftU64(BitExtract(ryzdata->DramBaseAddress[nind], 31, 12), 28);
            unsigned long long mclimit = LShiftU64(BitExtract(ryzdata->DramLimitAddress[nind], 31, 12), 28) | (LShiftU64(1, 28) - 1);
            unsigned short DstFabricID = BitExtract(ryzdata->DramLimitAddress[nind], 9, 0);

            if ((addr >= mcbase) && (addr <= mclimit))
            {
                const unsigned long INTLV_CHANBITS_MAP[] = {0, 1, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - A(%p,%d,%d,%p,%p,%d)", addr, umc, n, mcbase, mclimit, DstFabricID);

                unsigned long intlv_socketbits = BitExtract(ryzdata->DramBaseAddress[nind], 8, 8);
                unsigned long intlv_diebits = BitExtract(ryzdata->DramBaseAddress[nind], 7, 6);
                unsigned long IntLvNumChan = BitExtract(ryzdata->DramBaseAddress[nind], 5, 2);
                unsigned long intlv_chanbits = IntLvNumChan < 0xC ? INTLV_CHANBITS_MAP[IntLvNumChan] : IntLvNumChan - 0xB;
                int chhash = IntLvNumChan >= 0xC;

                int intlv_lsb = BitExtract(ryzdata->DramBaseAddress[nind], 11, 9) + 8;

                normaddr = addr;

                // sys addr -> norm  addr

                // hash addr
                mc = DstFabricID & (ctrl->numch - 1);
                if (intlv_chanbits != 0)
                {
                    int GlbHashIntlvCtl64K = chhash && BitExtract(ryzdata->DfGlobalCtrl[umc], 20, 20);
                    int GlbHashIntlvCtl2M = chhash && BitExtract(ryzdata->DfGlobalCtrl[umc], 21, 21);
                    int GlbHashIntlvCtl1G = chhash && BitExtract(ryzdata->DfGlobalCtrl[umc], 22, 22);
                    int hashbit = 0;

                    hashbit = (int)BitExtractULL(normaddr, intlv_lsb, intlv_lsb);
                    if (chhash)
                        hashbit ^= BitExtractULL(normaddr, 14, 14);
                    if (GlbHashIntlvCtl64K)
                        hashbit ^= BitExtractULL(normaddr, 18, 18);
                    if (GlbHashIntlvCtl2M)
                        hashbit ^= BitExtractULL(normaddr, 23, 23);
                    if (GlbHashIntlvCtl1G)
                        hashbit ^= BitExtractULL(normaddr, 32, 32);

                    if (BitExtractULL(normaddr, intlv_lsb, intlv_lsb) != hashbit)
                        normaddr ^= LShiftU64(1, intlv_lsb);

                    mc ^= hashbit;
                    AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - B0(%d,%d)", hashbit, mc);

                    if (intlv_chanbits > 1)
                    {
                        hashbit = (int)BitExtractULL(normaddr, intlv_lsb + 1, intlv_lsb + 1);
                        if (chhash)
                            hashbit ^= (int)BitExtractULL(normaddr, 12, 12);
                        if (GlbHashIntlvCtl64K)
                            hashbit ^= BitExtractULL(normaddr, 16, 16);
                        if (GlbHashIntlvCtl2M)
                            hashbit ^= BitExtractULL(normaddr, 21, 21);
                        if (GlbHashIntlvCtl1G)
                            hashbit ^= BitExtractULL(normaddr, 30, 30);

                        if (BitExtractULL(normaddr, 12, 12) != hashbit)
                            normaddr ^= LShiftU64(1, 12);

                        mc ^= (hashbit << 1);
                        AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - B1(%d,%d)", hashbit, mc);
                    }

                    if (intlv_chanbits > 2)
                    {
                        hashbit = (int)BitExtractULL(normaddr, intlv_lsb + 2, intlv_lsb + 2);
                        if (chhash)
                            hashbit ^= (int)BitExtractULL(normaddr, 13, 13);
                        if (GlbHashIntlvCtl64K)
                            hashbit ^= BitExtractULL(normaddr, 17, 17);
                        if (GlbHashIntlvCtl2M)
                            hashbit ^= BitExtractULL(normaddr, 22, 22);
                        if (GlbHashIntlvCtl1G)
                            hashbit ^= BitExtractULL(normaddr, 31, 31);

                        if (BitExtractULL(normaddr, 13, 13) != hashbit)
                            normaddr ^= LShiftU64(1, 13);

                        mc ^= (hashbit << 2);
                        AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - B2(%d,%d)", hashbit, mc);
                    }
                }

                // check dram hole
                int LgcyMmioHoleEn = BitExtract(ryzdata->DramBaseAddress[nind], 1, 1);

                if (LgcyMmioHoleEn)
                {
                    unsigned long long DramHoleBase = LShiftU64(BitExtractULL(ryzdata->DramHoleControl[umc], 31, 24), 24);
                    unsigned long long DramHoleSize = 0x100000000ULL - DramHoleBase;

                    if (normaddr >= (DramHoleBase + DramHoleSize))
                    {
                        normaddr -= DramHoleSize;
                    }
                }

                // subtract base addr
                normaddr -= mcbase;

                // normalize address
                if (intlv_chanbits != 0)
                {
                    unsigned short cs_id = 0;
                    // remove cs id
                    if (chhash)
                    {
                        int num_intlv_bits = intlv_chanbits;
                        num_intlv_bits += intlv_socketbits;

                        if (num_intlv_bits > 1)
                        {
                            cs_id |= ((unsigned short)BitExtractULL(normaddr, 12 + num_intlv_bits - 2, 12) << 1);
                            normaddr = LShiftU64(BitExtractULL(normaddr, 63, 12 + num_intlv_bits - 1), 12) | BitExtractULL(normaddr, 11, 0);
                        }

                        cs_id |= (unsigned short)BitExtractULL(normaddr, intlv_lsb, intlv_lsb);
                        normaddr = LShiftU64(BitExtractULL(normaddr, 63, intlv_lsb + 1), intlv_lsb) | BitExtractULL(normaddr, intlv_lsb - 1, 0);
                    }
                    else
                    {
                        int num_intlv_bits = intlv_socketbits + intlv_diebits + intlv_chanbits;
                        cs_id = (unsigned short)BitExtractULL(normaddr, intlv_lsb + num_intlv_bits - 1, intlv_lsb);

                        normaddr = LShiftU64(BitExtractULL(normaddr, 63, intlv_lsb + num_intlv_bits), intlv_lsb) | BitExtractULL(normaddr, intlv_lsb - 1, 0);
                    }
                    (void)cs_id;
                }

                // add dramoffset
                int HiAddrOffsetEn = BitExtract(ryzdata->DramOffset[umc], 0, 0);
                if (HiAddrOffsetEn)
                {
                    unsigned long long HiAddrOffset = LShiftU64(BitExtract(ryzdata->DramOffset[umc], 31, 12), 28);
                    if (n == 1)
                    {
                        normaddr += HiAddrOffset;
                    }
                }
                ch = mc;

                // look up cs
                for (int i = 0; i < 4; i++)
                {
                    int csind = mc * 4 + i;
                    int CSEnable = BitExtract(ryzdata->CSBaseAddr[csind], 0, 0);
                    if (CSEnable == 0)
                        continue;

                    unsigned long long CSBase = LShiftU64(BitExtractULL(ryzdata->CSBaseAddr[csind], 31, 1), 9);

                    int sind = mc * ctrl->numsl + i / 2;
                    unsigned long long CSMask = LShiftU64(~BitExtractULL(ryzdata->CSAddrMask[sind], 31, 1), 9);

                    AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - C(%p,%p,%p,%d)", normaddr, normaddr & CSMask, CSBase & CSMask, i);

                    if ((normaddr & CSMask) == (CSBase & CSMask))
                    {
                        int XorEn_n0 = BitExtract(ryzdata->AddrHashCS[mc * 2], 0, 0);
                        unsigned long long NormAddrXor_n0 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2], 31, 1), 9);
                        int XorEn_n1 = BitExtract(ryzdata->AddrHashCS[mc * 2 + 1], 0, 0);
                        unsigned long long NormAddrXor_n1 = LShiftU64(BitExtractULL(ryzdata->AddrHashCS[mc * 2 + 1], 31, 1), 9);

                        if (XorEn_n0 | XorEn_n1)
                        {
                            unsigned long long xorbits_n0 = 0;
                            unsigned long long xorbits_n1 = 0;
                            if (XorEn_n0)
                                xorbits_n0 = normaddr & NormAddrXor_n0;
                            if (XorEn_n1)
                                xorbits_n1 = normaddr & NormAddrXor_n1;

                            int cshash_n0 = 0;
                            int cshash_n1 = 0;
                            for (int bit = 0; bit < 63; bit++)
                            {
                                cshash_n0 ^= (int)(RShiftU64(xorbits_n0, bit) & 1);
                                cshash_n1 ^= (int)(RShiftU64(xorbits_n1, bit) & 1);
                            }
                            cs = i ^ ((cshash_n1 << 1) | cshash_n0);
                        }
                        else
                        {
                            cs = i;
                        }
                        AsciiFPrint(DEBUG_FILE_HANDLE, "zen2_decode_addr - D(%p,%d,%d,%d,%p,%p,%d)", normaddr, mc, cs, i, CSBase, CSMask, XorEn_n0 | XorEn_n1);
                        break;
                    }
                }
                break;
            }
        }
        if (mc >= 0)
            break;
    }

    if (pmc)
        *pmc = mc;
    if (pch)
        *pch = ch;
    if (pcs)
        *pcs = cs;
    if (pnormaddr)
        *pnormaddr = normaddr;
}

static void poll_ryzen_zen2(struct ecc_info *ctrl)
{
    unsigned long eccerrcnt;
    unsigned node = 0;
    unsigned int bus = 0;
    UINT64 mcastatus = 0, mcaaddr = 0, mcasynd = 0;
    UINT64 mcadestat = 0, mcadeaddr = 0;
    UINT64 mcamisc0 = 0;
    UINT64 addr, lsb;
    unsigned long syndrome, syndlen;
    int rank;
    int uncorrected;
    int i;

    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        // DimmEccEn. Read-write. Reset: 0. 0=Disable. 1=Enable. Indicates all populated DIMMs on the channel support ECC check bits
        if (BitExtract(ryzdata->UmcConfig[i], 12, 12) == 0)
            continue;

        int slot;
        int cs;
        for (cs = 0; cs < 4; cs++)
        {
            int rm;

            slot = cs < 2 ? 0 : 1;
            for (rm = 0; rm < 1; rm++)
            {
                unsigned long eccerrcntsel = 0;

                /* DRAM ECC Error Count Select register */
                smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
                if (eccerrcntsel == 0xffffffff)
                    continue;

                smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | (rm << 4) | cs);

                smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
                if (eccerrcnt == 0xffffffff)
                    continue;

                if (eccerrcnt & 0x0000ffff)
                    dimmerrcnt[i * ctrl->numsl + slot] += eccerrcnt & 0x0000ffff;
            }
        }

        // compare with previous dimm error count
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[i * ctrl->numsl + slot] != ctrl->preverrcnt[i * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + i);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[i * ctrl->numsl + slot], ctrl->preverrcnt[i * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);

                if (ctrl->numch > 2 && slot == 0)
                {
                    /* Report the error */
                    MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, channel, -1);
                }
            }
            ctrl->preverrcnt[i * ctrl->numsl + slot] = dimmerrcnt[i * ctrl->numsl + slot];
        }
    }

    for (UINT8 ch = 0; ch < ctrl->numch; ch++)
    {
        int oddch = ch % 2;
        int mcabank = (MSR_ZEN2_MCA_CTL_UMC(oddch) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),
        UINT64 mcastatus_legacy;

        _rdmsr64(MSR_ZEN2_MCA_STATUS_UMC(oddch), &mcastatus);
        _rdmsr64(MSR_ZEN2_MCA_STATUS(mcabank), &mcastatus_legacy);
        _rdmsr64(MSR_ZEN2_MCA_MISC0(mcabank), &mcamisc0);

        if (((mcamisc0 >> 32) & 0xFFF) != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT " (ErrCnt=%d)", mcabank, mcamisc0, (unsigned long)((mcamisc0 >> 32) & 0xFFF));
            MtSupportDebugWriteLine(gBuffer);
        }

        if (mcastatus != mcastatus_legacy)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d] (" I64HEXFMT ") does not match MCA_STATUS[%d] (" I64HEXFMT ")", oddch, mcastatus, mcabank, mcastatus_legacy);
            MtSupportDebugWriteLine(gBuffer);

            mcastatus_legacy = mcastatus;
        }

        if (mcastatus & (1ULL << 63))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT " (Overflow=%d, UC=%d, CECC=%d, UECC=%d, Deferred=%d, Scrub=%d, ErrorCode=%04X)",
                        oddch,
                        mcastatus,
                        (unsigned long)BitExtractULL(mcastatus, 62, 62),
                        (unsigned long)BitExtractULL(mcastatus, 61, 61),
                        (unsigned long)BitExtractULL(mcastatus, 46, 46),
                        (unsigned long)BitExtractULL(mcastatus, 45, 45),
                        (unsigned long)BitExtractULL(mcastatus, 44, 44),
                        (unsigned long)BitExtractULL(mcastatus, 40, 40),
                        (unsigned long)(mcastatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            uncorrected = (int)(RShiftU64(mcastatus, 45) & 1);

            _rdmsr64(MSR_ZEN2_MCA_DESTAT_UMC(oddch), &mcadestat);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DESTAT_UMC[%d]=" I64HEXFMT, oddch, mcadestat);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_ZEN2_MCA_DEADDR_UMC(oddch), &mcadeaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DEADDR_UMC[%d]=" I64HEXFMT, oddch, mcadeaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Read the address */
            _rdmsr64(MSR_ZEN2_MCA_ADDR_UMC(oddch), &mcaaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_ADDR_UMC[%d]=" I64HEXFMT, oddch, mcaaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location */
            lsb = (mcaaddr >> 56) & 0x3F;
            addr = mcaaddr & ((1ULL << 56) - 1);
            addr &= ~(lsb - 1);

            /* Read the syndrome */
            _rdmsr64(MSR_ZEN2_MCA_SYND_UMC(oddch), &mcasynd);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_SYND_UMC[%d]=" I64HEXFMT " (Chip Select=%d, Rank multiply=%d, Symbol=%d)", oddch, mcasynd, (unsigned long)(mcasynd & 0x7), (unsigned long)(mcasynd >> 4) & 0x7, (unsigned long)(RShiftU64(mcasynd, 8) & 0x3f));
            MtSupportDebugWriteLine(gBuffer);

            syndlen = (mcasynd >> 18) & 0x3F;
            syndrome = (mcasynd >> 32) & 0xFFFF;
            syndrome &= (unsigned long)(LShiftU64(1, syndlen) - 1);
            rank = mcasynd & 0x7;

            if (ctrl->numch <= 2) // MCA register does not exist for channels 2-7
            {
                /* Report the error */
                MtSupportReportECCError((UINTN)addr, uncorrected == 0, syndrome, -1, ch, rank < 2 ? 0 : 1);
            }

            /* Clear the error registers */
            _wrmsr64(MSR_ZEN2_MCA_STATUS_UMC(oddch), 0);
            _wrmsr64(MSR_ZEN2_MCA_STATUS(mcabank), 0);
        }
    }
}

static void poll_timings_ryzen(struct ecc_info *ctrl)
{
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    unsigned node = ctrl->dev - 0x18;
    unsigned int bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        unsigned long val = 0;
        smn_read(bus, UMC_DRAMCONFIG(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen - [MC%d] DramConfiguration=%08x", mc, val);

        if (val == 0xffffffff)
            continue;

        unsigned long memclk = (BitExtract(val, 6, 0) * 100 + 2) / 3;

        if (memclk == 0)
            continue;

        smn_read(bus, UMC_DEBUGMISC(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen - [MC%d] DebugMisc=%08x", mc, val);

        if (val != 0xffffffff)
            ctrl->ctrlclk = BitExtract(val, 3, 3) ? memclk : memclk >> 1;

        unsigned char tCL = 0, tRCD = 0, tRAS = 0, tRP = 0, tRC = 0;

        for (int n = 1; n <= 2; n++)
        {
            smn_read(bus, UMC_DRAMTIMING(mc, n), &val);
            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen - [MC%d] UMC_DRAMTIMING%d=%08x", mc, n, val);

            if (val == 0xffffffff)
                continue;

            if (n == 1)
            {
                tCL = BitExtract(val, 5, 0);
                tRCD = BitExtract(val, 21, 16);
                tRAS = BitExtract(val, 14, 8);
            }
            else if (n == 2)
            {
                tRP = BitExtract(val, 21, 16);
                tRC = BitExtract(val, 7, 0);
            }
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen - [MC%d] %d-%d-%d-%d", mc, tCL, tRCD, tRP, tRAS);

        if (tCL < 0x08 ||
            tRP < 0x08 ||
            tRCD < 0x08 ||
            tRAS < 0x15)
            continue;

        ctrl->memclk = memclk;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
        ctrl->tRC = tRC;
    }
}

DISABLE_OPTIMISATIONS()
static unsigned long long ryzen_memclk_freq(unsigned int bus, unsigned int mc)
{
    unsigned long val = 0;

    // Program global MEMCLK counter UMC::PerfMonCtlClk = 0x83000000
    smn_read(bus, UMC_PERFMONCTLCLK(mc), &val);

    if (val != 0xffffffff && val != 0x83000000)
        smn_write(bus, UMC_PERFMONCTLCLK(mc), 0x83000000);

    unsigned long long start = MtSupportReadTSC();

    unsigned long long PerfMonCtrClkStart = 0;
    smn_read(bus, UMC_PERFMONCTRCLKLO(mc), &val);
    PerfMonCtrClkStart = val;

    smn_read(bus, UMC_PERFMONCTRCLKHI(mc), &val);
    PerfMonCtrClkStart |= LShiftU64(val & 0xffff, 32);

    Sleep(200);

    unsigned long long PerfMonCtrClkEnd = 0;
    smn_read(bus, UMC_PERFMONCTRCLKLO(mc), &val);
    PerfMonCtrClkEnd = val;

    smn_read(bus, UMC_PERFMONCTRCLKHI(mc), &val);
    PerfMonCtrClkEnd |= LShiftU64(val & 0xffff, 32);

    unsigned long long elapsed_ms = clks_msec != 0 ? DivU64x32(MtSupportReadTSC() - start, (UINT32)clks_msec) : 0;
    unsigned long long memclk_khz = elapsed_ms != 0 ? DivU64x32(PerfMonCtrClkEnd - PerfMonCtrClkStart, (UINT32)elapsed_ms) : 0;
    return memclk_khz;
}
ENABLE_OPTIMISATIONS()

static void poll_timings_ryzen_zen4(struct ecc_info *ctrl)
{
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    unsigned node = ctrl->dev - 0x18;
    unsigned int bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    hsmp_arg arg;
    SetMem(&arg, sizeof(arg), 0);
    if (hsmp_request(bus, HSMP_GET_FCLK_MCLK, &arg) == 0)
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - fclk=%d Mhz memclk=%d Mhz (response: %d)", arg.argument[0], arg.argument[1], arg.response);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - HSMP_GET_FCLK_MCLK timed out");

    if (ctrl->mchbar != 0)
    {
        unsigned long gppclkcntrol = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + RYZEN_MMIO_MISC_GPPCLKCNTRL));

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - gppclkcntrol=%08x", gppclkcntrol);

        unsigned long cgpllcntrl3 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + RYZEN_MMIO_MISC_CGPLLCNTRLREG(3)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - cgpllcntrl3=%08x", cgpllcntrl3);
    }

    INT64 memclk_cntr_khz = -1;
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        unsigned long val = 0;
        smn_read(bus, UMC_DRAMCONFIG(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - [MC%d] DramConfiguration=%08x", mc, val);

        if (val == 0xffffffff)
            continue;

        unsigned long memclk = BitExtract(val, 15, 0);

        if (memclk == 0)
            continue;

        if (memclk_cntr_khz < 0)
            memclk_cntr_khz = ryzen_memclk_freq(bus, mc);

        INT64 memclk_khz = memclk * 1000;
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - [MC%d] MemClkFreq=%d memclk cntr freq=%ld Khz", mc, memclk, memclk_cntr_khz);

        // abs(memclk_cntr_khz - memclk_khz) / memclk_khz < 0.1
        if (MultS64x64(ABS(memclk_cntr_khz - memclk_khz), 100) < (10 * memclk))
            memclk = (unsigned long)DivS64x64Remainder(memclk_cntr_khz, 1000, NULL);

        smn_read(bus, UMC_DEBUGMISC(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - [MC%d] DebugMisc=%08x", mc, val);

        if (val != 0xffffffff)
            ctrl->ctrlclk = BitExtract(val, 3, 3) ? memclk : memclk >> 1;

        unsigned char tCL = 0, tRCD = 0, tRAS = 0, tRP = 0, tRC = 0;

        for (int n = 1; n <= 2; n++)
        {
            smn_read(bus, UMC_DRAMTIMING(mc, n), &val);
            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen4 - [MC%d] UMC_DRAMTIMING%d=%08x", mc, n, val);

            if (val == 0xffffffff)
                continue;

            if (n == 1)
            {
                tCL = BitExtract(val, 5, 0);
                tRCD = BitExtract(val, 21, 16);
                tRAS = BitExtract(val, 14, 8);
            }
            else if (n == 2)
            {
                tRP = BitExtract(val, 21, 16);
                tRC = BitExtract(val, 7, 0);
            }
        }

        if (tCL < 0x08 ||
            tRP < 0x08 ||
            tRCD < 0x08 ||
            tRAS < 0x15)
            continue;

        ctrl->memclk = memclk;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
        ctrl->tRC = tRC;
    }
}

static void poll_timings_ryzen_zen5(struct ecc_info *ctrl)
{
    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    unsigned node = ctrl->dev - 0x18;
    unsigned int bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

#if 0 // Causes issues when program exits
    hsmp_arg arg;
    SetMem(&arg, sizeof(arg), 0);
    if (hsmp_request(bus, HSMP_GET_FCLK_MCLK, &arg) == 0)
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - fclk=%d Mhz memclk=%d Mhz (response: %d)", arg.argument[0], arg.argument[1], arg.response);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - HSMP_GET_FCLK_MCLK timed out");
#endif

    INT64 memclk_cntr_khz = -1;
    for (UINT8 mc = 0; mc < ctrl->numch; mc++)
    {
        unsigned long val = 0;
        smn_read(bus, UMC_DRAMCONFIG(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - [MC%d] DramConfiguration=%08x", mc, val);

        if (val == 0xffffffff)
            continue;

        unsigned long memclk = BitExtract(val, 15, 0);

        if (memclk == 0)
            continue;

        if (memclk_cntr_khz < 0)
            memclk_cntr_khz = ryzen_memclk_freq(bus, mc);

        INT64 memclk_khz = memclk * 1000;
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - [MC%d] MemClkFreq=%d memclk cntr freq=%ld Khz", mc, memclk, memclk_cntr_khz);

        // abs(memclk_cntr_khz - memclk_khz) / memclk_khz < 0.1
        if (MultS64x64(ABS(memclk_cntr_khz - memclk_khz), 100) < (10 * memclk))
            memclk = (unsigned long)DivS64x64Remainder(memclk_cntr_khz, 1000, NULL);

        smn_read(bus, UMC_DEBUGMISC(mc), &val);
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - [MC%d] DebugMisc=%08x", mc, val);

        if (val != 0xffffffff)
            ctrl->ctrlclk = BitExtract(val, 3, 3) ? memclk : memclk >> 1;

        unsigned char tCL = 0, tRCD = 0, tRAS = 0, tRP = 0, tRC = 0;

        for (int n = 1; n <= 2; n++)
        {
            smn_read(bus, UMC_DRAMTIMING(mc, n), &val);
            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_ryzen_zen5 - [MC%d] UMC_DRAMTIMING%d=%08x", mc, n, val);

            if (val == 0xffffffff)
                continue;

            if (n == 1)
            {
                tCL = BitExtract(val, 5, 0);
                tRCD = BitExtract(val, 21, 16);
                tRAS = BitExtract(val, 14, 8);
            }
            else if (n == 2)
            {
                tRP = BitExtract(val, 21, 16);
                tRC = BitExtract(val, 7, 0);
            }
        }

        if (tCL < 0x08 ||
            tRP < 0x08 ||
            tRCD < 0x08 ||
            tRAS < 0x15)
            continue;

        ctrl->memclk = memclk;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
        ctrl->tRC = tRC;
    }
}

int decode_ryzen_zen2(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int mc = -1, ch = -1, cs = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long normaddr = 0;
    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0, i = 0;

    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;

    zen2_decode_addr(ctrl, addr, &mc, &ch, &cs, &normaddr);
    if (mc < 0 || ch < 0 || cs < 0)
        return -1;

    dimm = cs / ctrl->numsl;
    rank = cs % ctrl->numsl;

    if (ctrl->chipwidth[ch * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[ch * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (esize == 4)
    { // 32 bit error

        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                if (rank == 0)
                    chip = unaligned8 * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    else // 64 bit error
    {
        unsigned long lo = ebits & 0xffffffff;
        unsigned long hi = ebits >> 32;

        for (i = 0; i < numwords; i++)
        {
            if (((lo >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = i;
                else
                    chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                chiperrs++;
            }

            if (((hi >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = numwords + i;
                else
                    chip = rank * numwords * 2 + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_ryzen_zen2 - (%p,%p,%08x,%d,%d,%d,%d,%d)", addr, normaddr, ebits32, mc, ch, dimm, rank, chip);

    if (pch)
        *pch = mc;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    return 0;
}

static void poll_ryzen_zen4_61h(struct ecc_info *ctrl)
{
    unsigned long eccerrcnt;
    unsigned node = 0;
    unsigned int bus = 0;
    UINT64 mcastatus = 0, mcaaddr = 0, mcasynd = 0;
    UINT64 mcadestat = 0, mcadeaddr = 0;
    UINT64 mcamisc0 = 0;
    UINT64 addr, lsb;
    unsigned long syndrome, syndlen;
    int rank;
    int uncorrected;
    int i;

    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        // DimmEccEn. Read-write. Reset: 0. 0=Disable. 1=Enable. Indicates all populated DIMMs on the channel support ECC check bits
        if (BitExtract(ryzdata->UmcConfig[i], 12, 12) == 0)
            continue;

        int slot;
        int cs;
        for (cs = 0; cs < 4; cs++)
        {
            unsigned long eccerrcntsel = 0;

            slot = cs < 2 ? 0 : 1;
            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | cs);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
                dimmerrcnt[i * ctrl->numsl + slot] += eccerrcnt & 0x0000ffff;
        }

        // compare with previous dimm error count
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[i * ctrl->numsl + slot] != ctrl->preverrcnt[i * ctrl->numsl + slot])
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", ctrl->ctrlno * ctrl->numch + i, slot, dimmerrcnt[i * ctrl->numsl + slot], ctrl->preverrcnt[i * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
#if 0
                if (ctrl->numch > 2 && slot == 0)
                {
                    /* Report the error */
                    MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, ctrl->ctrlno * ctrl->numch + i, -1);
                }
#endif
            }
            ctrl->preverrcnt[i * ctrl->numsl + slot] = dimmerrcnt[i * ctrl->numsl + slot];
        }
    }

    for (UINT8 ch = 0; ch < ctrl->numch; ch++)
    {
        int oddch = ch % 2;
        int mcabank = (MSR_ZEN2_MCA_CTL_UMC(oddch) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),
        UINT64 mcastatus_legacy;

        _rdmsr64(MSR_ZEN4_61H_MCA_STATUS_UMC(oddch), &mcastatus);
        _rdmsr64(MSR_ZEN4_MCA_STATUS(mcabank), &mcastatus_legacy);
        _rdmsr64(MSR_ZEN4_MCA_MISC0(mcabank), &mcamisc0);

        if (((mcamisc0 >> 32) & 0xFFF) != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT " (ErrCnt=%d)", mcabank, mcamisc0, (unsigned long)((mcamisc0 >> 32) & 0xFFF));
            MtSupportDebugWriteLine(gBuffer);
        }

        if (mcastatus != mcastatus_legacy)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d] (" I64HEXFMT ") does not match MCA_STATUS[%d] (" I64HEXFMT ")", ch, mcastatus, mcabank, mcastatus_legacy);
            MtSupportDebugWriteLine(gBuffer);

            mcastatus_legacy = mcastatus;
        }

        if (mcastatus & (1ULL << 63))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT " (Overflow=%d, UC=%d, CECC=%d, UECC=%d, Deferred=%d, Scrub=%d, ErrorCode=%04X)",
                        ch,
                        mcastatus,
                        (unsigned long)BitExtractULL(mcastatus, 62, 62),
                        (unsigned long)BitExtractULL(mcastatus, 61, 61),
                        (unsigned long)BitExtractULL(mcastatus, 46, 46),
                        (unsigned long)BitExtractULL(mcastatus, 45, 45),
                        (unsigned long)BitExtractULL(mcastatus, 44, 44),
                        (unsigned long)BitExtractULL(mcastatus, 40, 40),
                        (unsigned long)(mcastatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            uncorrected = (int)(RShiftU64(mcastatus, 45) & 1);

            _rdmsr64(MSR_ZEN4_61H_MCA_DESTAT_UMC(oddch), &mcadestat);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DESTAT_UMC[%d]=" I64HEXFMT, ch, mcadestat);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_ZEN4_61H_MCA_DEADDR_UMC(oddch), &mcadeaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DEADDR_UMC[%d]=" I64HEXFMT, ch, mcadeaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Read the address */
            _rdmsr64(MSR_ZEN4_61H_MCA_ADDR_UMC(oddch), &mcaaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_ADDR_UMC[%d]=" I64HEXFMT, ch, mcaaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location */
            lsb = (mcaaddr >> 56) & 0x3F;
            addr = mcaaddr & ((1ULL << 56) - 1);
            addr &= ~(lsb - 1);

            /* Read the syndrome */
            _rdmsr64(MSR_ZEN4_61H_MCA_SYND_UMC(oddch), &mcasynd);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_SYND_UMC[%d]=" I64HEXFMT " (Chip Select=%d, Rank multiply=%d, Symbol=%d)", ch, mcasynd, (unsigned long)(mcasynd & 0x7), (unsigned long)(mcasynd >> 4) & 0x7, (unsigned long)(RShiftU64(mcasynd, 8) & 0x3f));
            MtSupportDebugWriteLine(gBuffer);

            syndlen = (mcasynd >> 18) & 0x3F;
            syndrome = (mcasynd >> 32) & 0xFFFF;
            syndrome &= (unsigned long)(LShiftU64(1, syndlen) - 1);
            rank = mcasynd & 0x7;

            /* Report the error */
            MtSupportReportECCError((UINTN)addr, uncorrected == 0, syndrome, -1, ch, rank < 2 ? 0 : 1);

            /* Clear the error registers */
            _wrmsr64(MSR_ZEN4_61H_MCA_STATUS_UMC(oddch), 0);
            _wrmsr64(MSR_ZEN4_MCA_STATUS(mcabank), 0);
        }
    }
}

static void poll_ryzen_zen4_78h(struct ecc_info *ctrl)
{
    unsigned long eccerrcnt;
    unsigned node = 0;
    unsigned int bus = 0;
    UINT64 mcastatus = 0, mcaaddr = 0, mcasynd = 0;
    UINT64 mcadestat = 0, mcadeaddr = 0;
    UINT64 mcamisc0 = 0;
    UINT64 addr, lsb;
    unsigned long syndrome, syndlen;
    int rank;
    int uncorrected;
    int i;

    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        // DimmEccEn. Read-write. Reset: 0. 0=Disable. 1=Enable. Indicates all populated DIMMs on the channel support ECC check bits
        if (BitExtract(ryzdata->UmcConfig[i], 12, 12) == 0)
            continue;

        int slot;
        int cs;
        for (cs = 0; cs < 4; cs++)
        {
            unsigned long eccerrcntsel = 0;

            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | cs);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
                dimmerrcnt[i] += eccerrcnt & 0x0000ffff;
        }

        // compare with previous dimm error count
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[i * ctrl->numsl + slot] != ctrl->preverrcnt[i * ctrl->numsl + slot])
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", ctrl->ctrlno * ctrl->numch + i, slot, dimmerrcnt[i * ctrl->numsl + slot], ctrl->preverrcnt[i * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
#if 0
                if (ctrl->numch > 2 && slot == 0)
                {
                    /* Report the error */
                    MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, ctrl->ctrlno * ctrl->numch + i, -1);
                }
#endif
            }
            ctrl->preverrcnt[i * ctrl->numsl + slot] = dimmerrcnt[i * ctrl->numsl + slot];
        }
    }

    for (UINT8 ch = 0; ch < ctrl->numch; ch++)
    {
        int mcabank = (MSR_ZEN4_78H_MCA_CTL_UMC(ch) >> 4) & 0xFF; // All processors maintain the same mapping of MSR number to MCA bank number (MSRC000_2000 for the beginning of MCA Bank 0, MSRC000_2010 for the beginning of MCA Bank 1, etc.),
        UINT64 mcastatus_legacy;

        _rdmsr64(MSR_ZEN4_78H_MCA_STATUS_UMC(ch), &mcastatus);
        _rdmsr64(MSR_ZEN4_MCA_STATUS(mcabank), &mcastatus_legacy);
        _rdmsr64(MSR_ZEN4_MCA_MISC0(mcabank), &mcamisc0);

        if (((mcamisc0 >> 32) & 0xFFF) != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0[%d]=" I64HEXFMT " (ErrCnt=%d)", mcabank, mcamisc0, (unsigned long)((mcamisc0 >> 32) & 0xFFF));
            MtSupportDebugWriteLine(gBuffer);
        }

        if (mcastatus != mcastatus_legacy)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d] (" I64HEXFMT ") does not match MCA_STATUS[%d] (" I64HEXFMT ")", ch, mcastatus, mcabank, mcastatus_legacy);
            MtSupportDebugWriteLine(gBuffer);

            mcastatus_legacy = mcastatus;
        }

        if (mcastatus & (1ULL << 63))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT " (Overflow=%d, UC=%d, CECC=%d, UECC=%d, Deferred=%d, Scrub=%d, ErrorCode=%04X)",
                        ch,
                        mcastatus,
                        (unsigned long)BitExtractULL(mcastatus, 62, 62),
                        (unsigned long)BitExtractULL(mcastatus, 61, 61),
                        (unsigned long)BitExtractULL(mcastatus, 46, 46),
                        (unsigned long)BitExtractULL(mcastatus, 45, 45),
                        (unsigned long)BitExtractULL(mcastatus, 44, 44),
                        (unsigned long)BitExtractULL(mcastatus, 40, 40),
                        (unsigned long)(mcastatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            uncorrected = (int)(RShiftU64(mcastatus, 45) & 1);

            _rdmsr64(MSR_ZEN4_78H_MCA_DESTAT_UMC(ch), &mcadestat);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DESTAT_UMC[%d]=" I64HEXFMT, ch, mcadestat);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_ZEN4_78H_MCA_DEADDR_UMC(ch), &mcadeaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DEADDR_UMC[%d]=" I64HEXFMT, ch, mcadeaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Read the address */
            _rdmsr64(MSR_ZEN4_78H_MCA_ADDR_UMC(ch), &mcaaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_ADDR_UMC[%d]=" I64HEXFMT, ch, mcaaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location */
            lsb = BitExtractULL(mcastatus, 29, 24);
            addr = BitExtractULL(mcaaddr, 55, 0);
            addr &= ~(lsb - 1);

            /* Read the syndrome */
            _rdmsr64(MSR_ZEN4_78H_MCA_SYND_UMC(ch), &mcasynd);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_SYND_UMC[%d]=" I64HEXFMT " (Chip Select=%d, Rank multiply=%d, Symbol=%d)", ch, mcasynd, (unsigned long)(mcasynd & 0x7), (unsigned long)(mcasynd >> 4) & 0x7, (unsigned long)(RShiftU64(mcasynd, 8) & 0x3f));
            MtSupportDebugWriteLine(gBuffer);

            syndlen = (mcasynd >> 18) & 0x3F;
            syndrome = (mcasynd >> 32) & 0xFFFF;
            syndrome &= (unsigned long)(LShiftU64(1, syndlen) - 1);
            rank = mcasynd & 0x7;

            /* Report the error */
            MtSupportReportECCError((UINTN)addr, uncorrected == 0, syndrome, ch, -1, rank < 2 ? 0 : 1);

            /* Clear the error registers */
            _wrmsr64(MSR_ZEN4_78H_MCA_STATUS_UMC(ch), 0);
            _wrmsr64(MSR_ZEN4_MCA_STATUS(mcabank), 0);
        }
    }
}

static void poll_ryzen_zen5(struct ecc_info *ctrl)
{
    unsigned long eccerrcnt;
    unsigned node = 0;
    unsigned int bus = 0;
    UINT64 mcastatus = 0, mcaaddr = 0, mcasynd = 0;
    UINT64 mcadestat = 0, mcadeaddr = 0;
    UINT64 mcamisc0 = 0;
    UINT64 addr, lsb;
    unsigned long syndrome, syndlen;
    int rank;
    int uncorrected;
    int i;
    unsigned int model = CPUID_MODEL(&cpu_id);

    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];
    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        // DimmEccEn. Read-write. Reset: 0. 0=Disable. 1=Enable. Indicates all populated DIMMs on the channel support ECC check bits
        if (BitExtract(ryzdata->UmcConfig[i], 12, 12) == 0)
            continue;

        int slot;
        int cs;
        for (cs = 0; cs < 2; cs++)
        {
            unsigned long eccerrcntsel = 0;

            /* DRAM ECC Error Count Select register */
            smn_read(bus, UMC_ECCERRCNTSEL(i), &eccerrcntsel);
            if (eccerrcntsel == 0xffffffff)
                continue;

            smn_write(bus, UMC_ECCERRCNTSEL(i), eccerrcntsel | cs);

            smn_read(bus, UMC_ECCERRCNT(i), &eccerrcnt);
            if (eccerrcnt == 0xffffffff)
                continue;

            if (eccerrcnt & 0x0000ffff)
                dimmerrcnt[i] += eccerrcnt & 0x0000ffff;
        }

        // compare with previous dimm error count
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[i * ctrl->numsl + slot] != ctrl->preverrcnt[i * ctrl->numsl + slot])
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", ctrl->ctrlno * ctrl->numch + i, slot, dimmerrcnt[i * ctrl->numsl + slot], ctrl->preverrcnt[i * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
#if 0
                if (ctrl->numch > 2 && slot == 0)
                {
                    /* Report the error */
                    MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, ctrl->ctrlno * ctrl->numch + i, -1);
                }
#endif
            }
            ctrl->preverrcnt[i * ctrl->numsl + slot] = dimmerrcnt[i * ctrl->numsl + slot];
        }
    }

    for (UINT8 ch = 0; ch < ctrl->numch; ch++)
    {
        _rdmsr64(MSR_ZEN5_MCA_STATUS_UMC(model, ch), &mcastatus);
        _rdmsr64(MSR_ZEN5_MCA_MISC0_UMC(model, ch), &mcamisc0);

        if (((mcamisc0 >> 32) & 0xFFF) != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_MISC0_UMC[%d]=" I64HEXFMT " (ErrCnt=%d)", ch, mcamisc0, (unsigned long)((mcamisc0 >> 32) & 0xFFF));
            MtSupportDebugWriteLine(gBuffer);
        }

        if (BitExtractULL(mcastatus, 63, 63))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_STATUS_UMC[%d]=" I64HEXFMT " (Overflow=%d, UC=%d, CECC=%d, UECC=%d, Deferred=%d, Scrub=%d, ErrorCode=%04X)",
                        ch,
                        mcastatus,
                        (unsigned long)BitExtractULL(mcastatus, 62, 62),
                        (unsigned long)BitExtractULL(mcastatus, 61, 61),
                        (unsigned long)BitExtractULL(mcastatus, 46, 46),
                        (unsigned long)BitExtractULL(mcastatus, 45, 45),
                        (unsigned long)BitExtractULL(mcastatus, 44, 44),
                        (unsigned long)BitExtractULL(mcastatus, 40, 40),
                        (unsigned long)(mcastatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            uncorrected = (int)BitExtractULL(mcastatus, 45, 45);

            _rdmsr64(MSR_ZEN5_MCA_DESTAT_UMC(model, ch), &mcadestat);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DESTAT_UMC[%d]=" I64HEXFMT, ch, mcadestat);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_ZEN5_MCA_DEADDR_UMC(model, ch), &mcadeaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_DEADDR_UMC[%d]=" I64HEXFMT, ch, mcadeaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Read the address */
            _rdmsr64(MSR_ZEN5_MCA_ADDR_UMC(model, ch), &mcaaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_ADDR_UMC[%d]=" I64HEXFMT, ch, mcaaddr);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location */
            lsb = BitExtractULL(mcastatus, 29, 24);
            addr &= ~(lsb - 1);

            /* Read the syndrome */
            _rdmsr64(MSR_ZEN5_MCA_SYND_UMC(model, ch), &mcasynd);

            AsciiSPrint(gBuffer, BUF_SIZE, "MCA_SYND_UMC[%d]=" I64HEXFMT " (Chip Select=%d, Rank multiply=%d, Symbol=%d)", ch, mcasynd, (unsigned long)(mcasynd & 0x7), (unsigned long)(mcasynd >> 4) & 0x7, (unsigned long)(RShiftU64(mcasynd, 8) & 0x3f));
            MtSupportDebugWriteLine(gBuffer);

            syndlen = (unsigned long)BitExtractULL(mcasynd, 23, 18);
            syndrome = (unsigned long)BitExtractULL(mcasynd, 63, 32);
            syndrome &= (unsigned long)(LShiftU64(1, syndlen) - 1);
            rank = mcasynd & 0x7;

            /* Report the error */
            MtSupportReportECCError((UINTN)addr, uncorrected == 0, syndrome, ch, -1, rank < 2 ? 0 : 1);

            /* Clear the error registers */
            _wrmsr64(MSR_ZEN5_MCA_STATUS_UMC(model, ch), 0);
        }
    }
}

int decode_ryzen_zen4_61h(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int mc = -1, ch = -1, cs = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long normaddr = 0;
    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0, i = 0;

    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    zen4_decode_addr(ctrl, addr, &mc, &ch, &cs, &normaddr);

    if (mc < 0 || cs < 0)
        return -1;

    dimm = cs / ctrl->numsl;
    rank = cs % ctrl->numsl;

    if (ctrl->chipwidth[mc * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[mc * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (ch >= 0)
    {
        unsigned char DdrType = BitExtract(ryzdata->UmcConfig[mc], 2, 0);
        if (DdrType == ZEN4_UMCCONFIG_DDRTYPE_DDR5 || DdrType == ZEN4_UMCCONFIG_DDRTYPE_LPDDR5)
        {
            for (i = 0; i < numwords; i++)
            {
                if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (rank == 0)
                        chip = ch * numwords + i;
                    else
                        chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);

                    chiperrs++;
                }
            }
        }
        else // DDR4
        {
            if (esize == 4)
            { // 32 bit error

                for (i = 0; i < numwords; i++)
                {
                    if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                    {
                        int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                        if (rank == 0)
                            chip = unaligned8 * numwords + i;
                        else
                            chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                        chiperrs++;
                    }
                }
            }
            else // 64 bit error
            {
                unsigned long lo = ebits & 0xffffffff;
                unsigned long hi = ebits >> 32;

                for (i = 0; i < numwords; i++)
                {
                    if (((lo >> (i * chipwidth)) & wordmask) != 0)
                    {
                        if (rank == 0)
                            chip = i;
                        else
                            chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                        chiperrs++;
                    }

                    if (((hi >> (i * chipwidth)) & wordmask) != 0)
                    {
                        if (rank == 0)
                            chip = numwords + i;
                        else
                            chip = rank * numwords * 2 + (numwords - i - 1);

                        chiperrs++;
                    }
                }
            }
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_ryzen_zen4_61h - (%p,%p,%08x,%d,%d,%d,%d,%d)", addr, normaddr, ebits32, mc, ch, dimm, rank, chip);

    if (pch)
        *pch = mc;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    return 0;
}

int decode_ryzen_zen4_78h(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int umc = -1, mc = -1, ch = -1, cs = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long normaddr = 0;
    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0, i = 0;

    int chipwidth = 8;
    int numranks = 1;
    int numwords;
    unsigned long wordmask;

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    zen4_decode_addr(ctrl, addr, &umc, &ch, &cs, &normaddr);

    if (umc < 0 || cs < 0)
        return -1;

    mc = umc / 2;
    dimm = 0;
    rank = cs % 2;

    if (ctrl->numranks[umc * 2 + dimm] > 0)
        numranks = ctrl->numranks[umc * 2 + dimm];
    if (ctrl->chipwidth[umc * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[umc * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (ch >= 0)
    {
        unsigned char DdrType = BitExtract(ryzdata->UmcConfig[umc], 2, 0);
        if (DdrType == ZEN4_UMCCONFIG_DDRTYPE_DDR5 || DdrType == ZEN4_UMCCONFIG_DDRTYPE_LPDDR5)
        {
            for (i = 0; i < numwords; i++)
            {
                if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (numranks == 2) // dual rank
                    {
                        if (mc == 0)
                        {
                            if (ch == 0)
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + i;
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);
                                }
                            }
                            else
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + (numwords - i - 1);
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + i;
                                }
                            }
                        }
                        else
                        {
                            if (ch == 0)
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + (numwords - i - 1);
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + i;
                                }
                            }
                            else
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + i;
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);
                                }
                            }
                        }
                    }
                    else // single rank
                    {
                        if (mc == 0)
                        {
                            if (ch == 0)
                                chip = 2 * i;
                            else
                                chip = 2 * (numwords - i - 1) + 1;
                        }
                        else
                        {
                            if (ch == 0)
                                chip = 2 * (numwords - i - 1);
                            else
                                chip = 2 * i + 1;
                        }
                    }
                    chiperrs++;
                }
            }
        }
        else // DDR4
        {
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_ryzen_zen4_78h - (%p,%p,%08x,%d,%d,%d,%d,%d,%d)", addr, normaddr, ebits32, umc, mc, ch, dimm, rank, chip);

    if (pch)
        *pch = mc;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    return 0;
}

int decode_ryzen_zen5(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int umc = -1, mc = -1, ch = -1, cs = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long normaddr = 0;
    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0, i = 0;

    int chipwidth = 8;
    int numranks = 1;
    int numwords;
    unsigned long wordmask;

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    zen5_decode_addr(ctrl, addr, &umc, &ch, &cs, &normaddr);

    if (umc < 0 || cs < 0)
        return -1;

    mc = umc / 2;
    dimm = 0;
    rank = cs % 2;

    if (ctrl->numranks[umc * 2 + dimm] > 0)
        numranks = ctrl->numranks[umc * 2 + dimm];
    if (ctrl->chipwidth[umc * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[umc * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (ch >= 0)
    {
        unsigned char DdrType = BitExtract(ryzdata->UmcConfig[umc], 2, 0);
        if (DdrType == ZEN5_UMCCONFIG_DDRTYPE_DDR5 || DdrType == ZEN5_UMCCONFIG_DDRTYPE_LPDDR5)
        {
            for (i = 0; i < numwords; i++)
            {
                if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (numranks == 2) // dual rank
                    {
                        if (mc == 0)
                        {
                            if (ch == 0)
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + i;
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);
                                }
                            }
                            else
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + (numwords - i - 1);
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + i;
                                }
                            }
                        }
                        else
                        {
                            if (ch == 0)
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + (numwords - i - 1);
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + i;
                                }
                            }
                            else
                            {
                                if (rank == 0)
                                {
                                    chip = rank * numwords * 2 + ch * numwords + i;
                                }
                                else
                                {
                                    chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);
                                }
                            }
                        }
                    }
                    else // single rank
                    {
                        if (mc == 0)
                        {
                            if (ch == 0)
                                chip = 2 * i;
                            else
                                chip = 2 * (numwords - i - 1) + 1;
                        }
                        else
                        {
                            if (ch == 0)
                                chip = 2 * (numwords - i - 1);
                            else
                                chip = 2 * i + 1;
                        }
                    }
                    chiperrs++;
                }
            }
        }
        else // DDR4
        {
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_ryzen_zen5 - (%p,%p,%08x,%d,%d,%d,%d,%d,%d)", addr, normaddr, ebits32, umc, mc, ch, dimm, rank, chip);

    if (pch)
        *pch = mc;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    return 0;
}

#define RYZEN_DRAM_SCRUB_BASE_ADDR 0x40
#define RYZEN_REDIR_SCRUB_CTRL 0xB8

BOOLEAN inject_ryzen(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;
    unsigned node = 0;
    unsigned int bus = 0;
    unsigned long misccfg = 0, eccerrinj = 0, eccerrinjctrl = 0;
    unsigned long dramscrub = 0, redirscrub = 0;
    int i;
    BOOLEAN ret = TRUE;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    if (enable)
    {
        /* Check if DRAM periodic scrub is enabled */
        pci_conf_read(0, 24, 6, RYZEN_DRAM_SCRUB_BASE_ADDR, 4, &dramscrub);
        ryzdata->prev_dramscrub = dramscrub;
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - DramScrubBaseAddr=%08x (DramScrubEn=%d)", dramscrub, dramscrub & 1);
        MtSupportDebugWriteLine(gBuffer);
        if (dramscrub & 1)
        {
            unsigned long newdramscrub = dramscrub & ~1;
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Writing 0x%08x to DramScrubBaseAddr", newdramscrub);
            MtSupportDebugWriteLine(gBuffer);

            pci_conf_write(0, 24, 6, RYZEN_DRAM_SCRUB_BASE_ADDR, 4, newdramscrub);
        }

        /* Check if DRAM redirect scrub is enabled */
        pci_conf_read(0, 24, 6, RYZEN_REDIR_SCRUB_CTRL, 4, &redirscrub);
        ryzdata->prev_redirscrub = redirscrub;
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - RedirScrubCtrl=%08x (RedirScrubMode=%d)", redirscrub, redirscrub & 3);
        MtSupportDebugWriteLine(gBuffer);
        if (redirscrub != 0)
        {
            unsigned long newredirscrub = redirscrub & ~3;
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Writing 0x%08x to RedirScrubCtrl", newredirscrub);
            MtSupportDebugWriteLine(gBuffer);

            pci_conf_write(0, 24, 6, RYZEN_REDIR_SCRUB_CTRL, 4, newredirscrub);
        }
    }
    else
    {
        pci_conf_read(0, 24, 6, RYZEN_DRAM_SCRUB_BASE_ADDR, 4, &dramscrub);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - DramScrubBaseAddr=%08x (DramScrubEn=%d)", dramscrub, dramscrub & 1);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Previous DramScrubBaseAddr=%08x", ryzdata->prev_dramscrub);
        MtSupportDebugWriteLine(gBuffer);

        /* Re-enable DRAM periodic scrub */
        if (dramscrub != ryzdata->prev_dramscrub)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Restoring 0x%08x to DramScrubBaseAddr", ryzdata->prev_dramscrub);
            MtSupportDebugWriteLine(gBuffer);

            pci_conf_write(0, 24, 6, RYZEN_DRAM_SCRUB_BASE_ADDR, 4, ryzdata->prev_dramscrub);
        }

        pci_conf_read(0, 24, 6, RYZEN_REDIR_SCRUB_CTRL, 4, &redirscrub);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - RedirScrubCtrl=%08x (RedirScrubMode=%d)", redirscrub, redirscrub & 3);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Previous RedirScrubCtrl=%08x", ryzdata->prev_redirscrub);
        MtSupportDebugWriteLine(gBuffer);

        /* Re-enable DRAM redirect scrub */
        if (redirscrub != ryzdata->prev_redirscrub)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - Restoring 0x%08x to RedirScrubCtrl", ryzdata->prev_redirscrub);
            MtSupportDebugWriteLine(gBuffer);

            pci_conf_write(0, 24, 6, RYZEN_REDIR_SCRUB_CTRL, 4, ryzdata->prev_redirscrub);
        }
        return TRUE;
    }

    for (i = 0; i < ctrl->numch; i++)
    {
        int n;

        smn_read(bus, UMC_MISCCFG(i), &misccfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - UMC_MISCCFG[%d] = %08x", i, misccfg);
        MtSupportDebugWriteLine(gBuffer);

        if (misccfg & (1 << 2)) // [2] DisErrInj
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - UMC error injection configuration writes are disabled (MISCCFG[%d] = %08x)", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            misccfg &= ~(1 << 2);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - writing UMC_MISCCFG[%d] = %08x", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_MISCCFG(i), misccfg);

            smn_read(bus, UMC_MISCCFG(i), &misccfg);

            if (misccfg & (1 << 2))
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - UMC error injection cannot be enabled (MISCCFG[%d] = %08x)", i, misccfg);
                MtSupportDebugWriteLine(gBuffer);

                ret = FALSE;
            }
        }

        for (n = 0; n < 4; n++)
        {
            smn_read(bus, UMC_ECCERRINJ(i, n), &eccerrinj);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            eccerrinj &= 0xfe000000; // 24:16 EccInjEn 15:0 EccInjVector
            if (uncorrectable)
                eccerrinj |= 0x00011111;
            else
                eccerrinj |= 0x00010001;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - writing UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCERRINJ(i, n), eccerrinj);
        }

        smn_read(bus, UMC_ECCERRINJCTRL(i), &eccerrinjctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        eccerrinjctrl &= ~0x7;
        eccerrinjctrl |= 0x2; // EccErrOneShotEn

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen - writing UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        smn_write(bus, UMC_ECCERRINJCTRL(i), eccerrinjctrl);
    }

    return ret;
}

BOOLEAN inject_ryzen_zen4(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;
    unsigned node = 0;
    unsigned int bus = 0;
    unsigned long misccfg = 0, eccerrinj = 0, eccerrinjctrl = 0;
    unsigned long dramscrub = 0;
    int i;
    BOOLEAN ret = TRUE;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        int n;

        if (enable)
        {
            /* Check if DRAM periodic scrub is enabled */
            smn_read(bus, ZEN4_UMC_DRAMSCRUBCTRL(i), &dramscrub);
            ryzdata->prev_dramscrub = dramscrub;
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - DramScrubCtrl=%08x (DramScrubEn=%d, PoisonScrubEn=%d, RedirScrubEn=%d)", dramscrub, BitExtract(dramscrub, 8, 8), BitExtract(dramscrub, 5, 5), BitExtract(dramscrub, 4, 4));
            MtSupportDebugWriteLine(gBuffer);
            if (BitExtract(dramscrub, 8, 8) || BitExtract(dramscrub, 5, 5) || BitExtract(dramscrub, 4, 4))
            {
                unsigned long newdramscrub = dramscrub;
                newdramscrub &= ~(1 << 8);
                newdramscrub &= ~(1 << 5);
                newdramscrub &= ~(1 << 4);

                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - Writing 0x%08x to DramScrubCtrl", newdramscrub);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, ZEN4_UMC_DRAMSCRUBCTRL(i), newdramscrub);
            }

            smn_read(bus, ZEN4_UMC_DRAMSCRUBBASEADDR(i), &dramscrub);
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_ryzen_zen4 - DramScrubBaseAddr=%08x", dramscrub);

            smn_read(bus, ZEN4_UMC_DRAMSCRUBLIMITADDR(i), &dramscrub);
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_ryzen_zen4 - DramScrubLimitAddr=%08x", dramscrub);
        }
        else
        {
            smn_read(bus, ZEN4_UMC_DRAMSCRUBCTRL(i), &dramscrub);
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - DramScrubCtrl=%08x (DramScrubEn=%d, PoisonScrubEn=%d, RedirScrubEn=%d)", dramscrub, BitExtract(dramscrub, 8, 8), BitExtract(dramscrub, 5, 5), BitExtract(dramscrub, 4, 4));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - Previous DramScrubBaseAddr=%08x", ryzdata->prev_dramscrub);
            MtSupportDebugWriteLine(gBuffer);

            /* Re-enable DRAM periodic scrub */
            if (dramscrub != ryzdata->prev_dramscrub)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - Restoring 0x%08x to DramScrubBaseAddr", ryzdata->prev_dramscrub);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, ZEN4_UMC_DRAMSCRUBCTRL(i), ryzdata->prev_dramscrub);
            }
            continue;
        }

        smn_read(bus, UMC_MISCCFG(i), &misccfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - UMC_MISCCFG[%d] = %08x", i, misccfg);
        MtSupportDebugWriteLine(gBuffer);

        if (misccfg & (1 << 2)) // [2] DisErrInj
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - UMC error injection configuration writes are disabled (MISCCFG[%d] = %08x)", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            misccfg &= ~(1 << 2);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - writing UMC_MISCCFG[%d] = %08x", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_MISCCFG(i), misccfg);

            smn_read(bus, UMC_MISCCFG(i), &misccfg);

            if (misccfg & (1 << 2))
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - UMC error injection cannot be enabled (MISCCFG[%d] = %08x)", i, misccfg);
                MtSupportDebugWriteLine(gBuffer);

                ret = FALSE;
            }
        }

        for (n = 0; n < 4; n++)
        {
            smn_read(bus, UMC_ECCERRINJ(i, n), &eccerrinj);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            eccerrinj &= 0xfc000000; // 25:16 EccInjEn 15:0 EccInjVector
            if (uncorrectable)
                eccerrinj |= 0x00011111;
            else
                eccerrinj |= 0x00010001;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - writing UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCERRINJ(i, n), eccerrinj);
        }

        smn_read(bus, ZEN4_UMC_ECCERRINJCTRL(i), &eccerrinjctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        eccerrinjctrl &= ~0x7;
        eccerrinjctrl |= 0x2; // EccErrOneShotEn

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen4 - writing UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        smn_write(bus, ZEN4_UMC_ECCERRINJCTRL(i), eccerrinjctrl);
    }

    return ret;
}

BOOLEAN inject_ryzen_zen5(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;
    unsigned node = 0;
    unsigned int bus = 0;
    unsigned long misccfg = 0, eccerrinj = 0, eccerrinjctrl = 0;
    unsigned long dramscrub = 0;
    int i;
    BOOLEAN ret = TRUE;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    ryzen_data *ryzdata = (ryzen_data *)ctrl->userdata;

    node = ctrl->dev - 0x18;
    bus = node * 0x20;

    if (bus != BitExtract(ryzdata->cfgaddrcntl, 7, 0) && BitExtract(ryzdata->cfgaddrcntl, 7, 0) != 0xFF)
        bus = BitExtract(ryzdata->cfgaddrcntl, 7, 0);

    for (i = 0; i < ctrl->numch; i++)
    {
        int n;

        if (enable)
        {
            /* Check if DRAM periodic scrub is enabled */
            smn_read(bus, ZEN5_UMC_DRAMSCRUBCTRL(i), &dramscrub);
            ryzdata->prev_dramscrub = dramscrub;
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - DramScrubCtrl=%08x (DramScrubEn=%d, PoisonScrubEn=%d, RedirScrubEn=%d)", dramscrub, BitExtract(dramscrub, 8, 8), BitExtract(dramscrub, 5, 5), BitExtract(dramscrub, 4, 4));
            MtSupportDebugWriteLine(gBuffer);
            if (BitExtract(dramscrub, 8, 8) || BitExtract(dramscrub, 5, 5) || BitExtract(dramscrub, 4, 4))
            {
                unsigned long newdramscrub = dramscrub;
                newdramscrub &= ~(1 << 8);
                newdramscrub &= ~(1 << 5);
                newdramscrub &= ~(1 << 4);

                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - Writing 0x%08x to DramScrubCtrl", newdramscrub);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, ZEN5_UMC_DRAMSCRUBCTRL(i), newdramscrub);
            }

            smn_read(bus, ZEN5_UMC_DRAMSCRUBBASEADDR(i), &dramscrub);
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_ryzen_zen5 - DramScrubBaseAddr=%08x", dramscrub);

            smn_read(bus, ZEN5_UMC_DRAMSCRUBLIMITADDR(i), &dramscrub);
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_ryzen_zen5 - DramScrubLimitAddr=%08x", dramscrub);
        }
        else
        {
            smn_read(bus, ZEN5_UMC_DRAMSCRUBCTRL(i), &dramscrub);
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - DramScrubCtrl=%08x (DramScrubEn=%d, PoisonScrubEn=%d, RedirScrubEn=%d)", dramscrub, BitExtract(dramscrub, 8, 8), BitExtract(dramscrub, 5, 5), BitExtract(dramscrub, 4, 4));

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - Previous DramScrubBaseAddr=%08x", ryzdata->prev_dramscrub);
            MtSupportDebugWriteLine(gBuffer);

            /* Re-enable DRAM periodic scrub */
            if (dramscrub != ryzdata->prev_dramscrub)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - Restoring 0x%08x to DramScrubBaseAddr", ryzdata->prev_dramscrub);
                MtSupportDebugWriteLine(gBuffer);

                smn_write(bus, ZEN5_UMC_DRAMSCRUBCTRL(i), ryzdata->prev_dramscrub);
            }
            continue;
        }

        smn_read(bus, UMC_MISCCFG(i), &misccfg);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - UMC_MISCCFG[%d] = %08x", i, misccfg);
        MtSupportDebugWriteLine(gBuffer);

        if (misccfg & (1 << 2)) // [2] DisErrInj
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - UMC error injection configuration writes are disabled (MISCCFG[%d] = %08x)", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            misccfg &= ~(1 << 2);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - writing UMC_MISCCFG[%d] = %08x", i, misccfg);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_MISCCFG(i), misccfg);

            smn_read(bus, UMC_MISCCFG(i), &misccfg);

            if (misccfg & (1 << 2))
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - UMC error injection cannot be enabled (MISCCFG[%d] = %08x)", i, misccfg);
                MtSupportDebugWriteLine(gBuffer);

                ret = FALSE;
            }
        }

        for (n = 0; n < 4; n++)
        {
            smn_read(bus, UMC_ECCERRINJ(i, n), &eccerrinj);

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            eccerrinj &= 0xfc000000; // 25:16 EccInjEn 15:0 EccInjVector
            if (uncorrectable)
                eccerrinj |= 0x00011111;
            else
                eccerrinj |= 0x00010001;

            AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - writing UMC_ECCERRINJ_%d[%d] = %08x", n, i, eccerrinj);
            MtSupportDebugWriteLine(gBuffer);

            smn_write(bus, UMC_ECCERRINJ(i, n), eccerrinj);
        }

        smn_read(bus, ZEN5_UMC_ECCERRINJCTRL(i), &eccerrinjctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        eccerrinjctrl &= ~0x7;
        eccerrinjctrl |= 0x2; // EccErrOneShotEn

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_ryzen_zen5 - writing UMC_ECCERRINJCTRL[%d] = %08x", i, eccerrinjctrl);
        MtSupportDebugWriteLine(gBuffer);

        smn_write(bus, ZEN5_UMC_ECCERRINJCTRL(i), eccerrinjctrl);
    }

    return ret;
}

static void poll_amd64(struct ecc_info *ctrl)
{
    unsigned long mcanb_lo, mcanb_hi;
    UINT64 page, offset;
    unsigned long celog_syndrome;
    unsigned long mcanb_add_lo, mcanb_add_hi;

    pci_conf_read(0, 24, 3, 0x4C, 4, &mcanb_hi);

    if (((mcanb_hi >> 31) & 1) && ((mcanb_hi >> 14) & 1))
    {
        pci_conf_read(0, 24, 3, 0x48, 4, &mcanb_lo);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Status=" I64HEXFMT " ", (UINT64)mcanb_hi << 32 | mcanb_lo);
        MtSupportDebugWriteLine(gBuffer);

        /* Find out about the first correctable error */
        /* Syndrome code -> bits use a complex matrix. Will add this later */
        /* Read the error location */
        pci_conf_read(0, 24, 3, 0x50, 4, &mcanb_add_lo);
        pci_conf_read(0, 24, 3, 0x54, 4, &mcanb_add_hi);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Address=" I64HEXFMT, (UINT64)mcanb_add_hi << 32 | mcanb_add_lo);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the syndrome */
        celog_syndrome = (((mcanb_lo >> 24) & 0xFF) << 8) | ((mcanb_hi >> 15) & 0xFF);

        /* Parse the error location */
        page = ((UINT64)mcanb_add_hi << 32 | mcanb_add_lo) >> 12;
        offset = (mcanb_add_lo >> 3) & 0xFFF;

        // todo: convert address to channel and slot

        /* Report the error */
        MtSupportReportECCError((UINTN)((UINT64)mcanb_add_hi << 32 | mcanb_add_lo), TRUE, celog_syndrome, -1, -1, -1);

        /* Clear the error registers */
        pci_conf_write(0, 24, 3, 0x4C, 4, mcanb_hi & 0x7FFFFFFF);
    }
    if (((mcanb_hi >> 31) & 1) && ((mcanb_hi >> 13) & 1))
    {
        pci_conf_read(0, 24, 3, 0x48, 4, &mcanb_lo);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Status=" I64HEXFMT " ", (UINT64)mcanb_hi << 32 | mcanb_lo);
        MtSupportDebugWriteLine(gBuffer);

        /* Found out about the first uncorrectable error */
        /* Read the error location */
        pci_conf_read(0, 24, 3, 0x50, 4, &mcanb_add_lo);
        pci_conf_read(0, 24, 3, 0x54, 4, &mcanb_add_hi);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Address=" I64HEXFMT, (UINT64)mcanb_add_hi << 32 | mcanb_add_lo);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location */
        page = ((UINT64)mcanb_add_hi << 32 | mcanb_add_lo) >> 12;
        offset = (mcanb_add_lo >> 3) & 0xFFF;

        /* Report the error */
        MtSupportReportECCError((UINTN)((UINT64)mcanb_add_hi << 32 | mcanb_add_lo), FALSE, -1, -1, -1, -1);

        /* Clear the error registers */
        pci_conf_write(0, 24, 3, 0x4C, 4, mcanb_hi & 0x7FFFFFF);
    }
}

void inject_amd64(int index, int uncorrectable)
{
    unsigned long nb_arr_add = 0;
    unsigned long dram_ecc = 0;
    unsigned long mcanb;
    int i;

    if (index < 0 || index >= s_numctrls)
        return;

    for (i = 0; i < 3; i++)
    {
        pci_conf_read(0, 24, 3, 0xB8, 4, &nb_arr_add);

        nb_arr_add &= 0x0FFFFC00;

        pci_conf_write(0, 24, 3, 0xB8, 4, nb_arr_add | 0x80000000 | (i << 1));

        pci_conf_read(0, 24, 3, 0xB8, 4, &nb_arr_add);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_amd64 - new nb_arr_add = %08x", nb_arr_add);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(0, 24, 3, 0xBC, 4, &dram_ecc);

        dram_ecc &= 0xE0080000;

        if (uncorrectable)
            dram_ecc |= (0x5 << 20);
        else
            dram_ecc |= (0x1 << 20);

        dram_ecc |= 0x000F;

        dram_ecc |= (1 << 17);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_amd64 - new dram_ecc = %08x", dram_ecc);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_write(0, 24, 3, 0xBC, 4, dram_ecc);

        pci_conf_read(0, 24, 3, 0x4C, 4, &mcanb);

        AsciiSPrint(gBuffer, BUF_SIZE, "MCA NB Status High=%08x", mcanb);
        MtSupportDebugWriteLine(gBuffer);
    }
}

static void setup_amd751(struct ecc_info *ctrl)
{
    unsigned long dram_status;

    MtSupportDebugWriteLine("AMD 751 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x5a, 2, &dram_status);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRAM STATUS=%08x", dram_status);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = (dram_status & (1 << 2)) ? ECC_CORRECT : ECC_NONE;
}

static void poll_amd751(struct ecc_info *ctrl)
{
    unsigned long ecc_status;
    unsigned long bank_addr;
    unsigned long bank_info;
    unsigned long page;
    int bits;
    int i;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x58, 2, &ecc_status);
    if (ecc_status & (3 << 8))
    {

        AsciiSPrint(gBuffer, BUF_SIZE, "ECC STATUS=%08x", ecc_status);
        MtSupportDebugWriteLine(gBuffer);

        for (i = 0; i < 6; i++)
        {
            if (!(ecc_status & (1 << i)))
            {
                continue;
            }
            /* Find the bank the error occured on */
            bank_addr = 0x40 + (i << 1);

            /* Now get the information on the erroring bank */
            pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, bank_addr, 2, &bank_info);

            AsciiSPrint(gBuffer, BUF_SIZE, "BANK INFO(%x)=%08x", bank_addr, bank_info);
            MtSupportDebugWriteLine(gBuffer);

            /* Parse the error location and error type */
            page = (bank_info & 0xFF80) << 4;
            bits = (((ecc_status >> 8) & 3) == 2) ? 1 : 2;

            /* Report the error */
            MtSupportReportECCError(page << 12, bits == 1 ? 1 : 0, -1, -1, -1, -1);
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0x58, 2, 0);
    }
}

/* Still waiting for the CORRECT intel datasheet
static void setup_i85x(struct ecc_info* ctrl)
{
    unsigned long drc;
    ctrl->cap = ECC_CORRECT;

    pci_conf_read(ctrl->bus, ctrl->dev, 1, 0x70, 4, &drc);
    ctrl->mode = ((drc>>20)&1)?ECC_CORRECT:ECC_NONE;

}
*/

static void setup_amd76x(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_DETECT, ECC_CORRECT, ECC_CORRECT};
    unsigned long ecc_mode_status;

    MtSupportDebugWriteLine("AMD 76x chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x48, 4, &ecc_mode_status);

    AsciiSPrint(gBuffer, BUF_SIZE, "ECC Mode Status=%08x", ecc_mode_status);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(ecc_mode_status >> 10) & 3];
}

static void poll_amd76x(struct ecc_info *ctrl)
{
    unsigned long ecc_mode_status;
    unsigned long bank_addr;
    unsigned long bank_info;
    unsigned long page;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x48, 4, &ecc_mode_status);

    /* Multibit error */
    if (ecc_mode_status & (1 << 9))
    {
        /* Find the bank the error occured on */
        bank_addr = 0xC0 + (((ecc_mode_status >> 4) & 0xf) << 2);

        /* Now get the information on the erroring bank */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, bank_addr, 4, &bank_info);

        AsciiSPrint(gBuffer, BUF_SIZE, "BANK INFO(%x)=%08x", bank_addr, bank_info);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (bank_info & 0xFF800000) >> 12;

        /* Report the error */
        MtSupportReportECCError((page << 12), TRUE, -1, -1, -1, -1);
    }
    /* Singlebit error */
    if (ecc_mode_status & (1 << 8))
    {
        /* Find the bank the error occured on */
        bank_addr = 0xC0 + (((ecc_mode_status >> 0) & 0xf) << 2);

        /* Now get the information on the erroring bank */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, bank_addr, 4, &bank_info);

        AsciiSPrint(gBuffer, BUF_SIZE, "BANK INFO(%x)=%08x", bank_addr, bank_info);
        MtSupportDebugWriteLine(gBuffer); /* Parse the error location and error type */

        page = (bank_info & 0xFF800000) >> 12;

        /* Report the error */
        MtSupportReportECCError((page << 12), FALSE, -1, -1, -1, -1);
    }
    /* Clear the error status */
    if (ecc_mode_status & (3 << 8))
    {
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0x48, 4, ecc_mode_status);
    }
}

static void setup_cnb20(struct ecc_info *ctrl)
{
    MtSupportDebugWriteLine("CNB20 chipset init");

    /* Fill in the correct memory capabilites */
    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ECC_NONE;
    /* FIXME add ECC error polling.  I don't have the documentation
     * do it right now.
     */
}

/* Device 16, Function 1 */
#define INTEL5400_MC 0x40
#define INTEL5400_MC_ERRDETEN(reg) ((reg >> 5) & 1)
#define INTEL5400_MC_SCRBEN(reg) ((reg >> 7) & 1)

#define INTEL5400_FERR_FAT 0x98
#define INTEL5400_FERR_FAT_ERRBITS 0x00400003
#define INTEL5400_FERR_FAT_CHIDX(reg) ((reg >> 28) & 0x3)

#define INTEL5400_NERR_FAT 0x9C

#define INTEL5400_NRECMEMA 0xBE
#define INTEL5400_NRECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL5400_NRECMEMA_RANK(reg) ((reg >> 8) & 0xf)

#define INTEL5400_NRECMEMB 0xC0
#define INTEL5400_NRECMEMB_ROW(reg) ((reg) & 0xffff)
#define INTEL5400_NRECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

#define INTEL5400_FERR_NF 0xa0
#define INTEL5400_FERR_NF_ERRBITS 0x3F7FFFF
#define INTEL5400_FERR_NF_CHIDX(reg) INTEL5400_FERR_FAT_CHIDX(reg)

#define INTEL5400_NERR_NF 0xa4

#define INTEL5400_RECMEMA 0xE0
#define INTEL5400_RECMEMA_BANK(reg) INTEL5400_NRECMEMA_BANK(reg)
#define INTEL5400_RECMEMA_RANK(reg) INTEL5400_NRECMEMA_RANK(reg)

#define INTEL5400_RECMEMB 0xE4
#define INTEL5400_RECMEMB_ROW(reg) INTEL5400_NRECMEMB_ROW(reg)
#define INTEL5400_RECMEMB_COL(reg) INTEL5400_NRECMEMB_COL(reg)

#define INTEL5400_REDMEMA 0xDC
#define INTEL5400_REDMEMB 0x7C

static void setup_E5400(struct ecc_info *ctrl)
{
    unsigned long mcs;

    MtSupportDebugWriteLine("Intel 5400 chipset init");

    /* Read the hardware capabilities */
    pci_conf_read(ctrl->bus, 16, 1, INTEL5400_MC, 4, &mcs); /* MC - Memory Control Settings */

    AsciiSPrint(gBuffer, BUF_SIZE, "MC=%08x", mcs);
    MtSupportDebugWriteLine(gBuffer);

    /* Fill in the correct memory capabilities */
    ctrl->mode = 0;
    ctrl->cap = ECC_SCRUB;

    /* Checking and correcting enabled */
    if (INTEL5400_MC_ERRDETEN(mcs))
    {
        unsigned long value;

        ctrl->mode |= ECC_CORRECT;

        /* read in the 1st FATAL error register */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5400_FERR_FAT, 4, &value);

        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_FAT=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        if (value & INTEL5400_FERR_FAT_ERRBITS)
            pci_conf_write(ctrl->bus, 16, 1, INTEL5400_FERR_FAT, 4, value);

        /* read in the 1st NON-FATAL error register */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5400_FERR_NF, 4, &value);

        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_NF=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        if (value & INTEL5400_FERR_NF_ERRBITS)
            pci_conf_write(ctrl->bus, 16, 1, INTEL5400_FERR_NF, 4, value);
    }

    /* scrub enabled */
    if (INTEL5400_MC_SCRBEN(mcs))
    {
        ctrl->mode |= __ECC_SCRUB;
    }
}

static void poll_E5400(struct ecc_info *ctrl)
{
    UINT8 channel;
    unsigned long col, row;
    UINT8 bank, rank;

    unsigned long value;
    unsigned long ferr_fat_fbd = 0;
    unsigned long nerr_fat_fbd = 0;
    unsigned long nrecmema = 0;
    unsigned long nrecmemb = 0;

    unsigned long ferr_nf_fbd = 0;
    unsigned long nerr_nf_fbd = 0;
    unsigned long recmema = 0;
    unsigned long recmemb = 0;
    unsigned long redmema = 0;
    unsigned long redmemb = 0;

    /* read in the 1st FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL5400_FERR_FAT, 4, &value);

    if (value & INTEL5400_FERR_FAT_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_FAT=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        ferr_fat_fbd = value;

        /* harvest the various error data we need */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5400_NERR_FAT, 4, &nerr_fat_fbd);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_NRECMEMA, 2, &nrecmema);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_NRECMEMB, 4, &nrecmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR_FAT=%08x", nerr_fat_fbd);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMA=%08X", nrecmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMB=%08X", nrecmemb);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error bits, by writing them back */
        pci_conf_write(ctrl->bus, 16, 1, INTEL5400_FERR_FAT, 4, value);

        channel = INTEL5400_FERR_FAT_CHIDX(ferr_fat_fbd);
        bank = INTEL5400_NRECMEMA_BANK(nrecmema);
        rank = INTEL5400_NRECMEMA_RANK(nrecmema);
        row = INTEL5400_NRECMEMB_ROW(nrecmemb);
        col = INTEL5400_NRECMEMB_COL(nrecmemb);

        /* Report the error */
        MtSupportReportECCError_dimm(col, row, bank, rank, FALSE, -1, -1, channel, -1);
    }

    /* read in the 1st NON-FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL5400_FERR_NF, 4, &value);

    /* If there is an error, then read in the 1st NON-FATAL error
     * register as well */
    if (value & INTEL5400_FERR_NF_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_NF=%08x", value);
        MtSupportDebugWriteLine(gBuffer);
        ferr_nf_fbd = value;

        /* harvest the various error data we need */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5400_NERR_NF, 4, &nerr_nf_fbd);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_RECMEMA, 4, &recmema);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_RECMEMB, 4, &recmemb);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_REDMEMA, 4, &redmema);
        pci_conf_read(ctrl->bus, 21, 1, INTEL5400_REDMEMB, 4, &redmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR_NF=%08x", nerr_nf_fbd);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMA=%08X", recmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMB=%08X", recmemb);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMA=%08X", redmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMB=%08X", redmemb);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error bits, by writing them back */
        pci_conf_write(ctrl->bus, 16, 1, INTEL5400_FERR_NF, 4, value);

        channel = ((redmemb) & 0x3fe00) ? 1 : 0;
        channel += INTEL5400_FERR_NF_CHIDX(ferr_nf_fbd);

        bank = INTEL5400_RECMEMA_BANK(recmema);
        rank = INTEL5400_RECMEMA_RANK(recmema);
        row = INTEL5400_RECMEMB_ROW(recmemb);
        col = INTEL5400_RECMEMB_COL(recmemb);

        /* Report the error */
        MtSupportReportECCError_dimm(col, row, bank, rank, TRUE, redmema, -1, channel, -1);
    }
}

/* Device 16, Function 1 */
#define INTEL5000_FERR_FAT 0x98
#define INTEL5000_FERR_FAT_ERRBITS 0x00400007
#define INTEL5000_FERR_FAT_CHIDX(reg) ((reg >> 28) & 0x3)

#define INTEL5000_NERR_FAT 0x9C

#define INTEL5000_NRECMEMA 0xBE
#define INTEL5000_NRECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL5000_NRECMEMA_RANK(reg) ((reg >> 8) & 0xf)

#define INTEL5000_NRECMEMB 0xC0
#define INTEL5000_NRECMEMB_ROW(reg) ((reg) & 0x7fff)
#define INTEL5000_NRECMEMB_COL(reg) ((reg >> 16) & 0x0fff)

#define INTEL5000_FERR_NF 0xa0
#define INTEL5000_FERR_NF_ERRBITS 0x187EFFF
#define INTEL5000_FERR_NF_CHIDX(reg) INTEL5000_FERR_FAT_CHIDX(reg)

#define INTEL5000_NERR_NF 0xa4

#define INTEL5000_RECMEMA 0xE2
#define INTEL5000_RECMEMA_BANK(reg) INTEL5000_NRECMEMA_BANK(reg)
#define INTEL5000_RECMEMA_RANK(reg) INTEL5000_NRECMEMA_RANK(reg)

#define INTEL5000_RECMEMB 0xE4
#define INTEL5000_RECMEMB_ROW(reg) INTEL5000_NRECMEMB_ROW(reg)
#define INTEL5000_RECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

#define INTEL5400_REDMEMA 0xDC
#define INTEL5400_REDMEMB 0x7C

static void poll_i5000(struct ecc_info *ctrl)
{
    UINT8 channel;
    unsigned long col, row;
    UINT8 bank, rank;

    unsigned long value;
    unsigned long ferr_fat_fbd = 0;
    unsigned long nerr_fat_fbd = 0;
    unsigned long nrecmema = 0;
    unsigned long nrecmemb = 0;

    unsigned long ferr_nf_fbd = 0;
    unsigned long nerr_nf_fbd = 0;
    unsigned long recmema = 0;
    unsigned long recmemb = 0;
    unsigned long redmemb = 0;

    /* read in the 1st FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL5000_FERR_FAT, 4, &value);

    if (value & INTEL5000_FERR_FAT_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_FAT=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        ferr_fat_fbd = value;

        /* harvest the various error data we need */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_NERR_FAT, 4, &nerr_fat_fbd);
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_NRECMEMA, 2, &nrecmema);
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_NRECMEMB, 4, &nrecmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR_FAT=%08x", nerr_fat_fbd);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMA=%08X", nrecmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMB=%08X", nrecmemb);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error bits, by writing them back */
        pci_conf_write(ctrl->bus, 16, 1, INTEL5000_FERR_FAT, 4, value);

        channel = INTEL5000_FERR_FAT_CHIDX(ferr_fat_fbd);
        bank = INTEL5000_NRECMEMA_BANK(nrecmema);
        rank = INTEL5000_NRECMEMA_RANK(nrecmema);
        row = INTEL5000_NRECMEMB_ROW(nrecmemb);
        col = INTEL5000_NRECMEMB_COL(nrecmemb);

        /* Report the error */
        MtSupportReportECCError_dimm(col, row, bank, rank, FALSE, -1, -1, channel, -1);
    }

    /* read in the 1st NON-FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL5000_FERR_NF, 4, &value);

    /* If there is an error, then read in the 1st NON-FATAL error
     * register as well */
    if (value & INTEL5000_FERR_NF_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_NF=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        ferr_nf_fbd = value;

        /* harvest the various error data we need */
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_NERR_NF, 4, &nerr_nf_fbd);
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_RECMEMA, 2, &recmema);
        pci_conf_read(ctrl->bus, 16, 1, INTEL5000_RECMEMB, 4, &recmemb);
        pci_conf_read(ctrl->bus, 16, 1, INTEL5400_REDMEMB, 4, &redmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR_NF=%08x", nerr_nf_fbd);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMA=%08X", recmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMB=%08X", recmemb);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMB=%08X", redmemb);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error bits, by writing them back */
        pci_conf_write(ctrl->bus, 16, 1, INTEL5000_FERR_NF, 4, value);

        channel = INTEL5400_FERR_NF_CHIDX(ferr_nf_fbd) & 2;

        bank = INTEL5000_RECMEMA_BANK(recmema);
        rank = INTEL5000_RECMEMA_RANK(recmema);
        row = INTEL5000_RECMEMB_ROW(recmemb);
        col = INTEL5000_RECMEMB_COL(recmemb);

        /* Report the error */
        MtSupportReportECCError_dimm(col, row, bank, rank, TRUE, -1, -1, channel, -1);
    }
}

#define INTEL5100_FERR_NF 0xA0
#define INTEL5100_FERR_NF_ERRBITS 0x0FFFFFFF
#define INTEL5100_FERR_NF_CHIDX(reg) ((reg >> 28) & 0x1)

#define INTEL5100_NERR_NF 0xA4

#define INTEL5100_VALIDLOG 0x18C
#define INTEL5100_REDMEMVALID(reg) ((reg >> 2) & 1)
#define INTEL5100_RECMEMVALID(reg) ((reg >> 1) & 1)
#define INTEL5100_NRECMEMVALID(reg) (reg & 1)

#define INTEL5100_NRECMEMA 0x190
#define INTEL5100_NRECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL5100_NRECMEMA_RANK(reg) ((reg >> 8) & 0x7)

#define INTEL5100_NRECMEMB 0x194
#define INTEL5100_NRECMEMB_ROW(reg) ((reg) & 0xffff)
#define INTEL5100_NRECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

#define INTEL5100_REDMEMA 0x198
#define INTEL5100_REDMEMB 0x19c

#define INTEL5100_RECMEMA 0x1a0
#define INTEL5100_RECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL5100_RECMEMA_RANK(reg) ((reg >> 8) & 0x7)

#define INTEL5100_RECMEMB 0x1a4
#define INTEL5100_RECMEMB_ROW(reg) ((reg) & 0xffff)
#define INTEL5100_RECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

static void poll_i5100(struct ecc_info *ctrl)
{
    unsigned long ferr_nf_mem, nerr_nf_mem;

    pci_conf_read(ctrl->bus, 16, 1, INTEL5100_FERR_NF, 4, &ferr_nf_mem);
    if (ferr_nf_mem & INTEL5100_FERR_NF_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_NF=%08x", ferr_nf_mem);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 16, 1, INTEL5100_NERR_NF, 4, &nerr_nf_mem);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR_NF=%08x", nerr_nf_mem);
        MtSupportDebugWriteLine(gBuffer);

        // i5100_read_log
        {
            UINT8 chan;
            unsigned int dev;
            unsigned long validlog;
            unsigned long dw2;
            unsigned long syndrome = 0;
            UINT8 bank;
            UINT8 rank;
            unsigned cas;
            unsigned ras;

            chan = INTEL5100_FERR_NF_CHIDX(ferr_nf_mem);
            dev = chan ? 22 : 21;

            pci_conf_read(ctrl->bus, dev, 0, INTEL5100_VALIDLOG, 4, &validlog);

            AsciiSPrint(gBuffer, BUF_SIZE, "VALIDLOG=%08x", validlog);
            MtSupportDebugWriteLine(gBuffer);

            if (INTEL5100_REDMEMVALID(validlog))
            { // recoverable
                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_REDMEMA, 4, &syndrome);

                AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMA=%08x", syndrome);
                MtSupportDebugWriteLine(gBuffer);
                /*
                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_REDMEMB, 4, &dw2);
                ecc_loc = dw2 & ((1 << 18) - 1);
                */
            }

            if (INTEL5100_RECMEMVALID(validlog))
            {
                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_RECMEMA, 4, &dw2);

                AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMA=%08x", dw2);
                MtSupportDebugWriteLine(gBuffer);

                bank = INTEL5100_RECMEMA_BANK(dw2);
                rank = INTEL5100_RECMEMA_RANK(dw2);

                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_RECMEMB, 4, &dw2);

                AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMB=%08x", dw2);
                MtSupportDebugWriteLine(gBuffer);

                cas = INTEL5100_RECMEMB_COL(dw2);
                ras = INTEL5100_RECMEMB_ROW(dw2);

                MtSupportReportECCError_dimm(cas, ras, bank, rank, TRUE, syndrome, -1, chan, -1);
            }

            if (INTEL5100_NRECMEMVALID(validlog))
            { // non-recoverable
                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_NRECMEMA, 4, &dw2);

                AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMA=%08x", dw2);
                MtSupportDebugWriteLine(gBuffer);

                bank = INTEL5100_NRECMEMA_BANK(dw2);
                rank = INTEL5100_NRECMEMA_RANK(dw2);

                pci_conf_read(ctrl->bus, dev, 0, INTEL5100_NRECMEMB, 4, &dw2);

                AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMB=%08x", dw2);
                MtSupportDebugWriteLine(gBuffer);

                cas = INTEL5100_NRECMEMB_COL(dw2);
                ras = INTEL5100_NRECMEMB_ROW(dw2);

                MtSupportReportECCError_dimm(cas, ras, bank, rank, FALSE, syndrome, -1, chan, -1);
            }

            pci_conf_write(ctrl->bus, dev, 0, INTEL5100_VALIDLOG, 4, validlog);
        }
        pci_conf_write(ctrl->bus, 16, 1, INTEL5100_NERR_NF, 4, nerr_nf_mem);
    }
    pci_conf_write(ctrl->bus, 16, 1, INTEL5100_FERR_NF, 4, ferr_nf_mem);
}

#define INTEL7300_FERR_GLOBAL_HI 0x48
#define INTEL7300_FERR_GLOBAL_HI_ERRBITS 0xF
#define INTEL7300_FERR_GLOBAL_HI_FATBITS 0xC

#define INTEL7300_FERR_GLOBAL_LO 0x40

#define INTEL7300_FERR_FAT 0x98
#define INTEL7300_FERR_FAT_ERRBITS 0x400007
#define INTEL7300_FERR_FAT_CHIDX(reg) ((reg >> 28) & 0x3)

#define INTEL7300_NRECMEMA 0xBE
#define INTEL7300_NRECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL7300_NRECMEMA_RANK(reg) ((reg >> 8) & 0xf)

#define INTEL7300_NRECMEMB 0xC0
#define INTEL7300_NRECMEMB_ROW(reg) ((reg) & 0xffff)
#define INTEL7300_NRECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

#define INTEL7300_NERR_FAT 0x9C

#define INTEL7300_FERR_NF 0xA0
#define INTEL7300_FERR_NF_ERRBITS 0x1E7EFFF
#define INTEL7300_FERR_NF_CHIDX(reg) ((reg >> 28) & 0x3)

#define INTEL7300_REDMEMA 0xDC
#define INTEL7300_RECMEMA 0xE0
#define INTEL7300_RECMEMA_BANK(reg) ((reg >> 12) & 0x7)
#define INTEL7300_RECMEMA_RANK(reg) ((reg >> 8) & 0xf)

#define INTEL7300_RECMEMB 0xE4
#define INTEL7300_RECMEMB_ROW(reg) ((reg) & 0xffff)
#define INTEL7300_RECMEMB_COL(reg) ((reg >> 16) & 0x1fff)

#define INTEL7300_REDMEMB 0x7C
#define INTEL7300_NERR_NF 0xA4

static void poll_i7300(struct ecc_info *ctrl)
{
    UINT8 channel;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome = 0;

    unsigned long value;
    unsigned long ferr_fat_fbd = 0;
    unsigned long nrecmema = 0;
    unsigned long nrecmemb = 0;

    unsigned long ferr_nf_fbd = 0;
    unsigned long recmema = 0;
    unsigned long recmemb = 0;
    unsigned long redmemb = 0;

    /* read in the 1st FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL7300_FERR_FAT, 4, &ferr_fat_fbd);
    if (ferr_fat_fbd & INTEL7300_FERR_FAT_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_FAT=%08x", ferr_fat_fbd);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_NRECMEMA, 2, &nrecmema);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_NRECMEMB, 4, &nrecmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMA=%08x", nrecmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NRECMEMB=%08x", nrecmemb);
        MtSupportDebugWriteLine(gBuffer);

        channel = INTEL7300_FERR_FAT_CHIDX(ferr_fat_fbd);

        bank = INTEL7300_NRECMEMA_BANK(nrecmema);
        rank = INTEL7300_NRECMEMA_RANK(nrecmema);
        col = INTEL7300_NRECMEMB_COL(nrecmemb);
        row = INTEL7300_NRECMEMB_ROW(nrecmemb);

        /* Clean the error register */
        pci_conf_write(ctrl->bus, 16, 1, INTEL7300_FERR_FAT, 4, ferr_fat_fbd);

        MtSupportReportECCError_dimm(col, row, bank, rank, FALSE, -1, -1, channel, -1);
    }

    /* read in the 1st NON-FATAL error register */
    pci_conf_read(ctrl->bus, 16, 1, INTEL7300_FERR_NF, 4, &ferr_nf_fbd);

    if (ferr_nf_fbd & INTEL7300_FERR_NF_ERRBITS)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "FERR_NF=%08x", ferr_nf_fbd);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_REDMEMA, 4, &syndrome);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_RECMEMA, 2, &recmema);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_RECMEMB, 4, &recmemb);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMA=%08x", recmema);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "RECMEMB=%08x", recmemb);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMA=%08x", syndrome);
        MtSupportDebugWriteLine(gBuffer);

        bank = INTEL7300_RECMEMA_BANK(recmema);
        rank = INTEL7300_RECMEMA_RANK(recmema);
        col = INTEL7300_RECMEMB_COL(recmemb);
        row = INTEL7300_RECMEMB_ROW(recmemb);

        pci_conf_read(ctrl->bus, 16, 1, INTEL7300_REDMEMB, 4, &value);

        AsciiSPrint(gBuffer, BUF_SIZE, "REDMEMB=%08x", value);
        MtSupportDebugWriteLine(gBuffer);

        channel = ((redmemb) & 0x3fe00) ? 1 : 0;
        channel += INTEL7300_FERR_NF_CHIDX(ferr_nf_fbd);

        /* Clear the error bit */
        pci_conf_write(ctrl->bus, 16, 1, INTEL7300_FERR_NF, 4, ferr_nf_fbd);

        MtSupportReportECCError_dimm(col, row, bank, rank, TRUE, syndrome, -1, channel, -1);
    }
}

static void setup_iE7xxx(struct ecc_info *ctrl)
{
    unsigned long mchcfgns;
    unsigned long drc;
    unsigned long device;
    unsigned long dvnp;

    MtSupportDebugWriteLine("Intel E7xxx chipset init");

    /* Read the hardare capabilities */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x52, 2, &mchcfgns);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHCFGNS=%08x", mchcfgns);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x7C, 4, &drc);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRC=%08x", drc);
    MtSupportDebugWriteLine(gBuffer);

    /* This is a check for E7205 */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x02, 2, &device);

    /* Fill in the correct memory capabilities */
    ctrl->mode = 0;
    ctrl->cap = ECC_CORRECT;

    /* checking and correcting enabled */
    if (((drc >> 20) & 3) == 2)
    {
        ctrl->mode |= ECC_CORRECT;
    }

    /* E7205 doesn't support scrubbing */
    if (device != 0x255d)
    {
        /* scrub enabled */
        /* For E7501, valid SCRUB operations is bit 0 / D0:F0:R70-73 */
        ctrl->cap = ECC_SCRUB;
        if (mchcfgns & 1)
        {
            ctrl->mode |= __ECC_SCRUB;
        }

        /* Now, we can active Dev1/Fun1 */
        /* Thanks to Tyan for providing us the board to solve this */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xE0, 2, &dvnp);
        AsciiSPrint(gBuffer, BUF_SIZE, "DVNP=%08x", dvnp);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xE0, 2, (dvnp & 0xFE));

        /* Clear any routing of ECC errors to interrupts that the BIOS might have set up */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x88, 1, 0x0);
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x8A, 1, 0x0);
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x8C, 1, 0x0);
    }

    /* Clear any prexisting error reports */
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 1, 3);
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 1, 3);
}

static void setup_iE7520(struct ecc_info *ctrl)
{
    unsigned long mchscrb;
    unsigned long drc;
    unsigned long dvnp1;

    MtSupportDebugWriteLine("E7520 chipset init");

    /* Read the hardare capabilities */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x52, 2, &mchscrb);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHSCRB=%08x", mchscrb);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x7C, 4, &drc);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRC=%08x", drc);
    MtSupportDebugWriteLine(gBuffer);

    /* Fill in the correct memory capabilities */
    ctrl->mode = 0;
    ctrl->cap = ECC_CORRECT;

    /* Checking and correcting enabled */
    if (((drc >> 20) & 3) != 0)
    {
        ctrl->mode |= ECC_CORRECT;
    }

    /* scrub enabled */
    ctrl->cap = ECC_SCRUB;
    if ((mchscrb & 3) == 2)
    {
        ctrl->mode |= __ECC_SCRUB;
    }

    /* Now, we can activate Fun1 */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xF4, 1, &dvnp1);

    AsciiSPrint(gBuffer, BUF_SIZE, "DVNP1=%08x", dvnp1);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xF4, 1, (dvnp1 | 0x20));

    /* Clear any prexisting error reports */
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 2, 0x4747);
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 2, 0x4747);
}

static void poll_iE7xxx(struct ecc_info *ctrl)
{
    unsigned long ferr;
    unsigned long nerr;

    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 1, &ferr);
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 1, &nerr);

    if (ferr & 1)
    {
        /* Find out about the first correctable error */
        unsigned long celog_add;
        unsigned long celog_syndrome;
        unsigned long page;

        AsciiSPrint(gBuffer, BUF_SIZE, "FERR=%08x", ferr);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xA0, 4, &celog_add);

        AsciiSPrint(gBuffer, BUF_SIZE, "CELOG_ADD=%08x", celog_add);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the syndrome */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xD0, 2, &celog_syndrome);

        AsciiSPrint(gBuffer, BUF_SIZE, "CELOG_SYNDROME=%08x", celog_syndrome);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location */
        page = (celog_add & 0x0FFFFFC0) >> 6;

        /* Report the error */
        MtSupportReportECCError((page << 12), TRUE, celog_syndrome, -1, -1, -1);

        /* Clear Bit */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 1, ferr & 3);
    }

    if (ferr & 2)
    {
        /* Found out about the first uncorrectable error */
        unsigned long uccelog_add;
        unsigned long page;

        AsciiSPrint(gBuffer, BUF_SIZE, "FERR=%08x", ferr);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xB0, 4, &uccelog_add);

        AsciiSPrint(gBuffer, BUF_SIZE, "UCELOG_ADD=%08x", uccelog_add);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location */
        page = (uccelog_add & 0x0FFFFFC0) >> 6;

        /* Report the error */
        MtSupportReportECCError((page << 12), FALSE, -1, -1, -1, -1);

        /* Clear Bit */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 1, ferr & 3);
    }

    /* Check if DRAM_NERR contains data */
    if (nerr & 3)
    {
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 1, nerr & 3);
    }
}

static void setup_i440gx(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_DETECT, ECC_CORRECT, ECC_CORRECT};
    unsigned long nbxcfg;

    MtSupportDebugWriteLine("Intel 440GX chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x50, 4, &nbxcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "NBXCFG=%08x", nbxcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(nbxcfg >> 7) & 3];
}

static void poll_i440gx(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    int bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x91, 2, &errsts);
    if (errsts & 0x11)
    {
        unsigned long eap;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%08x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x80, 4, &eap);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08x", eap);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF000) >> 12;
        bits = 0;
        if (eap & 3)
        {
            bits = ((eap & 3) == 1) ? 1 : 2;
        }

        if (bits)
        {
            /* Report the error */
            MtSupportReportECCError((page << 12), bits == 1 ? 1 : 0, -1, -1, -1, -1);
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0x91, 2, 0x11);
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0x80, 4, 3);
    }
}
static void setup_i840(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_CORRECT};
    unsigned long mchcfg;

    MtSupportDebugWriteLine("Intel 840 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x50, 2, &mchcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHCFG=%08x", mchcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(mchcfg >> 7) & 3];
}

static void poll_i840(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long syndrome;
    UINT8 channel;
    int bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    if (errsts & 3)
    {
        unsigned long eap;
        unsigned long derrctl_sts;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%08x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xE4, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xE2, 2, &derrctl_sts);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08x", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRCTRL_STS=%08x", derrctl_sts);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF800) >> 11;
        channel = eap & 1;
        syndrome = derrctl_sts & 0xFF;
        bits = ((errsts & 3) == 1) ? 1 : 2;

        /* Report the error */
        MtSupportReportECCError((page << 12), bits == 1 ? 1 : 0, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xE2, 2, 3 << 10);
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 3);
    }
}
static void setup_i875(struct ecc_info *ctrl)
{

    long *ptr;
    ulong dev0, dev6;
    ulong drc;

    MtSupportDebugWriteLine("Intel 875 chipset init");

    /* Fill in the correct memory capabilites */

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ECC_NONE;

    /* From my article : http://www.x86-secret.com/articles/tweak/pat/patsecrets-2.htm */
    /* Activate Device 6 */
    pci_conf_read(0, 0, 0, 0xF4, 1, &dev0);
    pci_conf_write(0, 0, 0, 0xF4, 1, (dev0 | 0x2));

    /* Activate Device 6 MMR */
    pci_conf_read(0, 6, 0, 0x04, 2, &dev6);
    pci_conf_write(0, 6, 0, 0x04, 2, (dev6 | 0x2));

    /* Read the MMR Base Address & Define the pointer*/
    pci_conf_read(0, 6, 0, 0x10, 4, &dev6);

    AsciiSPrint(gBuffer, BUF_SIZE, "BAR6=%08x", dev6);
    MtSupportDebugWriteLine(gBuffer);

#if 0
    ptr = (long*)((UINTN)dev6 + 0x68);

    if (((*ptr >> 18) & 1) == 1) { ctrl->mode = ECC_CORRECT; }
#endif
    ptr = (long *)((UINTN)dev6 + 0x68);

    drc = readmmio32((unsigned int *)ptr);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRC=%08x", drc);
    MtSupportDebugWriteLine(gBuffer);

    if (((drc >> 18) & 1) == 1)
    {
        ctrl->mode = ECC_CORRECT;
    }

    /* Reseting state */
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 0x81);
}

static void setup_i925(struct ecc_info *ctrl)
{

    // Activate MMR I/O
    ulong dev0, drc;
    unsigned long tolm;
    long *ptr;

    MtSupportDebugWriteLine("Intel 925 chipset init");

    pci_conf_read(0, 0, 0, 0x54, 4, &dev0);
    dev0 = dev0 | 0x10000000;
    pci_conf_write(0, 0, 0, 0x54, 4, dev0);

    // CDH start
    pci_conf_read(0, 0, 0, 0x44, 4, &dev0);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=%08x", dev0);
    MtSupportDebugWriteLine(gBuffer);

    if (!(dev0 & 0xFFFFC000))
    {
        pci_conf_read(0, 0, 0, 0x9C, 1, &tolm);

        AsciiSPrint(gBuffer, BUF_SIZE, "TOLUD=%02x", tolm);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_write(0, 0, 0, 0x47, 1, tolm & 0xF8);
    }
    // CDH end

    // ECC Checking
    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ECC_NONE;

    dev0 &= 0xFFFFC000;
#if 0
    ptr = (long*)((UINTN)dev0 + 0x120);
    drc = *ptr & 0xFFFFFFFF;
#endif
    ptr = (long *)((UINTN)dev0 + 0x120);
    drc = readmmio32((unsigned int *)ptr);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRC=%08x", drc);
    MtSupportDebugWriteLine(gBuffer);

    if (((drc >> 20) & 3) == 2)
    {
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 3);
        ctrl->mode = ECC_CORRECT;
    }
    else
    {
        ctrl->mode = ECC_NONE;
    }
}

#define INTEL925_ERRSTS 0xc8
#define INTEL925_DEAP 0x58
#define INTEL925_DERRSYN 0x5C
#define INTEL925_DERRDST 0x5D

static void poll_i925(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long des;
    unsigned long syndrome;
    unsigned long eap;

    UINT8 channel;
    UINT8 corrected;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL925_ERRSTS, 2, &errsts);

    if (errsts & 0x03)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location, syndrome and channel */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL925_DEAP, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL925_DERRSYN, 1, &syndrome);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL925_DERRDST, 1, &des);

        AsciiSPrint(gBuffer, BUF_SIZE, "DEAP=%08x", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRSYN=%02x", syndrome);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRDST=%02x", des);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF000) >> 12;
        channel = des & 1;
        corrected = (errsts & 0x01) ? 1 : 0;

        /* Report the error */
        MtSupportReportECCError((page << 12), corrected, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL925_ERRSTS, 2, 0x03);
    }
}

#define INTEL3000_ERRSTS 0xC8
#define INTEL3000_DEAP 0x58
#define INTEL3000_DERRSYN 0x5C
#define INTEL3000_DERRDST 0x5D

static void setup_i3000(struct ecc_info *ctrl)
{
    MtSupportDebugWriteLine("Intel 3000 chipset init");

    // ECC Checking
    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ECC_CORRECT;

    // Clear status
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3000_ERRSTS, 2, 0x03);
}

static void poll_i3000(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long syndrome;
    unsigned long eap;

    UINT8 channel;
    UINT8 corrected;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3000_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location, syndrome and channel */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3000_DEAP, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3000_DERRSYN, 1, &syndrome);

        AsciiSPrint(gBuffer, BUF_SIZE, "DEAP=%08x", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRSYN=%02x", syndrome);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF000) >> 12;
        channel = eap & 1;
        corrected = (errsts & 0x01) ? 1 : 0;

        /* Report the error */
        MtSupportReportECCError((page << 12), corrected, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3000_ERRSTS, 2, 0x03);
    }
}

static void setup_p35(struct ecc_info *ctrl)
{

    // Activate MMR I/O
    ulong dev0, capid0;

    MtSupportDebugWriteLine("Intel P35 chipset init");

    pci_conf_read(0, 0, 0, 0x48, 4, &dev0); // MCHBAR
    if (!(dev0 & 0x1))
    {
        pci_conf_write(0, 0, 0, 0x48, 1, dev0 | 1);
    }

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=%08x", dev0);
    MtSupportDebugWriteLine(gBuffer);

    // ECC Checking (No poll on X38/48 for now)
    pci_conf_read(0, 0, 0, 0xE4, 4, &capid0); // CAPID0 - Capability Identifier

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0[1]=%08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    if ((capid0 >> 8) & 1)
    {
        ctrl->cap = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    ctrl->mode = ECC_NONE;
}

#define INTEL3200_MCHBAR 0x48
#define INTEL3200_MCHBAR_HI 0x4C

#define INTEL3200_CAPID0_ECC 0xE4
#define INTEL3200_CAPID0_DUALCH 0xE9

#define INTEL3200_ERRSTS 0xC8

#define INTEL3200_MCHBAR_C0ECCERRLOG 0x280
#define INTEL3200_MCHBAR_C1ECCERRLOG 0x680

#define INTEL3200_ECCERRLOG_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL3200_ECCERRLOG_COL(reg) ((reg >> 48) & 0xffff)
#define INTEL3200_ECCERRLOG_ROW(reg) ((reg >> 32) & 0xffff)
#define INTEL3200_ECCERRLOG_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL3200_ECCERRLOG_RANK(reg) ((reg >> 27) & 0x03)

static void setup_i3200(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    MtSupportDebugWriteLine("Intel 3200 chipset init");

    pci_conf_read(0, 0, 0, INTEL3200_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL3200_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL3200_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0xFFFFFC000;

    pci_conf_read(0, 0, 0, INTEL3200_CAPID0_ECC, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0[1]=%08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    if ((capid0 >> 8) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
        ctrl->mode = ECC_CORRECT;
    }
}

static void poll_i3200(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 channel;
    int n_channels;
    UINT8 corrected;

    unsigned long capid0_9b; /* 9th byte of CAPID0 */
    UINT64 ECCerrlog[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3200_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3200_CAPID0_DUALCH, 1, &capid0_9b);

        AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0[DUALCH]=%02x", capid0_9b);
        MtSupportDebugWriteLine(gBuffer);

        n_channels = capid0_9b & 0x20 ? 1 : 2;

        for (channel = 0; channel < n_channels; channel++)
        {
            ECCerrlog[channel] = readmmio64(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL3200_MCHBAR_C0ECCERRLOG) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL3200_MCHBAR_C1ECCERRLOG)); /* Need to get channel 1 as well? */

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG[%d]=" I64HEXFMT, channel, ECCerrlog[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog[channel] & 0x03)
            {
                syndrome = INTEL3200_ECCERRLOG_SYN(ECCerrlog[channel]);
                col = INTEL3200_ECCERRLOG_COL(ECCerrlog[channel]);
                row = INTEL3200_ECCERRLOG_ROW(ECCerrlog[channel]);
                bank = INTEL3200_ECCERRLOG_BANK(ECCerrlog[channel]);
                rank = INTEL3200_ECCERRLOG_RANK(ECCerrlog[channel]);

                /* Parse the error location and error type */
                corrected = (ECCerrlog[channel] & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, -1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL3200_ERRSTS, 2, 0x03);
    }
}

static void setup_x38(struct ecc_info *ctrl)
{
    MtSupportDebugWriteLine("Intel X38 chipset (Intel 3200 equiv) init");

    setup_i3200(ctrl);
}

static void poll_x38(struct ecc_info *ctrl)
{
    poll_i3200(ctrl);
}

/*
 * Xeon E3-1200 memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e3-1200-family-vol-2-datasheet.html
 */
#define INTEL_E3SB_MCHBAR 0x48
#define INTEL_E3SB_MCHBAR_HI 0x4C

#define INTEL_E3SB_CAPID0_A 0xE4
#define INTEL_E3SB_CAPID0_B 0xE8

#define INTEL_E3SB_ERRSTS 0xC8
#define INTEL_E3SB_ERRCMD 0xCA
#define INTEL_E3SB_SMICMD 0xCC
#define INTEL_E3SB_SCICMD 0xCD

#define INTEL_E3SB_MCHBAR_CLKCFG 0xC00

#define INTEL_E3SB_MCHBAR_MAD_CHNL 0x5000
#define INTEL_E3SB_MCHBAR_MAD_DIMM_CH0 0x5004
#define INTEL_E3SB_MCHBAR_MAD_DIMM_CH1 0x5008

#define INTEL_E3SB_MCHBAR_TC_DBP_C0 0x4000
#define INTEL_E3SB_MCHBAR_TC_RAP_C0 0x4004
#define INTEL_E3SB_MCHBAR_TC_RWP_C0 0x4008
#define INTEL_E3SB_MCHBAR_TC_OTP_C0 0x400C
#define INTEL_E3SB_MCHBAR_ECCINJCOUNT_C0 0x40B4
#define INTEL_E3SB_MCHBAR_ECCDFT_C0 0x40B8
#define INTEL_E3SB_MCHBAR_ECCERRLOG0_C0 0x40C8
#define INTEL_E3SB_MCHBAR_ECCERRLOG1_C0 0x40CC
#define INTEL_E3SB_MCHBAR_ECCINJCOUNT_C1 0x44B4
#define INTEL_E3SB_MCHBAR_ECCDFT_C1 0x44B8
#define INTEL_E3SB_MCHBAR_ECCERRLOG0_C1 0x44C8
#define INTEL_E3SB_MCHBAR_ECCERRLOG1_C1 0x44CC

#define INTEL_E3SB_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_E3SB_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_E3SB_MCHBAR_MC_LOCK 0x50FC

#define INTEL_E3SB_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_E3SB_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_E3SB_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_E3SB_ECCERRLOG1_COL(reg) ((reg >> 16) & 0xffff)
#define INTEL_E3SB_ECCERRLOG1_ROW(reg) (reg & 0xffff)

#define INTEL_E3SB_MEM_TRML_TEMPERATURE_REPORT 0x58A4

#define INTEL_E3SB_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_E3SB_MCHBAR_MC_BIOS_DATA (0x5E04)

typedef struct
{
    unsigned long capid0_a;
    unsigned long capid0_b;
    unsigned long clkcfg;
    unsigned long long ms_total_size;
    unsigned long mad_chnl;
    unsigned long mad_dimm[2];
} snb_data;

static void setup_e3sb(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong errcmd;
#if 0
    ulong smicmd;
    ulong scicmd;
#endif

    ctrl->userdata = AllocateZeroPool(sizeof(snb_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    snb_data *snbdata = (snb_data *)ctrl->userdata;

    MtSupportDebugWriteLine("Intel E3 Sandy Bridge chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_E3SB_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_E3SB_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_E3SB_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFFC000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabiities
    pci_conf_read(0, 0, 0, INTEL_E3SB_CAPID0_A, 4, &snbdata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x", snbdata->capid0_a);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_E3SB_CAPID0_B, 4, &snbdata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", snbdata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_E3SB_ERRCMD, 2, &errcmd);

    AsciiSPrint(gBuffer, BUF_SIZE, "ERRCMD=%04x", errcmd);
    MtSupportDebugWriteLine(gBuffer);

    snbdata->clkcfg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_CLKCFG));

    AsciiSPrint(gBuffer, BUF_SIZE, "CLKCFG=%08x", snbdata->clkcfg);
    MtSupportDebugWriteLine(gBuffer);

#if 0
    pci_conf_read(0, 0, 0, INTEL_E3SB_SMICMD, 2, &smicmd);

    AsciiSPrint(gBuffer, BUF_SIZE, "SMICMD=%04x", smicmd);
    MtSupportDebugWriteLine(gBuffer);

    if (smicmd & 0x03)
    {
        MtSupportDebugWriteLine("SMI enabled. Disabling...");
        pci_conf_write(0, 0, 0, INTEL_E3SB_SMICMD, 2, smicmd & ~0x03);
    }
    pci_conf_read(0, 0, 0, INTEL_E3SB_SCICMD, 2, &scicmd);

    AsciiSPrint(gBuffer, BUF_SIZE, "SCICMD=%04x", scicmd);
    MtSupportDebugWriteLine(gBuffer);
#endif

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;

    if ((snbdata->capid0_a >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    snbdata->mad_chnl = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MAD_CHNL));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_CHNL=%08x", snbdata->mad_chnl);

    snbdata->ms_total_size = 0;
    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long tc_dbp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_TC_DBP_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_DBP=%08x", ch, tc_dbp);

        snbdata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MAD_DIMM_CH0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_%d=%08x", ch, snbdata->mad_dimm[ch]);

        unsigned long long dimm_a_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 15, 8), 28);
        snbdata->ms_total_size += dimm_a_size;
        snbdata->ms_total_size += dimm_b_size;

        unsigned int dimm_a_ranks = BitExtract(snbdata->mad_dimm[ch], 17, 17) + 1;
        unsigned int dimm_b_ranks = BitExtract(snbdata->mad_dimm[ch], 18, 18) + 1;
        unsigned int dimm_a_chipwidth = 1 << (BitExtract(snbdata->mad_dimm[ch], 19, 19) + 3);
        unsigned int dimm_b_chipwidth = 1 << (BitExtract(snbdata->mad_dimm[ch], 20, 20) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A size=%ld", ch, dimm_a_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A ranks=%d", ch, dimm_a_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A width=x%d", ch, dimm_a_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B size=%ld", ch, dimm_b_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B ranks=%d", ch, dimm_b_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B width=x%d", ch, dimm_b_chipwidth);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_a_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_a_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_b_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_b_chipwidth);

        if (dimm_a_size > 0 || dimm_b_size > 0)
            ctrl->chmode++;

        if ((snbdata->mad_dimm[ch] >> 24) & 0x02)
            ctrl->mode = ECC_CORRECT;
    }

    if ((ctrl->mode & ECC_CORRECT) != 0)
    {
        unsigned long errsts;

        pci_conf_read(0, 0, 0, INTEL_E3SB_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_E3SB_ERRSTS, 2, 0x03);
    }
}

static void poll_e3sb(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_E3SB_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Read the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] ERRLOG0=%08x, ERRLOG1=%08x", channel, ECCerrlog0[channel], ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_E3SB_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_E3SB_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_E3SB_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_E3SB_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_E3SB_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_E3SB_ERRSTS, 2, 0x03);
    }
}

// Reference: ECC DDR DRAM Error Injection Test Capabilities on Gladden, Sandy Bridge & Ivy Bridge Processors (Doc No: 494178)
// During functional operation, the ECC error injection registers are locked for writing by the LT_LOCK_MEMORY and the MC_LOCK registers. To write to these registers, a change to the Memory Reference Code (MRC) in BIOS is required.
void inject_e3sb(int index, int uncorrectable, int enable)
{
    UINT32 eccdft = 0;
    int channel;
    unsigned long capid0;
    UINT64 lt_lock_memory = 0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_E3SB_CAPID0_A, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - capid0 = %08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MC_LOCK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCADDRCOMP));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - ECC Addr Comp = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCADDRMASK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - ECC Addr Mask = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    for (channel = 0; channel < ctrl->numch; channel++)
    {
#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        if (channel == 0)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCINJCOUNT_C0));
        else if (channel == 1)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCINJCOUNT_C1));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - [Channel %d] ECC Inj count = %08x", channel, val);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCINJCOUNT_C0), 0x50);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCINJCOUNT_C1), 0x50);

        if (channel == 0)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCDFT_C0));
        else if (channel == 1)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCDFT_C1));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - [Channel %d] eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        eccdft &= 0xFFFFC7FF;

        if (enable == 0)
            eccdft &= ~(0x7 << 11);
        else if (uncorrectable == 1)
            eccdft |= (0x7 << 11);
        else if (uncorrectable == 0)
            eccdft |= (0x3 << 11);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3sb - [Channel %d] new eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCDFT_C0), eccdft);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_ECCDFT_C1), eccdft);

        _invdcache();
    }
}

void poll_timings_e3sb(struct ecc_info *ctrl)
{
    snb_data *snbdata = (snb_data *)ctrl->userdata;

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_a_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 15, 8), 28);
        unsigned long long ch_size = dimm_a_size + dimm_b_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_dbp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_TC_DBP_C0 + 0x400 * ch));

        unsigned char tCL = BitExtract(tc_dbp, 11, 8);
        unsigned char tRCD = BitExtract(tc_dbp, 3, 0);
        unsigned char tRAS = BitExtract(tc_dbp, 23, 16);
        unsigned char tRP = BitExtract(tc_dbp, 7, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3sb - [Ch %d] TC_DBP=%08x (%d-%d-%d-%d)", ch, tc_dbp, tCL, tRCD, tRP, tRAS);

        if (tCL < 5 || /* tCL > 12 || */
            tRP < 4 || /* tRP > 15 || */
            tRCD < 4 /* || tRCD > 15 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3sb - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 3, 0), BitExtract(mc_bios_req, 11, 8));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3sb - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 3, 0), BitExtract(mc_bios_data, 11, 8));
    unsigned int mc_freq = BitExtract(mc_bios_data, 3, 0);

    if (mc_freq == 0)
    {
        unsigned char Clk_Select = BitExtract(snbdata->clkcfg, 6, 4);
        if (Clk_Select == 0)
        {
            Clk_Select = BitExtract(snbdata->clkcfg, 2, 0);
            if (Clk_Select == 0)
                Clk_Select = BitExtract(snbdata->capid0_a, 2, 0);
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3sb - Clk_Select=%1x", Clk_Select);

        switch (Clk_Select)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        ctrl->memclk = mc_freq * 400 / 3;
    }
}

void poll_timings_e3ib(struct ecc_info *ctrl)
{
    snb_data *snbdata = (snb_data *)ctrl->userdata;

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_a_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(snbdata->mad_dimm[ch], 15, 8), 28);
        unsigned long long ch_size = dimm_a_size + dimm_b_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_dbp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_TC_DBP_C0 + 0x400 * ch));

        unsigned char tCL = BitExtract(tc_dbp, 11, 8);
        unsigned char tRCD = BitExtract(tc_dbp, 3, 0);
        unsigned char tRAS = BitExtract(tc_dbp, 23, 16);
        unsigned char tRP = BitExtract(tc_dbp, 7, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3ib - [Ch %d] TC_DBP=%08x (%d-%d-%d-%d)", ch, tc_dbp, tCL, tRCD, tRP, tRAS);

        if (tCL < 5 || /* tCL > 12 || */
            tRP < 4 || /* tRP > 15 || */
            tRCD < 4 /* || tRCD > 15 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3ib - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3ib - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8));
    unsigned int mc_freq = BitExtract(mc_bios_data, 5, 0);
    unsigned int mc_freq_type = BitExtract(mc_bios_data, 11, 8);

    if (mc_freq == 0)
    {
        unsigned char Clk_Select = BitExtract(snbdata->clkcfg, 6, 4);
        if (Clk_Select == 0)
        {
            Clk_Select = BitExtract(snbdata->clkcfg, 2, 0);
            if (Clk_Select == 0)
                Clk_Select = BitExtract(snbdata->capid0_b, 6, 4);
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3ib - Clk_Select=%1x", Clk_Select);

        switch (Clk_Select)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (mc_freq_type == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = mc_freq * 400 / 3;
        else // 1: 100.00Mhz
            ctrl->memclk = mc_freq * 100;
    }
}

int poll_temp_e3sb(struct ecc_info *ctrl)
{
    unsigned long mem_trml_temp_report;

    mem_trml_temp_report = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3SB_MEM_TRML_TEMPERATURE_REPORT));

    AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_e3sb - MEM_TRML_TEMPERATURE_REPORT=%08x", mem_trml_temp_report);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->dimmtemp[0] = mem_trml_temp_report & 0xff;
    ctrl->dimmtemp[ctrl->numsl] = (mem_trml_temp_report >> 8) & 0xff;
    return 0;
}

/*
 * Xeon E3-1200 v3 memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/processors/xeon/xeon-e3-1200v3-vol-2-datasheet.html
 */
#define INTEL_E3HASWELL_MCHBAR 0x48
#define INTEL_E3HASWELL_MCHBAR_HI 0x4C

#define INTEL_E3HASWELL_CAPID0_A 0xE4
#define INTEL_E3HASWELL_CAPID0_B 0xE8

#define INTEL_E3HASWELL_ERRSTS 0xC8

#define INTEL_E3HASWELL_MCHBAR_CLKCFG 0xC00

#define INTEL_E3HASWELL_MCHBAR_MAD_CHNL 0x5000
#define INTEL_E3HASWELL_MCHBAR_MAD_DIMM_CH0 0x5004
#define INTEL_E3HASWELL_MCHBAR_MAD_DIMM_CH1 0x5008

#define INTEL_E3HASWELL_MCHBAR_TC_PRE_C0 0x4000
#define INTEL_E3HASWELL_MCHBAR_TC_RDRD_C0 0x4004
#define INTEL_E3HASWELL_MCHBAR_TC_WR_C0 0x4008
#define INTEL_E3HASWELL_MCHBAR_TC_RDWR_C0 0x400C
#define INTEL_E3HASWELL_MCHBAR_TC_CAS_C0 0x4014
#define INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C0 0x40B4
#define INTEL_E3HASWELL_MCHBAR_ECCDFT_C0 0x40B8
#define INTEL_E3HASWELL_MCHBAR_ECCERRLOG0_C0 0x40C8
#define INTEL_E3HASWELL_MCHBAR_ECCERRLOG1_C0 0x40CC
#define INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C1 0x44B4
#define INTEL_E3HASWELL_MCHBAR_ECCDFT_C1 0x44B8
#define INTEL_E3HASWELL_MCHBAR_ECCERRLOG0_C1 0x44C8
#define INTEL_E3HASWELL_MCHBAR_ECCERRLOG1_C1 0x44CC
#define INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C2 0x4CB4
#define INTEL_E3HASWELL_MCHBAR_ECCDFT_C2 0x4CB8

#define INTEL_E3HASWELL_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_E3HASWELL_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_E3HASWELL_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_E3HASWELL_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_E3HASWELL_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_E3HASWELL_ECCERRLOG1_COL(reg) ((reg >> 16) & 0xffff)
#define INTEL_E3HASWELL_ECCERRLOG1_ROW(reg) (reg & 0xffff)

#define INTEL_E3HASWELL_DDR_DIMM_TEMP_C0 0x58B0
#define INTEL_E3HASWELL_DDR_DIMM_TEMP_C1 0x58B4

#define INTEL_E3HASWELL_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_E3HASWELL_MCHBAR_MC_BIOS_DATA (0x5E04)

typedef struct
{
    unsigned long capid0_a;
    unsigned long capid0_b;
    unsigned long clkcfg;
    unsigned long long ms_total_size;
    unsigned long mad_chnl;
    unsigned long mad_dimm[2];
} hsw_data;

static void setup_e3haswell(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ctrl->userdata = AllocateZeroPool(sizeof(hsw_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    hsw_data *hswdata = (hsw_data *)ctrl->userdata;

    MtSupportDebugWriteLine("Intel E3 Haswell-E chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_E3HASWELL_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_E3HASWELL_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_E3HASWELL_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_E3HASWELL_CAPID0_A, 4, &hswdata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x", hswdata->capid0_a);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_E3HASWELL_CAPID0_B, 4, &hswdata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", hswdata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    hswdata->clkcfg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_CLKCFG));

    AsciiSPrint(gBuffer, BUF_SIZE, "CLKCFG=%08x", hswdata->clkcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;

    if ((hswdata->capid0_a >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    hswdata->mad_chnl = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_MAD_CHNL));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_CHNL=%08x", hswdata->mad_chnl);

    hswdata->ms_total_size = 0;
    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=%08x", ch, tc_pre);

        unsigned long long tc_cas = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_TC_CAS_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_CAS=%08x", ch, tc_cas);

        hswdata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_MAD_DIMM_CH0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_%d=%08x", ch, hswdata->mad_dimm[ch]);

        unsigned long long dimm_a_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 15, 8), 28);
        hswdata->ms_total_size += dimm_a_size;
        hswdata->ms_total_size += dimm_b_size;

        unsigned int dimm_a_ranks = BitExtract(hswdata->mad_dimm[ch], 17, 17) + 1;
        unsigned int dimm_b_ranks = BitExtract(hswdata->mad_dimm[ch], 18, 18) + 1;
        unsigned int dimm_a_chipwidth = 1 << (BitExtract(hswdata->mad_dimm[ch], 19, 19) + 3);
        unsigned int dimm_b_chipwidth = 1 << (BitExtract(hswdata->mad_dimm[ch], 20, 20) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A size=%ld", ch, dimm_a_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A ranks=%d", ch, dimm_a_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A width=x%d", ch, dimm_a_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B size=%ld", ch, dimm_b_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B ranks=%d", ch, dimm_b_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B width=x%d", ch, dimm_b_chipwidth);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_a_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_a_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_b_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_b_chipwidth);

        if (dimm_a_size > 0 || dimm_b_size > 0)
            ctrl->chmode++;

        if ((hswdata->mad_dimm[ch] >> 24) & 0x3)
            ctrl->mode = ECC_CORRECT;
    }

    if ((ctrl->mode & ECC_CORRECT) != 0)
    {
        unsigned long errsts;

        pci_conf_read(0, 0, 0, INTEL_E3HASWELL_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_E3HASWELL_ERRSTS, 2, 0x03);
    }
}

static void poll_e3haswell(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_E3HASWELL_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;
        ulong capid0;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(0, 0, 0, INTEL_E3HASWELL_CAPID0_A, 4, &capid0);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Read the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_E3HASWELL_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_E3HASWELL_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_E3HASWELL_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_E3HASWELL_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_E3HASWELL_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_E3HASWELL_ERRSTS, 2, 0x03);
    }
}

void inject_e3haswell(int index, int uncorrectable, int enable)
{
    UINT32 eccdft = 0;
    int channel;
    int num_channels = 3;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_E3HASWELL_CAPID0_A, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - capid0 = %08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCADDRCOMP));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - ECC Addr Comp = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCADDRMASK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - ECC Addr Mask = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    for (channel = 0; channel < num_channels; channel++)
    {
#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        if (channel == 0)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C0));
        else if (channel == 1)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C1));
        else if (channel == 2)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - [Channel %d] ECC Inj count = %08x", channel, val);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C0), 0x50);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C1), 0x50);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCINJCOUNT_C2), 0x50);

        if (channel == 0)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C0));
        else if (channel == 1)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C1));
        else if (channel == 2)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - [Channel %d] eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        eccdft &= 0xFFFFC7FF;

        if (enable == 0)
            eccdft &= ~(0x7 << 11);
        else if (uncorrectable == 1)
            eccdft |= (0x7 << 11);
        else if (uncorrectable == 0)
            eccdft |= (0x3 << 11);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_e3haswell - [Channel %d] new eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C0), eccdft);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C1), eccdft);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_ECCDFT_C2), eccdft);
    }
}

void poll_timings_e3haswell(struct ecc_info *ctrl)
{
    hsw_data *hswdata = (hsw_data *)ctrl->userdata;

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_a_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 15, 8), 28);
        unsigned long long ch_size = dimm_a_size + dimm_b_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        unsigned long long tc_cas = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_TC_CAS_C0 + 0x400 * ch));

        unsigned char tCL = BitExtract(tc_cas, 4, 0);
        unsigned char tRCD = BitExtract(tc_pre, 4, 0);
        unsigned char tRAS = BitExtract(tc_pre, 16, 10);
        unsigned char tRP = BitExtract(tc_pre, 4, 0);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3haswell - [Ch %d] TC_PRE=%08x TC_CAS=%08X (%d-%d-%d-%d)", ch, tc_pre, tc_cas, tCL, tRCD, tRP, tRAS);

        if (tCL < 5 || /* tCL > 31 || */
            tRP < 8 /* || tRP > 63 || */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3haswell - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3haswell - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8));
    unsigned int mc_freq = BitExtract(mc_bios_data, 5, 0);

    if (mc_freq == 0)
    {
        unsigned char Clk_Select = BitExtract(hswdata->clkcfg, 6, 4);
        if (Clk_Select == 0)
        {
            Clk_Select = BitExtract(hswdata->clkcfg, 2, 0);
            if (Clk_Select == 0)
                Clk_Select = BitExtract(hswdata->capid0_b, 6, 4);
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_e3haswell - Clk_Select=%1x", Clk_Select);

        switch (Clk_Select)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        // 0101 = 1333 MT/s
        // 0110 = 1600 MT/ s
        switch (mc_freq)
        {
        case 0b110:
            ctrl->memclk = 800;
            break;
        case 0b101:
            ctrl->memclk = 667;
            break;
        }
    }
}

int poll_temp_e3haswell(struct ecc_info *ctrl)
{
    int channel;
    for (channel = 0; channel < ctrl->numch; channel++)
    {
        unsigned long dimm_temp;

        dimm_temp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_E3HASWELL_DDR_DIMM_TEMP_C0 + channel * 4));

        AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_e3haswell - DDR_DIMM_TEMP[%d]=%08x", channel, dimm_temp);
        MtSupportDebugWriteLine(gBuffer);

        ctrl->dimmtemp[channel * ctrl->numsl] = dimm_temp & 0xff;
        if (ctrl->numsl > 1)
            ctrl->dimmtemp[channel * ctrl->numsl + 1] = (dimm_temp >> 8) & 0xff;
    }
    return 0;
}

/*
 * Broadwell-H memory controller
 */
#define INTEL_BROADWELL_H_MCHBAR 0x48
#define INTEL_BROADWELL_H_MCHBAR_HI 0x4C

#define INTEL_BROADWELL_H_CAPID0_A 0xE4
#define INTEL_BROADWELL_H_CAPID0_B 0xE8

#define INTEL_BROADWELL_H_ERRSTS 0xC8

#define INTEL_BROADWELL_H_MCHBAR_CLKCFG 0xC00

#define INTEL_BROADWELL_H_MCHBAR_MAD_CHNL 0x5000
#define INTEL_BROADWELL_H_MCHBAR_MAD_DIMM_CH0 0x5004
#define INTEL_BROADWELL_H_MCHBAR_MAD_DIMM_CH1 0x5008

#define INTEL_BROADWELL_H_MCHBAR_TC_PRE_C0 0x4000
#define INTEL_BROADWELL_H_MCHBAR_TC_RDRD_C0 0x4004
#define INTEL_BROADWELL_H_MCHBAR_TC_WR_C0 0x4008
#define INTEL_BROADWELL_H_MCHBAR_TC_RDWR_C0 0x400C
#define INTEL_BROADWELL_H_MCHBAR_TC_CAS_C0 0x4014
#define INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C0 0x40B4
#define INTEL_BROADWELL_H_MCHBAR_ECCDFT_C0 0x40B8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG0_C0 0x40C8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG1_C0 0x40CC
#define INTEL_BROADWELL_H_MCHBAR_TC_PRE_C1 0x4400
#define INTEL_BROADWELL_H_MCHBAR_TC_RDRD_C1 0x4404
#define INTEL_BROADWELL_H_MCHBAR_TC_WR_C1 0x4408
#define INTEL_BROADWELL_H_MCHBAR_TC_RDWR_C1 0x440C
#define INTEL_BROADWELL_H_MCHBAR_TC_CAS_C1 0x4414
#define INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C1 0x44B4
#define INTEL_BROADWELL_H_MCHBAR_ECCDFT_C1 0x44B8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG0_C1 0x44C8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG1_C1 0x44CC
#define INTEL_BROADWELL_H_MCHBAR_TC_PRE_C2 0x4C00
#define INTEL_BROADWELL_H_MCHBAR_TC_RDRD_C2 0x4C04
#define INTEL_BROADWELL_H_MCHBAR_TC_WR_C2 0x4C08
#define INTEL_BROADWELL_H_MCHBAR_TC_RDWR_C2 0x4C0C
#define INTEL_BROADWELL_H_MCHBAR_TC_CAS_C2 0x4C14
#define INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C2 0x4CB4
#define INTEL_BROADWELL_H_MCHBAR_ECCDFT_C2 0x4CB8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG0_C2 0x4CC8
#define INTEL_BROADWELL_H_MCHBAR_ECCERRLOG1_C2 0x4CCC

#define INTEL_BROADWELL_H_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_BROADWELL_H_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_BROADWELL_H_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_BROADWELL_H_ECCERRLOG0_BANK(reg) ((reg >> 27) & 0x07)
#define INTEL_BROADWELL_H_ECCERRLOG0_RANK(reg) ((reg >> 30) & 0x03)
#define INTEL_BROADWELL_H_ECCERRLOG1_COL(reg) ((reg >> 16) & 0xffff)
#define INTEL_BROADWELL_H_ECCERRLOG1_ROW(reg) (reg & 0xffff)

#define INTEL_BROADWELL_H_DDR_DIMM_TEMP_C0 0x58B0
#define INTEL_BROADWELL_H_DDR_DIMM_TEMP_C1 0x58B4

#define INTEL_BROADWELL_H_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_BROADWELL_H_MCHBAR_MC_BIOS_DATA (0x5E04)

static void setup_broadwell_h(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ctrl->userdata = AllocateZeroPool(sizeof(hsw_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    hsw_data *hswdata = (hsw_data *)ctrl->userdata;

    MtSupportDebugWriteLine("Intel Broadwell chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_BROADWELL_H_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = LShiftU64(BitExtractULL(LShiftU64(mchbar_high, 32) | mchbar_low, 38, 15), 15); // MCHBAR 38:15

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_CAPID0_A, 4, &hswdata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x", hswdata->capid0_a);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_CAPID0_B, 4, &hswdata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", hswdata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    hswdata->clkcfg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_CLKCFG));

    AsciiSPrint(gBuffer, BUF_SIZE, "CLKCFG=%08x", hswdata->clkcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;

    if ((hswdata->capid0_a >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    hswdata->mad_chnl = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_MAD_CHNL));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_CHNL=%08x", hswdata->mad_chnl);
    MtSupportDebugWriteLine(gBuffer);

    hswdata->ms_total_size = 0;
    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=%08x", ch, tc_pre);

        unsigned long long tc_cas = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_TC_CAS_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_CAS=%08x", ch, tc_cas);

        hswdata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_MAD_DIMM_CH0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_%d=%08x", ch, hswdata->mad_dimm[ch]);

        unsigned long long dimm_a_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 7, 0), 28);
        unsigned long long dimm_b_size = LShiftU64(BitExtract(hswdata->mad_dimm[ch], 15, 8), 28);
        hswdata->ms_total_size += dimm_a_size;
        hswdata->ms_total_size += dimm_b_size;

        unsigned int dimm_a_ranks = BitExtract(hswdata->mad_dimm[ch], 17, 17) + 1;
        unsigned int dimm_b_ranks = BitExtract(hswdata->mad_dimm[ch], 18, 18) + 1;
        unsigned int dimm_a_chipwidth = 1 << (BitExtract(hswdata->mad_dimm[ch], 19, 19) + 3);
        unsigned int dimm_b_chipwidth = 1 << (BitExtract(hswdata->mad_dimm[ch], 20, 20) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A size=%ld", ch, dimm_a_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A ranks=%d", ch, dimm_a_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM A width=x%d", ch, dimm_a_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B size=%ld", ch, dimm_b_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B ranks=%d", ch, dimm_b_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM B width=x%d", ch, dimm_b_chipwidth);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_a_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_a_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_b_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_b_chipwidth);

        if (dimm_a_size > 0 || dimm_b_size > 0)
            ctrl->chmode++;

        if ((hswdata->mad_dimm[ch] >> 24) & 0x3)
            ctrl->mode = ECC_CORRECT;
    }

    if ((ctrl->mode & ECC_CORRECT) != 0)
    {
        unsigned long errsts;

        pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_BROADWELL_H_ERRSTS, 2, 0x03);
    }
}

static void poll_broadwell_h(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_BROADWELL_H_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Get the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_BROADWELL_H_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_BROADWELL_H_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_BROADWELL_H_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_BROADWELL_H_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_BROADWELL_H_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_BROADWELL_H_ERRSTS, 2, 0x03);
    }
}

void inject_broadwell_h(int index, int uncorrectable, int enable)
{
    UINT32 eccdft = 0;
    int channel;
    int num_channels = 3;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_BROADWELL_H_CAPID0_A, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - capid0 = %08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCADDRCOMP));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - ECC Addr Comp = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCADDRMASK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - ECC Addr Mask = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    for (channel = 0; channel < num_channels; channel++)
    {
        if (channel == 0)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C0));
        else if (channel == 1)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C1));
        else if (channel == 2)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - [Channel %d] ECC Inj count = %08x", channel, val);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C0), 0x50);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C1), 0x50);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCINJCOUNT_C2), 0x50);

        if (channel == 0)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C0));
        else if (channel == 1)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C1));
        else if (channel == 2)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - [Channel %d] eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        eccdft &= 0xFFFFC7FF;

        if (enable == 0)
            eccdft &= ~(0x7 << 11);
        else if (uncorrectable == 1)
            eccdft |= (0x7 << 11);
        else if (uncorrectable == 0)
            eccdft |= (0x3 << 11);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_broadwell_h - [Channel %d] new eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C0), eccdft);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C1), eccdft);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_MCHBAR_ECCDFT_C2), eccdft);

        _invdcache();
    }
}

int poll_temp_broadwell_h(struct ecc_info *ctrl)
{
    int channel;
    for (channel = 0; channel < ctrl->numch; channel++)
    {
        unsigned long dimm_temp;

        dimm_temp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_BROADWELL_H_DDR_DIMM_TEMP_C0 + channel * 4));

        AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_broadwell_h - DDR_DIMM_TEMP[%d]=%08x", channel, dimm_temp);
        MtSupportDebugWriteLine(gBuffer);

        ctrl->dimmtemp[channel * ctrl->numsl] = dimm_temp & 0xff;
        if (ctrl->numsl > 1)
            ctrl->dimmtemp[channel * ctrl->numsl + 1] = (dimm_temp >> 8) & 0xff;
    }
    return 0;
}

/*
 * Skylake memory controller
 *
 * Reference: Skylake Processor External Design Specification (EDS) (Doc: 544925) [Confidential]
 */
#define INTEL_SKYLAKE_MCHBAR 0x48
#define INTEL_SKYLAKE_MCHBAR_HI 0x4C

#define INTEL_SKYLAKE_CAPID0_A 0xE4
#define INTEL_SKYLAKE_CAPID0_B 0xE8
#define INTEL_SKYLAKE_CAPID0_C 0xEC

#define INTEL_SKYLAKE_ERRSTS 0xC8

#define INTEL_SKYLAKE_MCHBAR_MAD_INTER 0x5000
#define INTEL_SKYLAKE_MCHBAR_MAD_INTRA_0 0x5004
#define INTEL_SKYLAKE_MCHBAR_MAD_INTRA_1 0x5008
#define INTEL_SKYLAKE_MCHBAR_MAD_DIMM_0 0x500C
#define INTEL_SKYLAKE_MCHBAR_MAD_DIMM_1 0x5010
#define INTEL_SKYLAKE_MCHBAR_SA_PERF_STATUS 0x5918
#define INTEL_SKYLAKE_MCHBAR_TC_PRE_C0 0x4000
#define INTEL_SKYLAKE_MCHBAR_ECCDFT_C0 0x4034
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG0_C0 0x4048
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG1_C0 0x404C
#define INTEL_SKYLAKE_MCHBAR_TC_ODT_C0 0x4070
#define INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C0 0x4274
#define INTEL_SKYLAKE_MCHBAR_TC_PRE_C1 0x4400
#define INTEL_SKYLAKE_MCHBAR_ECCDFT_C1 0x4434
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG0_C1 0x4448
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG1_C1 0x444C
#define INTEL_SKYLAKE_MCHBAR_TC_ODT_C1 0x4470
#define INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C1 0x4674
#define INTEL_SKYLAKE_MCHBAR_ECCDFT_C2 0x4C34
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG0_C2 0x4C48
#define INTEL_SKYLAKE_MCHBAR_ECCERRLOG1_C2 0x4C4C
#define INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C2 0x4E74

#define INTEL_SKYLAKE_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_SKYLAKE_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_SKYLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_SKYLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_SKYLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_SKYLAKE_ECCERRLOG1_COL(reg) ((reg >> 17) & 0x07ff)
#define INTEL_SKYLAKE_ECCERRLOG1_ROW(reg) (reg & 0x1ffff)

#define INTEL_SKYLAKE_DDR_DIMM_TEMP_C0 0x58B0
#define INTEL_SKYLAKE_DDR_DIMM_TEMP_C1 0x58B4

typedef struct
{
    unsigned long capid0_a;
    unsigned long capid0_b;
    unsigned long capid0_c;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size;
    unsigned long mad_inter;
    unsigned long mad_intra[2], mad_dimm[2];
} skl_data;

static void setup_skylake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ctrl->userdata = AllocateZeroPool(sizeof(skl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    skl_data *skldata = (skl_data *)ctrl->userdata;

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    MtSupportDebugWriteLine("Intel Skylake chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_SKYLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_CAPID0_A, 4, &skldata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x", skldata->capid0_a);
    MtSupportDebugWriteLine(gBuffer);

    if ((skldata->capid0_a >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_CAPID0_B, 4, &skldata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", skldata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_CAPID0_C, 4, &skldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", skldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    skldata->mad_inter = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_MAD_INTER));
    AsciiSPrint(gBuffer, BUF_SIZE, "MAD_INTER=%08x", skldata->mad_inter);
    MtSupportDebugWriteLine(gBuffer);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=%08x", ch, tc_pre);
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_ODT_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_ODT=%08x", ch, tc_odt);

        skldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_MAD_INTRA_0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_%d=%08x", ch, skldata->mad_intra[ch]);
        skldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_MAD_DIMM_0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_%d=%08x", ch, skldata->mad_dimm[ch]);

        int dimm_l_map = BitExtract(skldata->mad_intra[ch], 0, 0);

        unsigned long long dimm_l_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 5, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 21, 16), 29);

        unsigned int dimm_l_ranks = BitExtract(skldata->mad_dimm[ch], 10, 10) + 1;
        unsigned int dimm_s_ranks = BitExtract(skldata->mad_dimm[ch], 26, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(skldata->mad_dimm[ch], 9, 8) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(skldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;

        if ((skldata->mad_intra[ch] >> 12) & 0x3)
            ctrl->mode = ECC_CORRECT;
    }

    if ((ctrl->mode & ECC_CORRECT) != 0)
    {
        unsigned long errsts;

        pci_conf_read(0, 0, 0, INTEL_SKYLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_SKYLAKE_ERRSTS, 2, 0x03);
    }
}

static void poll_skylake(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;
        ulong capid0;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(0, 0, 0, INTEL_SKYLAKE_CAPID0_A, 4, &capid0);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Get the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_SKYLAKE_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_SKYLAKE_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_SKYLAKE_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_SKYLAKE_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_SKYLAKE_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_SKYLAKE_ERRSTS, 2, 0x03);
    }
}

void inject_skylake(int index, int uncorrectable, int enable)
{
    UINT32 eccdft = 0;
    int num_channels = 3;
    int channel;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_SKYLAKE_CAPID0_A, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - capid0 = %08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCADDRCOMP));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - ECC Addr Comp = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCADDRMASK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - ECC Addr Mask = %08x", val);
    MtSupportDebugWriteLine(gBuffer);

    for (channel = 0; channel < num_channels; channel++)
    {
#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        if (channel == 0)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C0));
        else if (channel == 1)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C1));
        else if (channel == 2)
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - [Channel %d] ECC Inj count = %08x", channel, val);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C0), 0x50);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C1), 0x50);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCINJCOUNT_C2), 0x50);

        if (channel == 0)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C0));
        else if (channel == 1)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C1));
        else if (channel == 2)
            eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C2));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - [Channel %d] eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        eccdft &= 0xFFFFC7FF;

        if (enable == 0)
            eccdft &= ~0x7;
        else if (uncorrectable == 1)
            eccdft |= 0x7;
        else if (uncorrectable == 0)
            eccdft |= 0x3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_skylake - [Channel %d] new eccdft = %08x", channel, eccdft);
        MtSupportDebugWriteLine(gBuffer);

        if (channel == 0)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C0), eccdft);
        else if (channel == 1)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C1), eccdft);
        else if (channel == 2)
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_ECCDFT_C2), eccdft);

        _invdcache();
    }
}

void poll_timings_skylake(struct ecc_info *ctrl)
{
    skl_data *skldata = (skl_data *)ctrl->userdata;

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 5, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 21, 16), 29);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_ODT_C0 + 0x400 * ch));

        unsigned char tCL = BitExtract(tc_odt, 20, 16);
        unsigned char tRCD = BitExtract(tc_pre, 5, 0);
        unsigned char tRAS = BitExtract(tc_pre, 14, 8);
        unsigned char tRP = BitExtract(tc_pre, 5, 0);

        if (tCL < 5 || /* tCL > 31 || */
            tRP < 8 || /* tRP > 63 || */
            tRAS < 28 /* || tRAS > 64 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long sa_perf_status = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = BitExtract(sa_perf_status, 6, 0);
    unsigned int qclk_ref = BitExtract(sa_perf_status, 7, 7);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_skylake - SA_PERF_STATUS=%08x (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);

    if (qclk_ratio == 0)
    {
        unsigned char ddr_type = BitExtract(skldata->mad_inter, 1, 0);

        unsigned char DMFC = 0;
        if (ddr_type == 0) // DDR4
        {
            DMFC = BitExtract(skldata->capid0_c, 19, 17);
        }
        else if (ddr_type == 1) // DDR3
        {
            DMFC = BitExtract(skldata->capid0_b, 6, 4);
        }
        else if (ddr_type == 2) // LPDDR3
        {
            DMFC = BitExtract(skldata->capid0_c, 16, 14);
        }

        switch (DMFC)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
        else // 1: 100.00Mhz
            ctrl->memclk = qclk_ratio * 100 / 2;
    }
}

int poll_temp_skylake(struct ecc_info *ctrl)
{
    int channel;
    for (channel = 0; channel < ctrl->numch; channel++)
    {
        unsigned long dimm_temp;

        dimm_temp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_DDR_DIMM_TEMP_C0 + channel * 4));

        AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_skylake - DDR_DIMM_TEMP[%d]=%08x", channel, dimm_temp);
        MtSupportDebugWriteLine(gBuffer);

        ctrl->dimmtemp[channel * ctrl->numsl] = dimm_temp & 0xff;
        if (ctrl->numsl > 1)
            ctrl->dimmtemp[channel * ctrl->numsl + 1] = (dimm_temp >> 8) & 0xff;
    }
    return 0;
}

/*
 * Kaby Lake memory controller
 *
 * Reference:
 */
#define INTEL_KABYLAKE_MCHBAR 0x48
#define INTEL_KABYLAKE_MCHBAR_HI 0x4C

#define INTEL_KABYLAKE_CAPID0_A 0xE4
#define INTEL_KABYLAKE_CAPID0_B 0xE8
#define INTEL_KABYLAKE_CAPID0_C 0xEC

#define INTEL_KABYLAKE_ERRSTS 0xC8
#define INTEL_KABYLAKE_ERRCMD 0xCA
#define INTEL_KABYLAKE_SMICMD 0xCC
#define INTEL_KABYLAKE_SCICMD 0xCE
#define INTEL_KABYLAKE_PCICMD 0x04

#define INTEL_KABYLAKE_MCHBAR_MAD_INTER 0x5000
#define INTEL_KABYLAKE_MCHBAR_MAD_INTRA_0 0x5004
#define INTEL_KABYLAKE_MCHBAR_MAD_INTRA_1 0x5008
#define INTEL_KABYLAKE_MCHBAR_MAD_DIMM_0 0x500C
#define INTEL_KABYLAKE_MCHBAR_MAD_DIMM_1 0x5010

#define INTEL_KABYLAKE_MCHBAR_ECCDFT_C0 0x4034
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG0_C0 0x4048
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG1_C0 0x404C
#define INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C0 0x4274
#define INTEL_KABYLAKE_MCHBAR_ECCDFT_C1 0x4434
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG0_C1 0x4448
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG1_C1 0x444C
#define INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C1 0x4674
#define INTEL_KABYLAKE_MCHBAR_ECCDFT_C2 0x4C34
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG0_C2 0x4C48
#define INTEL_KABYLAKE_MCHBAR_ECCERRLOG1_C2 0x4C4C
#define INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C2 0x4E74

#define INTEL_KABYLAKE_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_KABYLAKE_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_KABYLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_KABYLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_KABYLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_KABYLAKE_ECCERRLOG1_COL(reg) ((reg >> 17) & 0x07ff)
#define INTEL_KABYLAKE_ECCERRLOG1_ROW(reg) (reg & 0x1ffff)

#define INTEL_KABYLAKE_DDR_DIMM_TEMP_C0 0x58B0
#define INTEL_KABYLAKE_DDR_DIMM_TEMP_C1 0x58B4

static void setup_kabylake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ctrl->userdata = AllocateZeroPool(sizeof(skl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    skl_data *skldata = (skl_data *)ctrl->userdata;

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    MtSupportDebugWriteLine("Intel Kaby Lake chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_KABYLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_CAPID0_A, 4, &skldata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", skldata->capid0_a, (skldata->capid0_a >> 25) & 1 ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    if ((skldata->capid0_a >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        ctrl->cap = ECC_CORRECT;
    }

    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_CAPID0_B, 4, &skldata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", skldata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_CAPID0_C, 4, &skldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", skldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    skldata->mad_inter = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_MAD_INTER));
    AsciiSPrint(gBuffer, BUF_SIZE, "MAD_INTER=%08x", skldata->mad_inter);
    MtSupportDebugWriteLine(gBuffer);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_PRE_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=%08x", ch, tc_pre);
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_SKYLAKE_MCHBAR_TC_ODT_C0 + 0x400 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_ODT=%08x", ch, tc_odt);
        skldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_MAD_INTRA_0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_%d=%08x", ch, skldata->mad_intra[ch]);
        skldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_MAD_DIMM_0 + 4 * ch));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_%d=%08x", ch, skldata->mad_dimm[ch]);

        int dimm_l_map = BitExtract(skldata->mad_intra[ch], 0, 0);

        unsigned long long dimm_l_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 5, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(skldata->mad_dimm[ch], 21, 16), 29);

        unsigned int dimm_l_ranks = BitExtract(skldata->mad_dimm[ch], 10, 10) + 1;
        unsigned int dimm_s_ranks = BitExtract(skldata->mad_dimm[ch], 26, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(skldata->mad_dimm[ch], 9, 8) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(skldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;

        if ((skldata->mad_intra[ch] >> 12) & 0x3)
            ctrl->mode = ECC_CORRECT;
    }

    if ((ctrl->mode & ECC_CORRECT) != 0)
    {
        unsigned long errsts;
        unsigned long errcmd;
        unsigned long smicmd;
        unsigned long scicmd;
        unsigned long pcicmd;

        pci_conf_read(0, 0, 0, INTEL_KABYLAKE_ERRCMD, 2, &errcmd);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRCMD=%04x", errcmd);
        MtSupportDebugWriteLine(gBuffer);

        if ((errcmd & 0x3) != 0)
        {
            errcmd &= ~0x3;
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting ERRCMD=%04x (Disable SERR over DMI)", errcmd);
            MtSupportDebugWriteLine(gBuffer);
            pci_conf_write(0, 0, 0, INTEL_KABYLAKE_ERRCMD, 2, errcmd);
        }

        pci_conf_read(0, 0, 0, INTEL_KABYLAKE_SMICMD, 2, &smicmd);

        AsciiSPrint(gBuffer, BUF_SIZE, "SMICMD=%04x", smicmd);
        MtSupportDebugWriteLine(gBuffer);

        if ((smicmd & 0x3) != 0)
        {
            smicmd &= ~0x3;
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting SMICMD=%04x (Disable SMI over DMI)", smicmd);
            MtSupportDebugWriteLine(gBuffer);
            pci_conf_write(0, 0, 0, INTEL_KABYLAKE_SMICMD, 2, smicmd);
        }

        pci_conf_read(0, 0, 0, INTEL_KABYLAKE_SCICMD, 2, &scicmd);

        AsciiSPrint(gBuffer, BUF_SIZE, "SCICMD=%04x", scicmd);
        MtSupportDebugWriteLine(gBuffer);

        if ((scicmd & 0x3) != 0)
        {
            scicmd &= ~0x3;
            AsciiSPrint(gBuffer, BUF_SIZE, "Setting SCICMD=%04x (Disable SCI over DMI)", scicmd);
            MtSupportDebugWriteLine(gBuffer);
            pci_conf_write(0, 0, 0, INTEL_KABYLAKE_SCICMD, 2, scicmd);
        }

        pci_conf_read(0, 0, 0, INTEL_KABYLAKE_PCICMD, 2, &pcicmd);

        AsciiSPrint(gBuffer, BUF_SIZE, "PCICMD=%04x", pcicmd);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(0, 0, 0, INTEL_KABYLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_KABYLAKE_ERRSTS, 2, 0x03);
    }
}

static void poll_kabylake(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_KABYLAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Get the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_KABYLAKE_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_KABYLAKE_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_KABYLAKE_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_KABYLAKE_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_KABYLAKE_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_KABYLAKE_ERRSTS, 2, 0x03);
    }
}

BOOLEAN inject_kabylake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    UINT32 eccdft = 0;
    int channel;
    int num_channels = 3;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_KABYLAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - capid0 = %08x", capid0);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCADDRCOMP));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - ECC Addr Comp = %08x", val);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCADDRMASK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - ECC Addr Mask = %08x", val);

    for (channel = 0; channel < num_channels; channel++)
    {
#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        const unsigned int MCHBAR_ECCINJCOUNT[] = {INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C0, INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C1, INTEL_KABYLAKE_MCHBAR_ECCINJCOUNT_C2};
        const unsigned int MCHBAR_ECCDFT[] = {INTEL_KABYLAKE_MCHBAR_ECCDFT_C0, INTEL_KABYLAKE_MCHBAR_ECCDFT_C1, INTEL_KABYLAKE_MCHBAR_ECCDFT_C2};

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] ECC Inj count = %08x", channel, val);

        unsigned int newval = enable ? MtSupportReadTSC() % 1024 : 0xFFFFFFFF;
        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]), newval);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]));

        if (val != newval)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] **ERROR** Unable to modify ECC Inj count to %08x", channel, newval);
            ret = FALSE;
        }

        eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] eccdft = %08x", channel, eccdft);

        eccdft &= 0xFFFFFFF8;

        if (enable == 0)
            eccdft &= ~0x7;
        else if (uncorrectable == 1)
            eccdft |= 0x7;
        else if (uncorrectable == 0)
            eccdft |= 0x3;

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] new eccdft = %08x", channel, eccdft);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]), eccdft);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]));

        if (val != eccdft)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] **ERROR** Unable to modify eccdft to %08x", channel, eccdft);
            ret = FALSE;
        }
    }
    return ret;
}

int poll_temp_kabylake(struct ecc_info *ctrl)
{
    int channel;
    for (channel = 0; channel < ctrl->numch; channel++)
    {
        unsigned long dimm_temp;

        dimm_temp = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_KABYLAKE_DDR_DIMM_TEMP_C0 + channel * 4));

        AsciiSPrint(gBuffer, BUF_SIZE, "poll_temp_kabylake - DDR_DIMM_TEMP[%d]=%08x", channel, dimm_temp);
        MtSupportDebugWriteLine(gBuffer);

        ctrl->dimmtemp[channel * ctrl->numsl] = dimm_temp & 0xff;
        if (ctrl->numsl > 1)
            ctrl->dimmtemp[channel * ctrl->numsl + 1] = (dimm_temp >> 8) & 0xff;
    }
    return 0;
}

/*
 * Coffee Lake memory controller
 *
 * Reference:
 */
#define INTEL_COFFEELAKE_MCHBAR 0x48
#define INTEL_COFFEELAKE_MCHBAR_HI 0x4C

#define INTEL_COFFEELAKE_CAPID0_A 0xE4
#define INTEL_COFFEELAKE_CAPID0_B 0xE8
#define INTEL_COFFEELAKE_CAPID0_C 0xEC

#define INTEL_COFFEELAKE_TOM 0xA0
#define INTEL_COFFEELAKE_TOM_H 0xA4
#define INTEL_COFFEELAKE_TOUUD 0xA8
#define INTEL_COFFEELAKE_BDSM 0xB0
#define INTEL_COFFEELAKE_BGSM 0xB4
#define INTEL_COFFEELAKE_TSEGMB 0xB8
#define INTEL_COFFEELAKE_TOLUD 0xBC
#define INTEL_COFFEELAKE_ERRSTS 0xC8

#define INTEL_COFFEELAKE_MCHBAR_INTRA_MAD_0 0x5004
#define INTEL_COFFEELAKE_MCHBAR_INTRA_MAD_1 0x5008

#define INTEL_COFFEELAKE_MCHBAR_TC_PRE(ch) (0x4000 + (ch * 0x400))
#define INTEL_COFFEELAKE_MCHBAR_TC_ODT(ch) (0x4070 + (ch * 0x400))
#define INTEL_COFFEELAKE_MCHBAR_ECCDFT_C0 0x4034
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG0_C0 0x4048
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG1_C0 0x404C
#define INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C0 0x4274
#define INTEL_COFFEELAKE_MCHBAR_ECCDFT_C1 0x4434
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG0_C1 0x4448
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG1_C1 0x444C
#define INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C1 0x4674
#define INTEL_COFFEELAKE_MCHBAR_ECCDFT_C2 0x4C34
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG0_C2 0x4C48
#define INTEL_COFFEELAKE_MCHBAR_ECCERRLOG1_C2 0x4C4C
#define INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C2 0x4E74

#define INTEL_COFFEELAKE_MCHBAR_MAD_INTER_CH 0x5000
#define INTEL_COFFEELAKE_MCHBAR_MAD_INTRA_CH0 0x5004
#define INTEL_COFFEELAKE_MCHBAR_MAD_INTRA_CH1 0x5008
#define INTEL_COFFEELAKE_MCHBAR_MAD_DIMM0 0x500C
#define INTEL_COFFEELAKE_MCHBAR_MAD_DIMM1 0x5010

#define INTEL_COFFEELAKE_MCHBAR_CHANNEL_HASH 0x5024
#define INTEL_COFFEELAKE_MCHBAR_CHANNEL_EHASH 0x5028

#define INTEL_COFFEELAKE_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_COFFEELAKE_MCHBAR_ECCADDRMASK 0x5094

#define INTEL_COFFEELAKE_MCHBAR_MC_LOCK 0x50FC

#define INTEL_COFFEELAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_COFFEELAKE_MCHBAR_MC_BIOS_REQ (0x5E00)

#define INTEL_COFFEELAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_COFFEELAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_COFFEELAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_COFFEELAKE_ECCERRLOG1_COL(reg) ((reg >> 17) & 0x07ff)
#define INTEL_COFFEELAKE_ECCERRLOG1_ROW(reg) (reg & 0x1ffff)

#define INTEL_COFFEELAKE_DDR4 0
#define INTEL_COFFEELAKE_DDR3 1
#define INTEL_COFFEELAKE_LPDDR3 2

typedef struct
{
    unsigned long capid0_b;
    unsigned long capid0_c;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size;
    unsigned long mad_inter_ch;
    unsigned long ch_hash;
    unsigned long ch_ehash;
    unsigned long mad_intra[2], mad_dimm[2];
} cfl_data;

static void setup_coffeelake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    unsigned long tolud, tom_lo, tom_hi;
    unsigned long long tom;

    MtSupportDebugWriteLine("Intel Coffee Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(cfl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    cfl_data *cfldata = (cfl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_COFFEELAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, (capid0 >> 25) & 1 ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_CAPID0_B, 4, &cfldata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", cfldata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_CAPID0_C, 4, &cfldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", cfldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if ((capid0 >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;

        ctrl->cap = ECC_CORRECT;

        mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_INTRA_MAD_0));
        mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_INTRA_MAD_1));

        AsciiSPrint(gBuffer, BUF_SIZE, "INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mad0, mad1);
        MtSupportDebugWriteLine(gBuffer);

        if ((mad0 >> 12) & 0x3 ||
            (mad1 >> 12) & 0x3)
            ctrl->mode = ECC_CORRECT;

        pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_COFFEELAKE_ERRSTS, 2, 0x03);
    }

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    cfldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_TOM_H, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    cfldata->tom = tom;

    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", cfldata->tolud, cfldata->tom);

    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;

    cfldata->mad_inter_ch = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_MAD_INTER_CH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTER_CH=%08x", cfldata->mad_inter_ch);

    ch_s_size = LShiftU64(BitExtract(cfldata->mad_inter_ch, 18, 12), 30);
    ch_l_map = BitExtract(cfldata->mad_inter_ch, 4, 4);

    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch S size=%ld", ch_s_size);
    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch L map=%d", ch_l_map);

    unsigned char ddr_type = BitExtract(cfldata->mad_inter_ch, 1, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "DDR Type %d", ddr_type);

    cfldata->ch_hash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_CHANNEL_HASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_HASH=%08x", cfldata->ch_hash);

    cfldata->ch_ehash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_CHANNEL_EHASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_EHASH=%08x", cfldata->ch_ehash);

    cfldata->ms_total_size = 0;
    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        cfldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_INTRA_MAD_0 + 4 * ch));
        cfldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_MAD_DIMM0 + 4 * ch));

        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_CH%d=%08x", ch, cfldata->mad_intra[ch]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_CH%d=%08x", ch, cfldata->mad_dimm[ch]);

        dimm_l_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 5, 0), 30);
        dimm_s_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 21, 16), 30);
        cfldata->ms_total_size += dimm_l_size;
        cfldata->ms_total_size += dimm_s_size;

        dimm_l_map = BitExtract(cfldata->mad_intra[ch], 0, 0);

        unsigned int dimm_l_ranks = BitExtract(cfldata->mad_dimm[ch], 10, 10) + 1;
        unsigned int dimm_s_ranks = BitExtract(cfldata->mad_dimm[ch], 26, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(cfldata->mad_dimm[ch], 9, 8) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(cfldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;
    }
    AsciiFPrint(DEBUG_FILE_HANDLE, "total size=%ld", cfldata->ms_total_size);
}

static void poll_coffeelake(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_COFFEELAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;
        ulong capid0;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_CAPID0_A, 4, &capid0);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Get the ECC error details
            ECCerrlog0[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCERRLOG0_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCERRLOG0_C1));
            ECCerrlog1[channel] = readmmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCERRLOG1_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCERRLOG1_C1));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_COFFEELAKE_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_COFFEELAKE_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_COFFEELAKE_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_COFFEELAKE_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_COFFEELAKE_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 2 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_COFFEELAKE_ERRSTS, 2, 0x03);
    }
}

BOOLEAN inject_coffeelake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    UINT32 eccdft = 0;
    int channel;
    int num_channels = 3;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_COFFEELAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_MC_LOCK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCADDRCOMP));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - ECC Addr Comp = %08x", val);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCADDRMASK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - ECC Addr Mask = %08x", val);

    for (channel = 0; channel < num_channels; channel++)
    {
        const unsigned int MCHBAR_ECCINJCOUNT[] = {INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C0, INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C1, INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C2};
        const unsigned int MCHBAR_ECCDFT[] = {INTEL_COFFEELAKE_MCHBAR_ECCDFT_C0, INTEL_COFFEELAKE_MCHBAR_ECCDFT_C1, INTEL_COFFEELAKE_MCHBAR_ECCDFT_C2};

#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C0) : (unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - [Channel %d] ECC Inj count = %08x", channel, val);

        unsigned int newval = 0x50;
        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]), newval);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCINJCOUNT[channel]));

        if (val != newval)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - [Channel %d] **ERROR** Unable to modify ECC Inj count to %08x", channel, newval);
            ret = FALSE;
        }

        eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - [Channel %d] eccdft = %08x", channel, eccdft);

        eccdft &= 0xFFFFFFF8;

        if (enable == 0)
            eccdft &= ~0x7;
        else if (uncorrectable == 1)
            eccdft |= 0x7;
        else if (uncorrectable == 0)
            eccdft |= 0x3;

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_coffeelake - [Channel %d] new eccdft = %08x", channel, eccdft);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]), eccdft);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + MCHBAR_ECCDFT[channel]));

        if (val != eccdft)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_kabylake - [Channel %d] **ERROR** Unable to modify eccdft to %08x", channel, eccdft);
            ret = FALSE;
        }
    }
    return ret;
}

void poll_timings_coffeelake(struct ecc_info *ctrl)
{
    cfl_data *cfldata = (cfl_data *)ctrl->userdata;

    unsigned char ddr_type = BitExtract(cfldata->mad_inter_ch, 2, 0);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 5, 0), 30);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 21, 16), 30);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_TC_PRE(ch)));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_TC_ODT(ch)));

        unsigned char tCL = BitExtract(tc_odt, 20, 16);
        unsigned char tRCD = BitExtract(tc_pre, 5, 0);
        unsigned char tRAS = BitExtract(tc_pre, 14, 8);
        unsigned char tRP = BitExtract(tc_pre, 5, 0);

        if (tCL < 5 || /* tCL > 31 || */
            tRP < 8 || /* tRP > 63 || */
            tRAS < 28 /* || tRAS > 64 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long sa_perf_status = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COFFEELAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = BitExtract(sa_perf_status, 6, 0);
    unsigned int qclk_ref = BitExtract(sa_perf_status, 7, 7);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_coffeelake - SA_PERF_STATUS=%08x (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);

    if (qclk_ratio == 0)
    {
        unsigned char DMFC = 0;
        switch (ddr_type)
        {
        case INTEL_COFFEELAKE_DDR4:
            DMFC = BitExtract(cfldata->capid0_c, 19, 17);
            break;

        case INTEL_COFFEELAKE_DDR3:
            DMFC = BitExtract(cfldata->capid0_b, 6, 4);
            break;

        case INTEL_COFFEELAKE_LPDDR3:
            DMFC = BitExtract(cfldata->capid0_c, 16, 14);
            break;
        }

        switch (DMFC)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
        else // 1: 100.00Mhz
            ctrl->memclk = qclk_ratio * 100 / 2;
    }
}

int decode_coffeelake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int ch = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long paddr, ch_addr, dimm_addr, rank_addr;

    int intlv_lsb = 0, hash_mode = 0;
    unsigned long long hash_mask = 0;
    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    int numranks = 1;

    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0, i = 0;

    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;

    cfl_data *cfldata = (cfl_data *)ctrl->userdata;

    if (addr >= cfldata->tom)
        paddr = addr - cfldata->tom + cfldata->tolud;
    else
        paddr = addr;

    ch_s_size = LShiftU64(BitExtract(cfldata->mad_inter_ch, 18, 12), 30); // rkl and up are in 0.5GB multiples, cfl is in 1GB
    ch_l_map = BitExtract(cfldata->mad_inter_ch, 4, 4);

    hash_mode = BitExtract(cfldata->ch_hash, 28, 28);
    intlv_lsb = hash_mode ? (BitExtract(cfldata->ch_hash, 26, 24) + 6) : 6;
    hash_mask = LShiftU64(BitExtract(cfldata->ch_hash, 19, 6), 6);

    // decode channel address
    decode_subaddr(paddr, intlv_lsb, hash_mode, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);

    dimm_s_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 21, 16), 30);
    dimm_l_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 5, 0), 30);
    dimm_l_map = BitExtract(cfldata->mad_intra[ch], 0, 0);

    int maxranks = MAX(BitExtract(cfldata->mad_dimm[ch], 10, 10) + 1, BitExtract(cfldata->mad_dimm[ch], 26, 26) + 1);

    hash_mode = 1;
    if (ctrl->chipwidth[ch * 2] == 16)
    {
        hash_mask = 0x90000; // DIMM mask
        intlv_lsb = 16;
    }
    else
    {
        hash_mask = maxranks >= 2 ? 0x420000 : 0x220000; // DIMM mask
        intlv_lsb = 17;
    }

    // decode DIMM address
    // TODO: check for asymmetric dimm sizes
    decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &dimm, &dimm_addr);

    if (dimm_l_map == dimm)
        numranks = BitExtract(cfldata->mad_dimm[ch], 10, 10) + 1;
    else
        numranks = BitExtract(cfldata->mad_dimm[ch], 26, 26) + 1;

    rank = 0;
    if (numranks > 1)
    {
        hash_mask = 0x88000; // Rank mask
        intlv_lsb = 15;

        decode_subaddr(dimm_addr, intlv_lsb, hash_mode, hash_mask, dimm_l_map == dimm ? dimm_l_size : dimm_s_size, dimm_l_map, &rank, &rank_addr);
    }

    if (ctrl->chipwidth[ch * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[ch * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (esize == 4)
    { // 32 bit error

        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                if (rank == 0)
                    chip = unaligned8 * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    else // 64 bit error
    {
        unsigned long lo = ebits & 0xffffffff;
        unsigned long hi = ebits >> 32;

        for (i = 0; i < numwords; i++)
        {
            if (((lo >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = i;
                else
                    chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                chiperrs++;
            }

            if (((hi >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = numwords + i;
                else
                    chip = rank * numwords * 2 + (numwords - i - 1);

                chiperrs++;
            }
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_cfl - C(%p,%08x,%d,%d,%d)", addr, ebits32, ch, dimm, rank);

    if (pch)
        *pch = ch;
    if (pdimm)
        *pdimm = dimm;
    if (prank)
        *prank = rank;
    if (pchip)
        *pchip = chip;
    if (subaddr)
        *subaddr = dimm_addr;

    return 0;
}
/*
 * Comet Lake memory controller
 *
 * Reference: Comet Lake Processor External Design Specification (EDS), Volume 2 of 2 (Document Number: 606654)
 */
#define INTEL_COMETLAKE_MCHBAR 0x48
#define INTEL_COMETLAKE_MCHBAR_HI 0x4C

#define INTEL_COMETLAKE_CAPID0_A 0xE4
#define INTEL_COMETLAKE_CAPID0_B 0xE8
#define INTEL_COMETLAKE_CAPID0_C 0xEC

#define INTEL_COMETLAKE_TOM 0xA0
#define INTEL_COMETLAKE_TOM_H 0xA4
#define INTEL_COMETLAKE_TOUUD 0xA8
#define INTEL_COMETLAKE_BDSM 0xB0
#define INTEL_COMETLAKE_BGSM 0xB4
#define INTEL_COMETLAKE_TSEGMB 0xB8
#define INTEL_COMETLAKE_TOLUD 0xBC

#define INTEL_COMETLAKE_ERRSTS 0xC8

#define INTEL_COMETLAKE_MCHBAR_MAD_INTER_CH 0x5000
#define INTEL_COMETLAKE_MCHBAR_MAD_INTRA_CH0 0x5004
#define INTEL_COMETLAKE_MCHBAR_MAD_INTRA_CH1 0x5008
#define INTEL_COMETLAKE_MCHBAR_MAD_DIMM0 0x500C
#define INTEL_COMETLAKE_MCHBAR_MAD_DIMM1 0x5010
#define INTEL_COMETLAKE_MCHBAR_CHANNEL_HASH 0x5024
#define INTEL_COMETLAKE_MCHBAR_CHANNEL_EHASH 0x5028

#define INTEL_COMETLAKE_MCHBAR_TC_PRE(ch) (0x4000 + (ch * 0x400))
#define INTEL_COMETLAKE_MCHBAR_TC_ODT(ch) (0x4070 + (ch * 0x400))
#define INTEL_COMETLAKE_MCHBAR_ECCDFT(ch) (0x4034 + (ch * 0x400))
#define INTEL_COMETLAKE_MCHBAR_ECCERRLOG0(ch) (0x4048 + (ch * 0x400))
#define INTEL_COMETLAKE_MCHBAR_ECCERRLOG1(ch) (0x404C + (ch * 0x400))
#define INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT(ch) (0x4274 + (ch * 0x400))

#define INTEL_COMETLAKE_MCHBAR_ECCADDRCOMP 0x5090
#define INTEL_COMETLAKE_MCHBAR_ECCADDRMASK 0x5094
#define INTEL_COMETLAKE_MCHBAR_MC_LOCK 0x50FC

#define INTEL_COMETLAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_COMETLAKE_MCHBAR_MC_BIOS_REQ (0x5E00)

#define INTEL_COMETLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_COMETLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_COMETLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_COMETLAKE_ECCERRLOG1_COL(reg) ((reg >> 17) & 0x07ff)
#define INTEL_COMETLAKE_ECCERRLOG1_ROW(reg) (reg & 0x1ffff)

#define INTEL_COMETLAKE_DDR4 0
#define INTEL_COMETLAKE_DDR3 1
#define INTEL_COMETLAKE_LPDDR3 2
#define INTEL_COMETLAKE_LPDDR4 3

static void setup_cometlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    MtSupportDebugWriteLine("Intel Comet Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(cfl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    cfl_data *cfldata = (cfl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_COMETLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, (capid0 >> 25) & 1 ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if ((capid0 >> 25) & 1)
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;

        ctrl->cap = ECC_CORRECT;

        mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MAD_INTRA_CH0));
        mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MAD_INTRA_CH1));

        AsciiSPrint(gBuffer, BUF_SIZE, "INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mad0, mad1);
        MtSupportDebugWriteLine(gBuffer);

        if ((mad0 >> 12) & 0x3 ||
            (mad1 >> 12) & 0x3)
            ctrl->mode = ECC_CORRECT;

        pci_conf_read(0, 0, 0, INTEL_COMETLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_COMETLAKE_ERRSTS, 2, 0x03);
    }

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_CAPID0_B, 4, &cfldata->capid0_b);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_B=%08x", cfldata->capid0_b);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_CAPID0_C, 4, &cfldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", cfldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    unsigned long tolud, tom_lo, tom_hi;
    unsigned long long tom;

    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    cfldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_TOM_H, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    cfldata->tom = tom;

    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", cfldata->tolud, cfldata->tom);

    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;

    cfldata->mad_inter_ch = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MAD_INTER_CH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTER_CH=%08x", cfldata->mad_inter_ch);

    ch_s_size = LShiftU64(BitExtract(cfldata->mad_inter_ch, 18, 12), 30);
    ch_l_map = BitExtract(cfldata->mad_inter_ch, 4, 4);

    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch S size=%ld", ch_s_size);
    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch L map=%d", ch_l_map);

    unsigned char ddr_type = BitExtract(cfldata->mad_inter_ch, 1, 0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "DDR Type %d", ddr_type);

    cfldata->ch_hash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_CHANNEL_HASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_HASH=%08x", cfldata->ch_hash);

    cfldata->ch_ehash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_CHANNEL_EHASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_EHASH=%08x", cfldata->ch_ehash);

    cfldata->ms_total_size = 0;
    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        cfldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MAD_INTRA_CH0 + 4 * ch));
        cfldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MAD_DIMM0 + 4 * ch));

        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_CH%d=%08x", ch, cfldata->mad_intra[ch]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_CH%d=%08x", ch, cfldata->mad_dimm[ch]);

        dimm_l_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 5, 0), 30);
        dimm_s_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 21, 16), 30);
        cfldata->ms_total_size += dimm_l_size;
        cfldata->ms_total_size += dimm_s_size;

        dimm_l_map = BitExtract(cfldata->mad_intra[ch], 0, 0);

        unsigned int dimm_l_ranks = BitExtract(cfldata->mad_dimm[ch], 10, 10) + 1;
        unsigned int dimm_s_ranks = BitExtract(cfldata->mad_dimm[ch], 26, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(cfldata->mad_dimm[ch], 9, 8) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(cfldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;
    }
    AsciiFPrint(DEBUG_FILE_HANDLE, "total size=%ld", cfldata->ms_total_size);
}

static void poll_cometlake(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long col, row;
    UINT8 bank, rank;
    unsigned long syndrome;
    UINT8 corrected;

    UINT32 ECCerrlog0[2];
    UINT32 ECCerrlog1[2];

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_COMETLAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        UINT8 channel;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            // Get the ECC error details
            ECCerrlog0[channel] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCERRLOG0(channel)));
            ECCerrlog1[channel] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCERRLOG1(channel)));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", channel, ECCerrlog0[channel]);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", channel, ECCerrlog1[channel]);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0[channel] && ECCerrlog1[channel])
            {
                syndrome = INTEL_COMETLAKE_ECCERRLOG0_SYN(ECCerrlog0[channel]);
                col = INTEL_COMETLAKE_ECCERRLOG1_COL(ECCerrlog1[channel]);
                row = INTEL_COMETLAKE_ECCERRLOG1_ROW(ECCerrlog1[channel]);
                bank = INTEL_COMETLAKE_ECCERRLOG0_BANK(ECCerrlog0[channel]);
                rank = INTEL_COMETLAKE_ECCERRLOG0_RANK(ECCerrlog0[channel]);

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, channel, rank < 4 ? 0 : 1);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_COMETLAKE_ERRSTS, 2, 0x03);
    }
}

BOOLEAN inject_cometlake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    UINT32 eccdft = 0;
    int channel;
    unsigned long capid0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_COMETLAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_MC_LOCK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCADDRCOMP));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - ECC Addr Comp = %08x", val);

    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCADDRMASK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - ECC Addr Mask = %08x", val);

    for (channel = 0; channel < ctrl->numch; channel++)
    {
#if 0
        if (uncorrectable < 0)
            writemmio32(channel == 0 ? (unsigned int*)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT_C0) : (unsigned int*)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT_C1), 0xffffffff);
        else
#endif
        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - [Channel %d] ECC Inj count = %08x", channel, val);

        unsigned int newval = 0x50;
        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT(channel)), newval);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCINJCOUNT(channel)));
        if (val != newval)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - [Channel %d] **ERROR** Unable to modify ECC Inj count to %08x", channel, newval);
            ret = FALSE;
        }

        eccdft = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCDFT(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - [Channel %d] eccdft = %08x", channel, eccdft);

        eccdft &= 0xFFFFFFF8;

        if (enable == 0)
            eccdft &= ~0x7;
        else if (uncorrectable == 1)
            eccdft |= 0x7;
        else if (uncorrectable == 0)
            eccdft |= 0x3;

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - [Channel %d] new eccdft = %08x", channel, eccdft);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCDFT(channel)), eccdft);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_ECCDFT(channel)));

        if (val != eccdft)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_cometlake - [Channel %d] **ERROR** Unable to modify eccdft to %08x", channel, eccdft);
            ret = FALSE;
        }
    }
    return ret;
}

void poll_timings_cometlake(struct ecc_info *ctrl)
{
    cfl_data *cfldata = (cfl_data *)ctrl->userdata;

    unsigned char ddr_type = BitExtract(cfldata->mad_inter_ch, 2, 0);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 5, 0), 30);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(cfldata->mad_dimm[ch], 21, 16), 30);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_TC_PRE(ch)));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_TC_ODT(ch)));

        unsigned char tCL = 0;
        unsigned char tRCD = 0;
        unsigned char tRAS = 0;
        unsigned char tRP = 0;

        switch (ddr_type)
        {
        case INTEL_COMETLAKE_DDR3:
        case INTEL_COMETLAKE_DDR4:
        case INTEL_COMETLAKE_LPDDR3:
            tCL = BitExtract(tc_odt, 20, 16);
            tRCD = BitExtract(tc_pre, 5, 0);
            tRAS = BitExtract(tc_pre, 14, 8);
            tRP = BitExtract(tc_pre, 5, 0);

            if (tCL < 5 || /* tCL > 31 || */
                tRP < 8 || /* tRP > 63 || */
                tRAS < 28 /* || tRAS > 64 */)
                continue;

            break;
        case INTEL_COMETLAKE_LPDDR4:
            tCL = BitExtract(tc_odt, 21, 16);
            tRCD = BitExtract(tc_pre, 5, 0);
            tRAS = BitExtract(tc_pre, 15, 9);
            tRP = BitExtract(tc_pre, 5, 0);

            if (tCL < 4 ||  /* tCL > 36 || */
                tRCD < 8 || /* tRCD > 59 || */
                tRP < 8 ||  /* tRP > 59 || */
                tRAS < 28 /* || tRAS > 90 */)
                continue;

            break;
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_cometlake - [Ch %d] TC_PRE=%08x TC_ODT=%08X (%d-%d-%d-%d)", ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;
    }

    unsigned long sa_perf_status = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_COMETLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = BitExtract(sa_perf_status, 6, 0);
    unsigned int qclk_ref = BitExtract(sa_perf_status, 7, 7);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_cometlake - SA_PERF_STATUS=%08x (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);

    if (qclk_ratio == 0)
    {
        unsigned char DMFC = 0;
        switch (ddr_type)
        {
        case INTEL_COMETLAKE_DDR4:
        case INTEL_COMETLAKE_LPDDR4:
            DMFC = BitExtract(cfldata->capid0_c, 19, 17);
            break;

        case INTEL_COMETLAKE_DDR3:
            DMFC = BitExtract(cfldata->capid0_b, 6, 4);
            break;

        case INTEL_COMETLAKE_LPDDR3:
            DMFC = BitExtract(cfldata->capid0_c, 16, 14);
            break;
        }

        switch (DMFC)
        {
        case 0b111:
            ctrl->memclk = 1067;
            break;
        case 0b110:
            ctrl->memclk = 1333;
            break;
        case 0b101:
            ctrl->memclk = 1600;
            break;
        case 0b100:
            ctrl->memclk = 1867;
            break;
        case 0b011:
            ctrl->memclk = 2133;
            break;
        case 0b010:
            ctrl->memclk = 2400;
            break;
        case 0b001:
        case 0b000:
            ctrl->memclk = 2667;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
        else // 1: 100.00Mhz
            ctrl->memclk = qclk_ratio * 100 / 2;
    }
}

/*
 * Rocket Lake memory controller
 *
 * Reference: 11th Generation Intel Core Processor Datasheet Volume 2 of 2 (Doc: 636761)
 */
#define INTEL_ROCKETLAKE_MCHBAR 0x48
#define INTEL_ROCKETLAKE_MCHBAR_HI 0x4C

#define INTEL_ROCKETLAKE_TOM 0xA0
#define INTEL_ROCKETLAKE_TOM_HI 0xA4
#define INTEL_ROCKETLAKE_TOUUD 0xA8
#define INTEL_ROCKETLAKE_TOUUD_HI 0xAC
#define INTEL_ROCKETLAKE_TOLUD 0xBC

#define INTEL_ROCKETLAKE_CAPID0_A 0xE4
#define INTEL_ROCKETLAKE_CAPID0_B 0xE8
#define INTEL_ROCKETLAKE_CAPID0_C 0xEC

#define INTEL_ROCKETLAKE_CAPID0_A_ECCDIS(reg) ((reg >> 25) & 1)
#define INTEL_ROCKETLAKE_CAPID0_A_DDPCD(reg) ((reg >> 14) & 1)
#define INTEL_ROCKETLAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)

#define INTEL_ROCKETLAKE_ERRSTS 0xC8

#define INTEL_ROCKETLAKE_MCHBAR_MAD_INTER_CH 0x5000
#define INTEL_ROCKETLAKE_MCHBAR_MAD_INTRA_CH0 0x5004
#define INTEL_ROCKETLAKE_MCHBAR_MAD_INTRA_CH1 0x5008
#define INTEL_ROCKETLAKE_MCHBAR_MAD_DIMM_CH0 0x500C
#define INTEL_ROCKETLAKE_MCHBAR_MAD_DIMM_CH1 0x5010
#define INTEL_ROCKETLAKE_MCHBAR_CHANNEL_HASH 0x5024
#define INTEL_ROCKETLAKE_MCHBAR_CHANNEL_EHASH 0x5028
#define INTEL_ROCKETLAKE_MCHBAR_REMAPBASE 0x5090
#define INTEL_ROCKETLAKE_MCHBAR_REMAPLIMIT 0x5098

#define INTEL_ROCKETLAKE_MCHBAR_MC_INIT_STATE(ch) (0x4254 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_ECC_DEBUG(ch) (0x4034 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_ECCERRLOG0(ch) (0x4048 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_ECCERRLOG1(ch) (0x404C + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_ECCINJCOUNT(ch) (0x4274 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_ECCADDRCOMP 0x5088
#define INTEL_ROCKETLAKE_MCHBAR_ECCADDRMASK 0x5158
#define INTEL_ROCKETLAKE_MCHBAR_MC_LOCK 0x50FC
#define INTEL_ROCKETLAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_ROCKETLAKE_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_ROCKETLAKE_MCHBAR_MC_BIOS_DATA (0x5E04)
#define INTEL_ROCKETLAKE_MCHBAR_BCLK_FREQ (0x5F60)

#define INTEL_ROCKETLAKE_MCHBAR_TC_PRE(ch) (0x4000 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_TC_ACT(ch) (0x4004 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_TC_ODT(ch) (0x4070 + (ch * 0x400))
#define INTEL_ROCKETLAKE_MCHBAR_SC_GS_CFG(ch) (0x4088 + (ch * 0x400))

#define INTEL_ROCKETLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_ROCKETLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_ROCKETLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_ROCKETLAKE_ECCERRLOG0_CHUNK(reg) ((reg >> 24) & 0x07)
#define INTEL_ROCKETLAKE_ECCERRLOG1_BANKGRP(reg) ((reg >> 29) & 0x03)
#define INTEL_ROCKETLAKE_ECCERRLOG1_COL(reg) ((reg >> 17) & 0x0fff)
#define INTEL_ROCKETLAKE_ECCERRLOG1_ROW(reg) (reg & 0x1ffff)

#define INTEL_ROCKETLAKE_DDR4 0
#define INTEL_ROCKETLAKE_DDR5 1
#define INTEL_ROCKETLAKE_LPDDR5 2
#define INTEL_ROCKETLAKE_LPDDR4 3

typedef struct
{
    unsigned long capid0_c;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size;
    unsigned long mad_inter_ch;
    unsigned long ch_hash;
    unsigned long ch_ehash;
    unsigned long mad_intra[2], mad_dimm[2];
} rkl_data;

static void setup_rocketlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Rocket Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(rkl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    rkl_data *rkldata = (rkl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_ROCKETLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF0000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, INTEL_ROCKETLAKE_CAPID0_A_ECCDIS(capid0) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_ROCKETLAKE_CAPID0_A_ECCDIS(capid0))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;

        ctrl->cap = ECC_CORRECT;

        mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MAD_INTRA_CH0));
        mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MAD_INTRA_CH1));

        AsciiSPrint(gBuffer, BUF_SIZE, "INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mad0, mad1);
        MtSupportDebugWriteLine(gBuffer);

        if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
            (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
            ctrl->mode = ECC_CORRECT;

        pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_ROCKETLAKE_ERRSTS, 2, 0x03);
    }

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_CAPID0_C, 4, &rkldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", rkldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    rkldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    rkldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", rkldata->tolud, rkldata->tom);

    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_REMAPBASE));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPBASE=" I64HEXFMT, remapbase);

    remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_REMAPLIMIT));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPLIMIT=" I64HEXFMT, remaplimit);

    rkldata->ms_total_size = 0;

    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    unsigned long mc_init_state;
    int ch;

    rkldata->mad_inter_ch = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MAD_INTER_CH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTER_CH=%08x", rkldata->mad_inter_ch);

    ch_s_size = LShiftU64(BitExtract(rkldata->mad_inter_ch, 19, 12), 29);
    ch_l_map = BitExtract(rkldata->mad_inter_ch, 4, 4);

    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch S size=%ld", ch_s_size);
    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch L map=%d", ch_l_map);

    unsigned char ddr_type = BitExtract(rkldata->mad_inter_ch, 2, 0);
    if (ddr_type < 2)
    {
        static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5"};
        AsciiFPrint(DEBUG_FILE_HANDLE, "DDR type=%s", DDR_TYPE[ddr_type]);
    }

    rkldata->ch_hash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_CHANNEL_HASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_HASH=%08x", rkldata->ch_hash);

    rkldata->ch_ehash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_CHANNEL_EHASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_EHASH=%08x", rkldata->ch_ehash);

    rkldata->ms_total_size = 0;
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_TC_PRE(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=" I64HEXFMT, ch, tc_pre);
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_TC_ODT(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_ODT=" I64HEXFMT, ch, tc_odt);
        unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_SC_GS_CFG(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] SC_GS_CFG=" I64HEXFMT, ch, sc_gs_cfg);

        mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MC_INIT_STATE(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] MC_INIT_STATE=%08x", ch, mc_init_state);

        rkldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MAD_INTRA_CH0 + 4 * ch));
        rkldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MAD_DIMM_CH0 + 4 * ch));

        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_CH%d=%08x", ch, rkldata->mad_intra[ch]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_CH%d=%08x", ch, rkldata->mad_dimm[ch]);

        dimm_l_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 6, 0), 29);
        dimm_s_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 22, 16), 29);
        dimm_l_map = BitExtract(rkldata->mad_intra[ch], 0, 0);

        rkldata->ms_total_size += dimm_s_size;
        rkldata->ms_total_size += dimm_l_size;

        unsigned int dimm_l_ranks = BitExtract(rkldata->mad_dimm[ch], 10, 9) + 1;
        unsigned int dimm_s_ranks = BitExtract(rkldata->mad_dimm[ch], 27, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(rkldata->mad_dimm[ch], 8, 7) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(rkldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "total size=%ld", rkldata->ms_total_size);
}

static void poll_rocketlake(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ROCKETLAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (UINT8 ch = 0; ch < 2; ch++)
        {
            UINT32 ECCerrlog0;
            UINT32 ECCerrlog1;

            // Get the ECC error details
            ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCERRLOG0(ch)));
            ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCERRLOG1(ch)));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", ch, ECCerrlog0);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", ch, ECCerrlog1);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0 && ECCerrlog1)
            {
                UINT32 col, row;
                UINT8 bank, rank;
                UINT32 syndrome;
                UINT8 slot;
                UINT8 corrected;

                syndrome = INTEL_ROCKETLAKE_ECCERRLOG0_SYN(ECCerrlog0);
                col = INTEL_ROCKETLAKE_ECCERRLOG1_COL(ECCerrlog1);
                row = INTEL_ROCKETLAKE_ECCERRLOG1_ROW(ECCerrlog1);
                bank = INTEL_ROCKETLAKE_ECCERRLOG0_BANK(ECCerrlog0);
                rank = INTEL_ROCKETLAKE_ECCERRLOG0_RANK(ECCerrlog0);

                slot = rank < 4 ? 0 : 1;

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, ch, slot);
            }
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ROCKETLAKE_ERRSTS, 2, 0x0003);
    }
}

BOOLEAN inject_rocketlake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    UINT32 eccdbg = 0;
    int channel;
    unsigned long capid0;
    unsigned int val;
    unsigned long long val64;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_ROCKETLAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MC_LOCK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCADDRCOMP));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - ECC Addr Comp = " I64HEXFMT, val64);

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCADDRMASK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - ECC Addr Mask = " I64HEXFMT, val64);

    for (channel = 0; channel < ctrl->numch; channel++)
    {

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCINJCOUNT(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - [Ch %d] ECC Inj count = %08x", channel, val);

        unsigned int newval = 0x50;
        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCINJCOUNT(channel)), 0x50);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECCINJCOUNT(channel)));

        if (val != newval)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - [Ch %d] **ERROR** Unable to modify ECC Inj count to %08x", channel, newval);
            ret = FALSE;
        }

        eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECC_DEBUG(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - [Ch %d] ECC_DEBUG = %08x", channel, eccdbg);

        eccdbg &= 0xFFFFFFF8;

        // Error Injection Mode (ECC_INJECT):
        // ECC error inject options :
        //  000b : No ECC error injection.
        //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
        //  011b : Inject correctable ECC error on ECC error insertion counter.
        //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
        //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
        if (enable == 0)
            eccdbg &= ~0x7;
        else if (uncorrectable == 1)
            eccdbg |= 0x7;
        else if (uncorrectable == 0)
            eccdbg |= 0x3;

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - [Ch %d] new ECC_DEBUG = %08x", channel, eccdbg);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECC_DEBUG(channel)), eccdbg);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_ECC_DEBUG(channel)));

        if (val != eccdbg)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_rocketlake - [Ch %d] **ERROR** Unable to modify ECC_DEBUG to %08x", channel, eccdbg);
            ret = FALSE;
        }
    }
    return ret;
}

void poll_timings_rocketlake(struct ecc_info *ctrl)
{
    rkl_data *rkldata = (rkl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;

    unsigned char ddr_type = BitExtract(rkldata->mad_inter_ch, 2, 0);
    switch (ddr_type)
    {
    case INTEL_ROCKETLAKE_LPDDR4:
        freq_mult = BitExtract(rkldata->capid0_c, 21, 17);
        break;
    case INTEL_ROCKETLAKE_DDR4:
    default:
        freq_mult = BitExtract(rkldata->capid0_c, 27, 23);
        break;
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - freq_mult=%d", freq_mult);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 6, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 22, 16), 29);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_TC_PRE(ch)));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_TC_ODT(ch)));
        unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_SC_GS_CFG(ch)));

        unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 21, 16);
        unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 5, 0);
        unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 15, 9);
        unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 5, 0);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - [Ch %d] TC_PRE=%08x TC_ODT=%08X (%d-%d-%d-%d)", ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

        if (tCL < 4 ||  /* tCL > 36 || */
            tRCD < 8 || /* tRCD > 59 || */
            tRP < 8 ||  /* tRP > 59 || */
            tRAS < 28 /* || tRAS > 90 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;

        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] SC_GS_CFG=" I64HEXFMT " (GEAR2=%d)", ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31));
        gear_mode = BitExtract(sc_gs_cfg, 31, 31) ? 2 : 1;
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d, GEAR=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8), BitExtract(mc_bios_req, 16, 16));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d, GEAR=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8), BitExtract(mc_bios_data, 16, 16));

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = (unsigned int)BitExtractULL(sa_perf_status, 9, 2);
    unsigned int qclk_ref = (unsigned int)BitExtractULL(sa_perf_status, 10, 10);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ROCKETLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_rocketlake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }
}

int decode_rocketlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int i;
    int ch = -1, subch = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long paddr, ch_addr, subch_addr, dimm_addr, rank_addr;

    int intlv_lsb = 0, hash_mode = 0;
    unsigned long long hash_mask = 0;
    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    unsigned char ehcm, ddr_type;
    int numranks = 1;

    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0;

    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;

    rkl_data *rkldata = (rkl_data *)ctrl->userdata;

    if (addr >= rkldata->tom)
        paddr = addr - rkldata->tom + rkldata->tolud;
    else
        paddr = addr;

    ch_s_size = LShiftU64(BitExtract(rkldata->mad_inter_ch, 19, 12), 29);
    ch_l_map = BitExtract(rkldata->mad_inter_ch, 4, 4);
    ehcm = BitExtract(rkldata->mad_inter_ch, 3, 3);
    ddr_type = BitExtract(rkldata->mad_inter_ch, 2, 0);

    hash_mode = BitExtract(rkldata->ch_hash, 28, 28);
    intlv_lsb = hash_mode ? (BitExtract(rkldata->ch_hash, 26, 24) + 6) : 6;
    hash_mask = LShiftU64(BitExtract(rkldata->ch_hash, 19, 6), 6);

    decode_subaddr(paddr, intlv_lsb, hash_mode, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);

    dimm_l_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 6, 0), 29);
    dimm_s_size = LShiftU64(BitExtract(rkldata->mad_dimm[ch], 22, 16), 29);
    dimm_l_map = BitExtract(rkldata->mad_intra[ch], 0, 0);

    if (ehcm) // LPDDR4x
    {
        hash_mode = BitExtract(rkldata->ch_ehash, 28, 28);
        intlv_lsb = hash_mode ? (BitExtract(rkldata->ch_ehash, 26, 24) + 6) : 6;
        hash_mask = LShiftU64(BitExtract(rkldata->ch_ehash, 19, 6), 6);

        decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &subch, &subch_addr);
    }

    int maxranks = MAX(BitExtract(rkldata->mad_dimm[ch], 10, 9) + 1, BitExtract(rkldata->mad_dimm[ch], 27, 26) + 1);

    hash_mode = 1;

    if (ctrl->chipwidth[ch * 2] == 16)
    {
        hash_mask = 0x90000; // DIMM mask
        intlv_lsb = 16;
    }
    else
    {
        hash_mask = maxranks >= 2 ? 0x420000 : 0x220000; // DIMM mask
        intlv_lsb = 17;
    }
    decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &dimm, &dimm_addr);

    if (dimm_l_map == dimm)
        numranks = BitExtract(rkldata->mad_dimm[ch], 10, 9) + 1;
    else
        numranks = BitExtract(rkldata->mad_dimm[ch], 27, 26) + 1;

    rank = 0;
    if (numranks > 1)
    {
        hash_mode = 1;
        hash_mask = 0x88000; // Rank mask
        intlv_lsb = 15;

        decode_subaddr(dimm_addr, intlv_lsb, hash_mode, hash_mask, dimm_l_map == dimm ? dimm_l_size : dimm_s_size, dimm_l_map, &rank, &rank_addr);
    }

    if (ctrl->chipwidth[ch * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[ch * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (esize == 4)
    { // 32 bit error

        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                if (rank == 0)
                    chip = unaligned8 * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    else // 64 bit error
    {
        unsigned long lo = ebits & 0xffffffff;
        unsigned long hi = ebits >> 32;

        for (i = 0; i < numwords; i++)
        {
            if (((lo >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = i;
                else
                    chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                chiperrs++;
            }

            if (((hi >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = numwords + i;
                else
                    chip = rank * numwords * 2 + (numwords - i - 1);

                chiperrs++;
            }
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_rkl - C(%p,%08x,%d,%d,%d,%d)", addr, ebits32, ch, subch, dimm, rank);

    if (pch)
        *pch = ch;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    if (subaddr)
        *subaddr = dimm_addr;

    return 0;
}

/*
 * Ice Lake memory controller
 *
 * Reference: Ice Lake Processor External Design Specification Volume 2 of 2 (Document Number: 571131)
 */
#define INTEL_ICELAKE_MCHBAR 0x48
#define INTEL_ICELAKE_MCHBAR_HI 0x4C

#define INTEL_ICELAKE_TOM 0xA0
#define INTEL_ICELAKE_TOM_HI 0xA4
#define INTEL_ICELAKE_TOUUD 0xA8
#define INTEL_ICELAKE_TOUUD_HI 0xAC
#define INTEL_ICELAKE_TOLUD 0xBC

#define INTEL_ICELAKE_CAPID0_A 0xE4
#define INTEL_ICELAKE_CAPID0_B 0xE8
#define INTEL_ICELAKE_CAPID0_C 0xEC

#define INTEL_ICELAKE_CAPID0_A_ECCDIS(reg) ((reg >> 25) & 1)
#define INTEL_ICELAKE_CAPID0_A_DDPCD(reg) ((reg >> 14) & 1)
#define INTEL_ICELAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)
#define INTEL_ICELAKE_CAPID0_C_IBECC_EN(reg) ((reg >> 15) & 1)

#define INTEL_ICELAKE_ERRSTS 0xC8

#define INTEL_ICELAKE_MCHBAR_MAD_INTER_CH (0x5000)
#define INTEL_ICELAKE_MCHBAR_MAD_INTRA_CH0 (0x5004)
#define INTEL_ICELAKE_MCHBAR_MAD_INTRA_CH1 (0x5008)
#define INTEL_ICELAKE_MCHBAR_MAD_DIMM_CH0 (0x500C)
#define INTEL_ICELAKE_MCHBAR_MAD_DIMM_CH1 (0x5010)
#define INTEL_ICELAKE_MCHBAR_CHANNEL_HASH (0x5024)
#define INTEL_ICELAKE_MCHBAR_CHANNEL_EHASH (0x5028)
#define INTEL_ICELAKE_MCHBAR_REMAPBASE (0x5090)
#define INTEL_ICELAKE_MCHBAR_REMAPLIMIT (0x5098)

#define INTEL_ICELAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_ICELAKE_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_ICELAKE_MCHBAR_MC_BIOS_DATA (0x5E04)
#define INTEL_ICELAKE_MCHBAR_BCLK_FREQ (0x5F60)

#define INTEL_ICELAKE_MCHBAR_MC_INIT_STATE(ch) (0x4254 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_ECCERRLOG0(ch) (0x4048 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_ECCERRLOG1(ch) (0x404C + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_ECC_INJECT_COUNT(ch) (0x4274 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_ECC_DEBUG(ch) (0x4034 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_ECC_INJ_ADDR_COMPARE (0x5088)
#define INTEL_ICELAKE_MCHBAR_ECC_INJ_ADDR_MASK (0x5158)

#define INTEL_ICELAKE_MCHBAR_TC_PRE(ch) (0x4000 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_TC_ODT(ch) (0x4070 + (ch * 0x400))
#define INTEL_ICELAKE_MCHBAR_SC_GS_CFG(ch) (0x4088 + (ch * 0x400))

#define INTEL_ICELAKE_MCHBAR_MC_LOCK (0x50FC)

#define INTEL_ICELAKE_ECCERRLOG0_SYN(reg) (BitExtract(reg, 23, 16))
#define INTEL_ICELAKE_ECCERRLOG0_BANK(reg) (BitExtract(reg, 31, 29))
#define INTEL_ICELAKE_ECCERRLOG0_RANK(reg) (BitExtract(reg, 28, 27))
#define INTEL_ICELAKE_ECCERRLOG1_COL(reg) (BitExtract(reg, 28, 17))
#define INTEL_ICELAKE_ECCERRLOG1_ROW(reg) (BitExtract(reg, 16, 0))

#define INTEL_ICELAKE_DDR4 0
#define INTEL_ICELAKE_DDR5 1
#define INTEL_ICELAKE_LPDDR5 2
#define INTEL_ICELAKE_LPDDR4 3

typedef struct
{
    unsigned long capid0_c;
    unsigned long capid0_e;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size;
    unsigned long mc_hash;
    unsigned long mad_inter_ch;
    unsigned long ch_hash;
    unsigned long ch_ehash;
    unsigned long mad_intra[2], mad_dimm[2];
} icl_data;

static void setup_icelake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Tiger Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(icl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    icl_data *icldata = (icl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_ICELAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_ICELAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = LShiftU64(BitExtractULL(LShiftU64(mchbar_high, 32) | mchbar_low, 38, 16), 16); // MCHBAR - 38:16

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_ICELAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, INTEL_ICELAKE_CAPID0_A_ECCDIS(capid0) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_CAPID0_C, 4, &icldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", icldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_ICELAKE_CAPID0_A_ECCDIS(capid0))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;

        if (INTEL_ICELAKE_CAPID0_A_ECCDIS(capid0) == 0)
            ctrl->cap |= ECC_CORRECT;

        mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MAD_INTRA_CH0));
        mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MAD_INTRA_CH1));

        AsciiSPrint(gBuffer, BUF_SIZE, "INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mad0, mad1);
        MtSupportDebugWriteLine(gBuffer);

        if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
            (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
            ctrl->mode |= ECC_CORRECT;

        pci_conf_read(0, 0, 0, INTEL_ICELAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_ICELAKE_ERRSTS, 2, errsts);
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    icldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_ICELAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    icldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", icldata->tolud, icldata->tom);

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_ICELAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    icldata->ms_total_size = 0;

    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    unsigned long mc_init_state;
    int ch;
    remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_REMAPBASE));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPBASE=" I64HEXFMT, remapbase);

    remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_REMAPLIMIT));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPLIMIT=" I64HEXFMT, remaplimit);

    icldata->mad_inter_ch = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MAD_INTER_CH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTER_CH=%08x", icldata->mad_inter_ch);

    ch_s_size = LShiftU64(BitExtract(icldata->mad_inter_ch, 19, 12), 29);
    ch_l_map = BitExtract(icldata->mad_inter_ch, 4, 4);

    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch S size=%ld", ch_s_size);
    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch L map=%d", ch_l_map);

    unsigned char ddr_type = BitExtract(icldata->mad_inter_ch, 2, 0);
    if (ddr_type < 4)
    {
        static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"", L"", L"LPDDR4"};
        AsciiFPrint(DEBUG_FILE_HANDLE, "DDR type=%s", DDR_TYPE[ddr_type]);
    }

    icldata->ch_hash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_CHANNEL_HASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_HASH=%08x", icldata->ch_hash);

    icldata->ch_ehash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_CHANNEL_EHASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_EHASH=%08x", icldata->ch_ehash);

    icldata->ms_total_size = 0;
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_TC_PRE(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_PRE=" I64HEXFMT, ch, tc_pre);
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_TC_ODT(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] TC_ODT=" I64HEXFMT, ch, tc_odt);
        unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_SC_GS_CFG(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] SC_GS_CFG=" I64HEXFMT, ch, sc_gs_cfg);

        mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MC_INIT_STATE(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "MC_INIT_STATE=%08x", mc_init_state);

        icldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MAD_INTRA_CH0 + 4 * ch));
        icldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MAD_DIMM_CH0 + 4 * ch));

        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_CH%d=%08x", ch, icldata->mad_intra[ch]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_CH%d=%08x", ch, icldata->mad_dimm[ch]);

        dimm_l_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 6, 0), 29);
        dimm_s_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 22, 16), 29);
        dimm_l_map = BitExtract(icldata->mad_intra[ch], 0, 0);

        icldata->ms_total_size += dimm_s_size;
        icldata->ms_total_size += dimm_l_size;

        unsigned int dimm_l_ranks = BitExtract(icldata->mad_dimm[ch], 10, 9) + 1;
        unsigned int dimm_s_ranks = BitExtract(icldata->mad_dimm[ch], 27, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(icldata->mad_dimm[ch], 8, 7) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(icldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "total size=%ld", icldata->ms_total_size);
}

static void poll_icelake(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_ERRSTS, 2, &errsts);
    if (errsts)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);
    }

    if (errsts & 0x03)
    {
        for (UINT8 ch = 0; ch < 2; ch++)
        {
            UINT32 ECCerrlog0;
            UINT32 ECCerrlog1;

            // Get the ECC error details
            ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECCERRLOG0(ch)));
            ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECCERRLOG1(ch)));

            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG0[%d]=%08x", ch, ECCerrlog0);
            MtSupportDebugWriteLine(gBuffer);
            AsciiSPrint(gBuffer, BUF_SIZE, "ERRLOG1[%d]=%08x", ch, ECCerrlog1);
            MtSupportDebugWriteLine(gBuffer);

            if (ECCerrlog0 && ECCerrlog1)
            {
                UINT32 col, row;
                UINT8 bank, rank;
                UINT32 syndrome;
                UINT8 slot;
                UINT8 corrected;

                syndrome = INTEL_ICELAKE_ECCERRLOG0_SYN(ECCerrlog0);
                col = INTEL_ICELAKE_ECCERRLOG1_COL(ECCerrlog1);
                row = INTEL_ICELAKE_ECCERRLOG1_ROW(ECCerrlog1);
                bank = INTEL_ICELAKE_ECCERRLOG0_BANK(ECCerrlog0);
                rank = INTEL_ICELAKE_ECCERRLOG0_RANK(ECCerrlog0);

                slot = rank < 4 ? 0 : 1;

                /* Parse the error location and error type */
                corrected = (errsts & 0x01) ? 1 : 0;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, ch, slot);
            }
        }
    }

    if (errsts & 0x03)
    {
        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_ERRSTS, 2, errsts);
    }
}

BOOLEAN inject_icelake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    UINT32 eccdbg = 0;
    int channel;
    unsigned long capid0;
    unsigned int val;
    unsigned long long val64;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_ICELAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MC_LOCK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_INJ_ADDR_COMPARE));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - ECC Addr Comp = " I64HEXFMT, val64);

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_INJ_ADDR_MASK));
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - ECC Addr Mask = " I64HEXFMT, val64);

    for (channel = 0; channel < ctrl->numch; channel++)
    {

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_INJECT_COUNT(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - [Ch %d] ECC Inj count = %08x", channel, val);

        unsigned int newval = 0x50;
        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_INJECT_COUNT(channel)), newval);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_INJECT_COUNT(channel)));

        if (val != newval)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - [Ch %d] **ERROR** Unable to modify ECC Inj count to %08x", channel, newval);
            ret = FALSE;
        }

        eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_DEBUG(channel)));

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - [Ch %d] ECC_DEBUG = %08x", channel, eccdbg);

        eccdbg &= 0xFFFFFFF8;

        // Error Injection Mode (ECC_INJECT):
        // ECC error inject options :
        //  000b : No ECC error injection.
        //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
        //  011b : Inject correctable ECC error on ECC error insertion counter.
        //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
        //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
        if (enable == 0)
            eccdbg &= ~0x7;
        else if (uncorrectable == 1)
            eccdbg |= 0x7;
        else if (uncorrectable == 0)
            eccdbg |= 0x3;

        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - [Ch %d] new ECC_DEBUG = %08x", channel, eccdbg);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_DEBUG(channel)), eccdbg);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_ECC_DEBUG(channel)));

        if (val != eccdbg)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_icelake - [Ch %d] **ERROR** Unable to modify ECC_DEBUG to %08x", channel, eccdbg);
            ret = FALSE;
        }
    }
    return ret;
}

int decode_icelake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int i;
    int ch = -1, subch = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long paddr, ch_addr, subch_addr, dimm_addr, rank_addr;

    int intlv_lsb = 0, hash_mode = 0;
    unsigned long long hash_mask = 0;
    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    unsigned char ehcm, ddr_type;
    int numranks = 1;

    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chiperrs = 0;

    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;

    icl_data *icldata = (icl_data *)ctrl->userdata;

    if (addr >= icldata->tom)
        paddr = addr - icldata->tom + icldata->tolud;
    else
        paddr = addr;

    ch_s_size = LShiftU64(BitExtract(icldata->mad_inter_ch, 19, 12), 29);
    ch_l_map = BitExtract(icldata->mad_inter_ch, 4, 4);
    ehcm = BitExtract(icldata->mad_inter_ch, 3, 3);
    ddr_type = BitExtract(icldata->mad_inter_ch, 2, 0);

    hash_mode = BitExtract(icldata->ch_hash, 28, 28);
    intlv_lsb = hash_mode ? (BitExtract(icldata->ch_hash, 26, 24) + 6) : 6;
    hash_mask = LShiftU64(BitExtract(icldata->ch_hash, 19, 6), 6);

    decode_subaddr(paddr, intlv_lsb, hash_mode, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);

    dimm_l_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 6, 0), 29);
    dimm_s_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 22, 16), 29);
    dimm_l_map = BitExtract(icldata->mad_intra[ch], 0, 0);

    if (ehcm) // LPDDR4x
    {
        hash_mode = BitExtract(icldata->ch_ehash, 28, 28);
        intlv_lsb = hash_mode ? (BitExtract(icldata->ch_ehash, 26, 24) + 6) : 6;
        hash_mask = LShiftU64(BitExtract(icldata->ch_ehash, 19, 6), 6);

        decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &subch, &subch_addr);
    }

    int maxranks = MAX(BitExtract(icldata->mad_dimm[ch], 10, 9) + 1, BitExtract(icldata->mad_dimm[ch], 27, 26) + 1);

    hash_mode = 1;

    if (ctrl->chipwidth[ch * 2] == 16)
    {
        hash_mask = 0x90000; // DIMM mask
        intlv_lsb = 16;
    }
    else
    {
        hash_mask = maxranks >= 2 ? 0x420000 : 0x220000; // DIMM mask
        intlv_lsb = 17;
    }
    decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &dimm, &dimm_addr);

    if (dimm_l_map == dimm)
        numranks = BitExtract(icldata->mad_dimm[ch], 10, 9) + 1;
    else
        numranks = BitExtract(icldata->mad_dimm[ch], 27, 26) + 1;

    rank = 0;
    if (numranks > 1)
    {
        hash_mode = 1;
        hash_mask = 0x88000; // Rank mask
        intlv_lsb = 15;

        decode_subaddr(dimm_addr, intlv_lsb, hash_mode, hash_mask, dimm_l_map == dimm ? dimm_l_size : dimm_s_size, dimm_l_map, &rank, &rank_addr);
    }

    if (ctrl->chipwidth[ch * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[ch * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (esize == 4)
    { // 32 bit error

        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                if (rank == 0)
                    chip = unaligned8 * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    else // 64 bit error
    {
        unsigned long lo = ebits & 0xffffffff;
        unsigned long hi = ebits >> 32;

        for (i = 0; i < numwords; i++)
        {
            if (((lo >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = i;
                else
                    chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                chiperrs++;
            }

            if (((hi >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = numwords + i;
                else
                    chip = rank * numwords * 2 + (numwords - i - 1);

                chiperrs++;
            }
        }
    }

    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_icl - C(%p,%08x,%d,%d,%d,%d)", addr, ebits32, ch, subch, dimm, rank);

    if (pch)
        *pch = ch;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    if (subaddr)
        *subaddr = dimm_addr;

    return 0;
}

void poll_timings_icelake(struct ecc_info *ctrl)
{
    icl_data *icldata = (icl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;

    unsigned char ddr_type = BitExtract(icldata->mad_inter_ch, 2, 0);
    switch (ddr_type)
    {
    case INTEL_ICELAKE_LPDDR4:
        freq_mult = BitExtract(icldata->capid0_c, 21, 17);
        break;
    case INTEL_ICELAKE_DDR4:
    default:
        freq_mult = BitExtract(icldata->capid0_c, 27, 23);
        break;
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - freq_mult=%d", freq_mult);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 6, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(icldata->mad_dimm[ch], 22, 16), 29);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_TC_PRE(ch)));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_TC_ODT(ch)));
        unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_SC_GS_CFG(ch)));

        unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 21, 16);
        unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 5, 0);
        unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 15, 9);
        unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 5, 0);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - [Ch %d] TC_PRE=%08x TC_ODT=%08X (%d-%d-%d-%d)", ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

        if (tCL < 4 ||  /* tCL > 36 || */
            tRCD < 8 || /* tRCD > 59 || */
            tRP < 8 ||  /* tRP > 59 || */
            tRAS < 28 /* || tRAS > 90 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;

        AsciiFPrint(DEBUG_FILE_HANDLE, "[Ch%d] SC_GS_CFG=" I64HEXFMT " (GEAR2=%d)", ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31));
        gear_mode = BitExtract(sc_gs_cfg, 31, 31) ? 2 : 1;
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d, GEAR=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8), BitExtract(mc_bios_req, 16, 16));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d, GEAR=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8), BitExtract(mc_bios_data, 16, 16));

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = (unsigned int)BitExtractULL(sa_perf_status, 9, 2);
    unsigned int qclk_ref = (unsigned int)BitExtractULL(sa_perf_status, 10, 10);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ICELAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }
}

/*
 * Tiger Lake memory controller
 *
 * Reference: Tiger Lake H Processor External Design Specification Volume 2b of 2 (Document Number: 616658)
 *            11th Generation Intel Core Processors Datasheet Volume 2 of 2 (Document Number: 636761)
 */
#define INTEL_TIGERLAKE_MCHBAR 0x48
#define INTEL_TIGERLAKE_MCHBAR_HI 0x4C

#define INTEL_TIGERLAKE_TOM 0xA0
#define INTEL_TIGERLAKE_TOM_HI 0xA4
#define INTEL_TIGERLAKE_TOUUD 0xA8
#define INTEL_TIGERLAKE_TOUUD_HI 0xAC
#define INTEL_TIGERLAKE_TOLUD 0xBC

#define INTEL_TIGERLAKE_CAPID0_A 0xE4
#define INTEL_TIGERLAKE_CAPID0_B 0xE8
#define INTEL_TIGERLAKE_CAPID0_C 0xEC
#define INTEL_TIGERLAKE_CAPID0_E 0xF0

#define INTEL_TIGERLAKE_CAPID0_A_ECCDIS(reg) ((reg >> 25) & 1)
#define INTEL_TIGERLAKE_CAPID0_A_DDPCD(reg) ((reg >> 14) & 1)
#define INTEL_TIGERLAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)
#define INTEL_TIGERLAKE_CAPID0_C_IBECC_EN(reg) ((reg >> 15) & 1)

#define INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(reg) ((reg >> 12) & 1)

#define INTEL_TIGERLAKE_ERRSTS 0xC8

#define INTEL_TIGERLAKE_MCHBAR_MC_INIT_STATE(mc) (0x4254 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_MAD_INTER_CH(mc) (0x5000 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_MAD_INTRA_CH0(mc) (0x5004 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_MAD_INTRA_CH1(mc) (0x5008 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_MAD_DIMM_CH0(mc) (0x500C + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_MAD_DIMM_CH1(mc) (0x5010 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_CHANNEL_HASH(mc) (0x5024 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_CHANNEL_EHASH(mc) (0x5028 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_REMAPBASE(mc) (0x5090 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_REMAPLIMIT(mc) (0x5098 + (mc * 0x10000))

#define INTEL_TIGERLAKE_MCHBAR_SA_PERF_STATUS 0x5918
#define INTEL_TIGERLAKE_MCHBAR_MC_BIOS_REQ 0x5E00
#define INTEL_TIGERLAKE_MCHBAR_MC_BIOS_DATA 0x5E04
#define INTEL_TIGERLAKE_MCHBAR_BCLK_FREQ 0x5F60

#define INTEL_TIGERLAKE_MCHBAR_ECCERRLOG0(mc, ch) (0x4048 + (mc * 0x10000) + (ch * 0x400))
#define INTEL_TIGERLAKE_MCHBAR_ECCERRLOG1(mc, ch) (0x404C + (mc * 0x10000) + (ch * 0x400))
#define INTEL_TIGERLAKE_MCHBAR_ECCINJCOUNT(mc, ch) (0x42FC + (mc * 0x10000) + (ch * 0x400))
#define INTEL_TIGERLAKE_MCHBAR_ECCADDRCOMP(mc) (0x5088 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_ECCADDRMASK(mc) (0x5158 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_ECC_DEBUG(mc, ch) (0x4038 + (mc * 0x10000) + (ch * 0x400))

#define INTEL_TIGERLAKE_MCHBAR_TC_PRE(mc, ch) (0x4000 + (mc * 0x10000) + (ch * 0x400))
#define INTEL_TIGERLAKE_MCHBAR_TC_ODT(mc, ch) (0x4070 + (mc * 0x10000) + (ch * 0x400))
#define INTEL_TIGERLAKE_MCHBAR_SC_GS_CFG(mc, ch) (0x4088 + (mc * 0x10000) + (ch * 0x400))

#define INTEL_TIGERLAKE_MCHBAR_MC_LOCK(mc) (0x50FC + (mc * 0x10000))

#define INTEL_TIGERLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_TIGERLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_TIGERLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_TIGERLAKE_ECCERRLOG1_COL(reg) ((reg >> 18) & 0x07ff)
#define INTEL_TIGERLAKE_ECCERRLOG1_ROW(reg) (reg & 0x3ffff)

#define INTEL_TIGERLAKE_MCHBAR_IBECC_ACTIVATE(mc) (0xD400 + (mc * 0x10000))
#define INTEL_TIGERLAKE_IBECC_ACTIVATE_IBECC_EN(reg) (reg & 1)

#define INTEL_TIGERLAKE_MCHBAR_IBECC_STATUS(mc) (0xD404 + (mc * 0x10000))

#define INTEL_TIGERLAKE_MCHBAR_IBECC_ERROR_LOG(mc) (0xD570 + (mc * 0x10000))
#define INTEL_TIGERLAKE_IBECC_ERROR_LOG_MERRSTS (1ULL << 63)
#define INTEL_TIGERLAKE_IBECC_ERROR_LOG_CERRSTS (1ULL << 62)
#define INTEL_TIGERLAKE_IBECC_ERROR_LOG_ERRSYND(reg) (BitExtractULL(reg, 61, 46))
#define INTEL_TIGERLAKE_IBECC_ERROR_LOG_ERRADD(reg) (BitExtractULL(reg, 38, 5))

#define INTEL_TIGERLAKE_MCHBAR_IBECC_INJ_CONTROL(mc) (0xD598 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_IBECCADDRCOMP(mc) (0xD580 + (mc * 0x10000))
#define INTEL_TIGERLAKE_MCHBAR_IBECCADDRMASK(mc) (0xD588 + (mc * 0x10000))

#define INTEL_TIGERLAKE_DDR4 0
#define INTEL_TIGERLAKE_DDR5 1
#define INTEL_TIGERLAKE_LPDDR5 2
#define INTEL_TIGERLAKE_LPDDR4 3

#define INTEL_TIGERLAKE_H_MCHBAR_MAD_INTER_CH(mc) (0xD800 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_MAD_INTRA_CH0(mc) (0xD804 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_MAD_INTRA_CH1(mc) (0xD808 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_MAD_DIMM_CH0(mc) (0xD80C + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_MAD_DIMM_CH1(mc) (0xD810 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_CHANNEL_HASH(mc) (0xD824 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_CHANNEL_EHASH(mc) (0xD828 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_REMAPBASE(mc) (0xD890 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_REMAPLIMIT(mc) (0xD898 + (mc * 0x10000))

#define INTEL_TIGERLAKE_H_MCHBAR_TC_PRE(mc, ch) (0xE000 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_TC_ODT(mc, ch) (0xE070 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_SC_GS_CFG(mc, ch) (0xE088 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_TIGERLAKE_H_MCHBAR_MC_INIT_STATE(mc, ch) (0xE454 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_ECCERRLOG0(mc, ch) (0xE048 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_ECCERRLOG1(mc, ch) (0xE04C + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT(mc, ch) (0xE4FC + (mc * 0x10000) + (ch * 0x800))
#define INTEL_TIGERLAKE_H_MCHBAR_ECCADDRCOMP(mc) (0xD888 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_ECCADDRMASK(mc) (0xD958 + (mc * 0x10000))
#define INTEL_TIGERLAKE_H_MCHBAR_ECC_DEBUG(mc, ch) (0xE038 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_TIGERLAKE_H_MCHBAR_MC_LOCK(mc) (0xD8FC + (mc * 0x10000))

#define INTEL_TIGERLAKE_H_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_TIGERLAKE_H_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_TIGERLAKE_H_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_TIGERLAKE_H_ECCERRLOG1_COL(reg) ((reg >> 18) & 0x07ff)
#define INTEL_TIGERLAKE_H_ECCERRLOG1_ROW(reg) (reg & 0x3ffff)

typedef struct
{
    unsigned long capid0_c;
    unsigned long capid0_e;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size[2];
    unsigned long mc_hash[2];
    unsigned long mad_inter_ch[2];
    unsigned long ch_hash[2];
    unsigned long ch_ehash[2];
    unsigned long mad_intra[4], mad_dimm[4];
} tgl_data;

static void setup_tigerlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Tiger Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(tgl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    tgl_data *tgldata = (tgl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_TIGERLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFC0000ULL; // MCHBAR - 38:17

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_C, 4, &tgldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", tgldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_E, 4, &tgldata->capid0_e);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_E=%08x (IBECC disable: %s)", tgldata->capid0_e, INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e) ? L"yes" : L"no");
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) && INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;
        int mc;

        if (INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) == 0)
            ctrl->cap |= ECC_CORRECT;
        if (INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e) == 0)
            ctrl->cap |= __ECC_INBAND;

        for (mc = 0; mc < 2; mc++)
        {
            mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_INTRA_CH0(mc)));
            mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_INTRA_CH1(mc)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mc, mad0, mad1);
            MtSupportDebugWriteLine(gBuffer);

            if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
                (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
                ctrl->mode |= ECC_CORRECT;

            if (INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e) == 0)
            {
                ulong ibecc_act = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_ACTIVATE(mc)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ACTIVATE=%08x", mc, ibecc_act);
                MtSupportDebugWriteLine(gBuffer);

                if (ibecc_act == 0xffffffff)
                    AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ACTIVATE is invalid");
                if (INTEL_TIGERLAKE_IBECC_ACTIVATE_IBECC_EN(ibecc_act))
                {
                    ulong ibecc_status;
                    unsigned long long errlog;

                    ibecc_status = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_STATUS(mc)));
                    AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] IBECC_STATUS=%08x", mc, ibecc_status);

                    errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ERROR_LOG=" I64HEXFMT, mc, errlog);
                    MtSupportDebugWriteLine(gBuffer);

                    if (errlog != (unsigned long long)-1)
                    {
                        ctrl->mode |= __ECC_INBAND;
                        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] IBECC is enabled", mc);

                        /* Clear the error status */
                        errlog |= INTEL_TIGERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_TIGERLAKE_IBECC_ERROR_LOG_CERRSTS;
                        writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)), errlog);
                    }
                    else
                        AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ERROR_LOG is invalid");
                }
            }
        }

        pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_TIGERLAKE_ERRSTS, 2, errsts);
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    tgldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    tgldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", tgldata->tolud, tgldata->tom);

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    SetMem(tgldata->ms_total_size, sizeof(tgldata->ms_total_size), 0);

    for (int mc = 0; mc < 2; mc++)
    {
        unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
        int ch_l_map = 0, dimm_l_map = 0;
        unsigned long mc_init_state;
        int ch;
#if 0
        tgldata->mc_hash[mc] = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_MC_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_MC_HASH=%08x", mc, tgldata->mc_hash[mc]);

        if (tgldata->mc_hash[mc] == 0xffffffff)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] invalid MAD_MC_HASH - MC may not exist", mc);
            continue;
        }
#endif
        remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_REMAPBASE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPBASE=" I64HEXFMT, mc, remapbase);

        remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_REMAPLIMIT(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPLIMIT=" I64HEXFMT, mc, remaplimit);

        mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_INIT_STATE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MC_INIT_STATE=%08x", mc, mc_init_state);

        tgldata->mad_inter_ch[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_INTER_CH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTER_CH=%08x", mc, tgldata->mad_inter_ch[mc]);

        ch_s_size = LShiftU64(BitExtract(tgldata->mad_inter_ch[mc], 19, 12), 29);
        ch_l_map = BitExtract(tgldata->mad_inter_ch[mc], 4, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch width=x%d", mc, 1 << (BitExtract(tgldata->mad_inter_ch[mc], 28, 27) + 4));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch S size=%ld", mc, ch_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch L map=%d", mc, ch_l_map);

        unsigned char ddr_type = BitExtract(tgldata->mad_inter_ch[mc], 2, 0);
        if (ddr_type < 4)
        {
            static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5", L"LPDDR5", L"LPDDR4"};
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DDR type=%s", mc, DDR_TYPE[ddr_type]);
        }

        tgldata->ch_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_CHANNEL_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_HASH=%08x", mc, tgldata->ch_hash[mc]);

        tgldata->ch_ehash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_CHANNEL_EHASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_EHASH=%08x", mc, tgldata->ch_ehash[mc]);

        tgldata->ms_total_size[mc] = 0;
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_TC_PRE(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_PRE=" I64HEXFMT, mc, ch, tc_pre);
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_TC_ODT(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_ODT=" I64HEXFMT, mc, ch, tc_odt);
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_SC_GS_CFG(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT, mc, ch, sc_gs_cfg);

            tgldata->mad_intra[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_INTRA_CH0(mc) + 4 * ch));
            tgldata->mad_dimm[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_DIMM_CH0(mc) + 4 * ch));

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTRA_CH%d=%08x", mc, ch, tgldata->mad_intra[mc * 2 + ch]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_DIMM_CH%d=%08x", mc, ch, tgldata->mad_dimm[mc * 2 + ch]);

            dimm_l_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            dimm_s_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            dimm_l_map = BitExtract(tgldata->mad_intra[mc * 2 + ch], 0, 0);

            tgldata->ms_total_size[mc] += dimm_s_size;
            tgldata->ms_total_size[mc] += dimm_l_size;

            unsigned int dimm_l_ranks = BitExtract(tgldata->mad_dimm[mc * 2 + ch], 10, 9) + 1;
            unsigned int dimm_s_ranks = BitExtract(tgldata->mad_dimm[mc * 2 + ch], 27, 26) + 1;
            unsigned int dimm_l_chipwidth = 1 << (BitExtract(tgldata->mad_dimm[mc * 2 + ch], 8, 7) + 3);
            unsigned int dimm_s_chipwidth = 1 << (BitExtract(tgldata->mad_dimm[mc * 2 + ch], 25, 24) + 3);

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L size=%ld", mc, ch, dimm_l_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L ranks=%d", mc, ch, dimm_l_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L width=x%d", mc, ch, dimm_l_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S size=%ld", mc, ch, dimm_s_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S ranks=%d", mc, ch, dimm_s_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S width=x%d", mc, ch, dimm_s_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L map=%d", mc, ch, dimm_l_map);

            if (ch == 0)
            {
                ctrl->numranks[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
                ctrl->numranks[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);
            }
            if (dimm_l_size > 0 || dimm_s_size > 0)
                ctrl->chmode++;
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] total size=%ld", mc, tgldata->ms_total_size[mc]);
    }
}

static void setup_tigerlake_h(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Tiger Lake H chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(tgl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    tgl_data *tgldata = (tgl_data *)ctrl->userdata;
    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_TIGERLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFC0000ULL; // MCHBAR - 38:17

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", capid0, INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_E, 4, &tgldata->capid0_e);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_E=%08x (IBECC disable: %s)", tgldata->capid0_e, INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e) ? L"yes" : L"no");
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) && INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;
        UINT8 mc;

        if (INTEL_TIGERLAKE_CAPID0_A_ECCDIS(capid0) == 0)
            ctrl->cap |= ECC_CORRECT;
        if (INTEL_TIGERLAKE_CAPID0_E_IBECC_DIS(tgldata->capid0_e) == 0)
            ctrl->cap |= __ECC_INBAND;

        for (mc = 0; mc < 2; mc++)
        {
            mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MAD_INTRA_CH0(mc)));
            mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MAD_INTRA_CH1(mc)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] MAD_INTRA_CH0=%08x, MAD_INTRA_CH1=%08x", mc, mad0, mad1);
            MtSupportDebugWriteLine(gBuffer);

            if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
                (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
                ctrl->mode = ECC_CORRECT;
        }

        pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_TIGERLAKE_ERRSTS, 2, errsts);
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    tgldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    tgldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", tgldata->tolud, tgldata->tom);

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    SetMem(tgldata->ms_total_size, sizeof(tgldata->ms_total_size), 0);

    for (int mc = 0; mc < 2; mc++)
    {
        unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
        int ch_l_map = 0, dimm_l_map = 0;
        unsigned long mc_init_state;
        int ch;
#if 0
        tgldata->mc_hash[mc] = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MAD_MC_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_MC_HASH=%08x", mc, tgldata->mc_hash[mc]);

        if (tgldata->mc_hash[mc] == 0xffffffff)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] invalid MAD_MC_HASH - MC may not exist", mc);
            continue;
        }
#endif
        remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_REMAPBASE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPBASE=" I64HEXFMT, mc, remapbase);

        remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_REMAPLIMIT(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPLIMIT=" I64HEXFMT, mc, remaplimit);

        tgldata->mad_inter_ch[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MAD_INTER_CH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTER_CH=%08x", mc, tgldata->mad_inter_ch[mc]);

        ch_s_size = LShiftU64(BitExtract(tgldata->mad_inter_ch[mc], 19, 12), 29);
        ch_l_map = BitExtract(tgldata->mad_inter_ch[mc], 4, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch width=x%d", mc, 1 << (BitExtract(tgldata->mad_inter_ch[mc], 28, 27) + 4));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch S size=%ld", mc, ch_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch L map=%d", mc, ch_l_map);

        unsigned char ddr_type = BitExtract(tgldata->mad_inter_ch[mc], 2, 0);
        if (ddr_type < 4)
        {
            static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5", L"LPDDR5", L"LPDDR4"};
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DDR type=%s", mc, DDR_TYPE[ddr_type]);
        }

        tgldata->ch_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_CHANNEL_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_HASH=%08x", mc, tgldata->ch_hash[mc]);

        tgldata->ch_ehash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_CHANNEL_EHASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_EHASH=%08x", mc, tgldata->ch_ehash[mc]);

        tgldata->ms_total_size[mc] = 0;
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_TC_PRE(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_PRE=" I64HEXFMT, mc, ch, tc_pre);
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_TC_ODT(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_ODT=" I64HEXFMT, mc, ch, tc_odt);
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_SC_GS_CFG(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT, mc, ch, sc_gs_cfg);

            mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MC_INIT_STATE(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d MC_INIT_STATE=%08x", mc, ch, mc_init_state);

            tgldata->mad_intra[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MAD_INTRA_CH0(mc) + 4 * ch));
            tgldata->mad_dimm[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MAD_DIMM_CH0(mc) + 4 * ch));

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTRA_CH%d=%08x", mc, ch, tgldata->mad_intra[mc * 2 + ch]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_DIMM_CH%d=%08x", mc, ch, tgldata->mad_dimm[mc * 2 + ch]);

            dimm_l_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            dimm_s_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            dimm_l_map = BitExtract(tgldata->mad_intra[mc * 2 + ch], 0, 0);

            tgldata->ms_total_size[mc] += dimm_s_size;
            tgldata->ms_total_size[mc] += dimm_l_size;

            unsigned int dimm_l_ranks = BitExtract(tgldata->mad_dimm[mc * 2 + ch], 10, 9) + 1;
            unsigned int dimm_s_ranks = BitExtract(tgldata->mad_dimm[mc * 2 + ch], 27, 26) + 1;
            unsigned int dimm_l_chipwidth = 1 << (BitExtract(tgldata->mad_dimm[mc * 2 + ch], 8, 7) + 3);
            unsigned int dimm_s_chipwidth = 1 << (BitExtract(tgldata->mad_dimm[mc * 2 + ch], 25, 24) + 3);

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L size=%ld", mc, ch, dimm_l_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L ranks=%d", mc, ch, dimm_l_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L width=x%d", mc, ch, dimm_l_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S size=%ld", mc, ch, dimm_s_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S ranks=%d", mc, ch, dimm_s_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S width=x%d", mc, ch, dimm_s_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L map=%d", mc, ch, dimm_l_map);

            if (ch == 0)
            {
                ctrl->numranks[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
                ctrl->numranks[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);
            }
            if (dimm_l_size > 0 || dimm_s_size > 0)
                ctrl->chmode++;
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] total size=%ld", mc, tgldata->ms_total_size[mc]);
    }
}

static void poll_tigerlake(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_TIGERLAKE_ERRSTS, 2, &errsts);
    if (errsts)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);
    }

    for (UINT8 mc = 0; mc < 2; mc++)
    {
        if (errsts & 0x03)
        {
            for (UINT8 ch = 0; ch < 2; ch++)
            {
                UINT32 ECCerrlog0;
                UINT32 ECCerrlog1;

                // Get the ECC error details
                ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCERRLOG0(mc, ch)));
                ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCERRLOG1(mc, ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG0[%d]=%08x", mc, ch, ECCerrlog0);
                MtSupportDebugWriteLine(gBuffer);
                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG1[%d]=%08x", mc, ch, ECCerrlog1);
                MtSupportDebugWriteLine(gBuffer);

                if (ECCerrlog0 && ECCerrlog1)
                {
                    UINT32 col, row;
                    UINT8 bank, rank;
                    UINT32 syndrome;
                    UINT8 slot;
                    UINT8 corrected;

                    syndrome = INTEL_TIGERLAKE_ECCERRLOG0_SYN(ECCerrlog0);
                    col = INTEL_TIGERLAKE_ECCERRLOG1_COL(ECCerrlog1);
                    row = INTEL_TIGERLAKE_ECCERRLOG1_ROW(ECCerrlog1);
                    bank = INTEL_TIGERLAKE_ECCERRLOG0_BANK(ECCerrlog0);
                    rank = INTEL_TIGERLAKE_ECCERRLOG0_RANK(ECCerrlog0);

                    slot = rank < 4 ? 0 : 1;

                    /* Parse the error location and error type */
                    corrected = ((errsts >> (mc * 8)) & 0x01) ? 1 : 0;

                    /* Report the error */
                    MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, mc, slot);
                }
            }
        }

        // IBECC errors
        if (ctrl->mode & __ECC_INBAND)
        {
            unsigned long long errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)));
            if ((errlog != (unsigned long long)-1) && // check register is valid
                (errlog & (INTEL_TIGERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_TIGERLAKE_IBECC_ERROR_LOG_CERRSTS)))
            {
                unsigned long long addr;
                UINT32 syndrome;
                UINT8 corrected;

                addr = INTEL_TIGERLAKE_IBECC_ERROR_LOG_ERRADD(errlog);
                syndrome = (int)INTEL_TIGERLAKE_IBECC_ERROR_LOG_ERRSYND(errlog);
                corrected = (errlog & INTEL_TIGERLAKE_IBECC_ERROR_LOG_MERRSTS) == 0;

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ERROR_LOG=" I64HEXFMT " (addr=%p, synd=%04x, corrected=%d)", mc, errlog, (PVOID)addr, syndrome, corrected);
                MtSupportDebugWriteLine(gBuffer);

                /* Report the error */
                MtSupportReportIBECCError((UINTN)addr, corrected, syndrome, -1, -1, -1);

                /* Clear the error status */
                errlog |= INTEL_TIGERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_TIGERLAKE_IBECC_ERROR_LOG_CERRSTS;
                writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)), errlog);
            }
        }
    }

    if (errsts & 0x03)
    {
        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_TIGERLAKE_ERRSTS, 2, errsts);
    }
}

static void poll_tigerlake_h(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_TIGERLAKE_ERRSTS, 2, &errsts);
    if (errsts & 0x03C3)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        for (UINT8 mc = 0; mc < 2; mc++)
        {
            unsigned long mask = (0x03 << (mc * 8));
            if ((errsts & mask) == 0)
                continue;

            for (UINT8 ch = 0; ch < 2; ch++)
            {
                UINT32 ECCerrlog0;
                UINT32 ECCerrlog1;

                // Get the ECC error details
                ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCERRLOG0(mc, ch)));
                ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCERRLOG1(mc, ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG0[%d]=%08x", mc, ch, ECCerrlog0);
                MtSupportDebugWriteLine(gBuffer);
                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG1[%d]=%08x", mc, ch, ECCerrlog1);
                MtSupportDebugWriteLine(gBuffer);

                if (ECCerrlog0 && ECCerrlog1)
                {
                    UINT32 col, row;
                    UINT8 bank, rank;
                    UINT32 syndrome;
                    UINT8 slot;
                    UINT8 corrected;

                    syndrome = INTEL_TIGERLAKE_H_ECCERRLOG0_SYN(ECCerrlog0);
                    col = INTEL_TIGERLAKE_H_ECCERRLOG1_COL(ECCerrlog1);
                    row = INTEL_TIGERLAKE_H_ECCERRLOG1_ROW(ECCerrlog1);
                    bank = INTEL_TIGERLAKE_H_ECCERRLOG0_BANK(ECCerrlog0);
                    rank = INTEL_TIGERLAKE_H_ECCERRLOG0_RANK(ECCerrlog0);

                    slot = rank < 4 ? 0 : 1;

                    /* Parse the error location and error type */
                    corrected = ((errsts >> (mc * 8)) & 0x01) ? 1 : 0;

                    /* Report the error */
                    MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, mc, slot);
                }
            }
        }

        // IBECC errors
        if (errsts & (0x3 << 6))
        {
            UINT8 corrected = (errsts & 0x80) == 0;

            /* Report the error */
            MtSupportReportIBECCError_dimm(-1, -1, -1, -1, corrected, -1, -1, -1, -1);
        }

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_TIGERLAKE_ERRSTS, 2, errsts);
    }
}

BOOLEAN inject_tigerlake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    int mc;
    UINT32 eccdbg = 0;
    unsigned long capid0;
    unsigned int val;
    unsigned long long val64;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    for (mc = 0; mc < 2; mc++)
    {
#if 0
        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_LOCK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");
#endif
        val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCADDRCOMP(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d] ECC Addr Comp = " I64HEXFMT, mc, val64);

        val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCADDRMASK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d] ECC Addr Mask = " I64HEXFMT, mc, val64);

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif

        for (int ch = 0; ch < 2; ch++)
        {
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCINJCOUNT(mc, ch)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d|Ch%d] ECC Inj count = %08x", mc, ch, val);

            unsigned int newval = 0x50;
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCINJCOUNT(mc, ch)), newval);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECCINJCOUNT(mc, ch)));

            if (val != newval)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC Inj count to %08x", mc, ch, newval);
                ret = FALSE;
            }

            eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECC_DEBUG(mc, ch)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d|Ch%d] ECC_DEBUG = %08x", mc, ch, eccdbg);

            eccdbg &= 0xFFFFFFF8;

            // Error Injection Mode (ECC_INJECT):
            // ECC error inject options :
            //  000b : No ECC error injection.
            //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
            //  011b : Inject correctable ECC error on ECC error insertion counter.
            //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
            //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
            if (enable == 0)
                eccdbg &= ~0x7;
            else if (uncorrectable == 1)
                eccdbg |= 0x7;
            else if (uncorrectable == 0)
                eccdbg |= 0x3;

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - new ECC_DEBUG = %08x", eccdbg);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECC_DEBUG(mc, ch)), eccdbg);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_ECC_DEBUG(mc, ch)));

            if (val != eccdbg)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC_DEBUG to %08x", mc, ch, eccdbg);
                ret = FALSE;
            }
        }
    }
    return ret;
}

BOOLEAN inject_tigerlake_h(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    int mc;
    UINT32 eccdbg = 0;
    unsigned long capid0;
    unsigned int val;
    unsigned long long val64;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    pci_conf_read(0, 0, 0, INTEL_TIGERLAKE_CAPID0_A, 4, &capid0);
    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - capid0 = %08x", capid0);

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    for (mc = 0; mc < 2; mc++)
    {
        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_MC_LOCK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");

        val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCADDRCOMP(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d] ECC Addr Comp = " I64HEXFMT, mc, val64);

        val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCADDRMASK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d] ECC Addr Mask = " I64HEXFMT, mc, val64);

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif
        for (int ch = 0; ch < 2; ch++)
        {
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT(mc, ch)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d|Ch%d] ECC Inj count = %08x", mc, ch, val);

            unsigned int newval = 0x50;
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT(mc, ch)), newval);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT(mc, ch)));

            if (val != newval)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d|Ch%d]  **ERROR** Unable to modify ECC Inj count to %08x", mc, ch, newval);
                ret = FALSE;
            }

            eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECC_DEBUG(mc, ch)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d|Ch%d] ECC_DEBUG = %08x", mc, ch, eccdbg);

            eccdbg &= 0xFFFFFFF8;

            // Error Injection Mode (ECC_INJECT):
            // ECC error inject options :
            //  000b : No ECC error injection.
            //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
            //  011b : Inject correctable ECC error on ECC error insertion counter.
            //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
            //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
            if (enable == 0)
                eccdbg &= ~0x7;
            else if (uncorrectable == 1)
                eccdbg |= 0x7;
            else if (uncorrectable == 0)
                eccdbg |= 0x3;

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - new ECC_DEBUG = %08x", eccdbg);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECC_DEBUG(mc, ch)), eccdbg);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_ECCINJCOUNT(mc, ch)));

            if (val != eccdbg)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_tigerlake_h - [MC%d|Ch%d]  **ERROR** Unable to modify ECC_DEBUG to %08x", mc, ch, eccdbg);
                ret = FALSE;
            }
        }
    }
    return ret;
}

void poll_timings_tigerlake(struct ecc_info *ctrl)
{
    tgl_data *tgldata = (tgl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;
    unsigned char ddr_type = INTEL_TIGERLAKE_DDR4;
    for (UINT8 mc = 0; mc < 2; mc++)
    {
        ddr_type = BitExtract(tgldata->mad_inter_ch[mc], 2, 0);
        switch (ddr_type)
        {
        case INTEL_TIGERLAKE_DDR5:
            freq_mult = BitExtract(tgldata->capid0_e, 11, 7);
            break;
        case INTEL_TIGERLAKE_LPDDR5:
            freq_mult = BitExtract(tgldata->capid0_e, 5, 1);
            break;
        case INTEL_TIGERLAKE_DDR4:
            freq_mult = BitExtract(tgldata->capid0_c, 27, 23);
            break;
        case INTEL_TIGERLAKE_LPDDR4:
            freq_mult = BitExtract(tgldata->capid0_c, 21, 17);
            break;
        default:
            continue;
        }
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - [MC%d] freq_mult=%d", mc, freq_mult);

        for (int ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long dimm_l_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            unsigned long long dimm_s_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            unsigned long long ch_size = dimm_l_size + dimm_s_size;

            if (ch_size == 0)
                continue;

            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_TC_PRE(mc, ch)));
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_TC_ODT(mc, ch)));
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_SC_GS_CFG(mc, ch)));

            unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 22, 16);
            unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 47, 41);
            unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 40, 33);
            unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 6, 0);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - [MC%d][Ch %d] TC_PRE=" I64HEXFMT " TC_ODT=" I64HEXFMT " (%d-%d-%d-%d)", mc, ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

            if (tCL < 4 ||  /* tCL > 72 || */
                tRCD < 8 || /* tRCD > 59 || */
                tRP < 8 ||  /* tRP > 60 || */
                tRAS < 28 /* || tRAS > 136 */)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d][Ch %d] SC_GS_CFG=" I64HEXFMT " (GEAR2=%d)", mc, ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31));
            gear_mode = BitExtract(sc_gs_cfg, 31, 31) ? 2 : 1;
        }
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d, GEAR_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8), BitExtract(mc_bios_req, 16, 16));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d, GEAR_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8), BitExtract(mc_bios_data, 16, 16));

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = (unsigned int)BitExtractULL(sa_perf_status, 9, 2);
    unsigned int qclk_ref = (unsigned int)BitExtractULL(sa_perf_status, 10, 10);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }

    if (ddr_type == INTEL_TIGERLAKE_LPDDR5)
    {
        // Once the data transfer rate drops to 3200 Mbps or slower, it is possible to change the CK to WCK ratio from 1:4 to 1:2
        // Timings are in units of WCK for LPDDR5
        unsigned char WCK2tCK = (ctrl->memclk << 1) > 3200 ? 4 : 2;

        ctrl->tAA /= WCK2tCK;
        ctrl->tRCD /= WCK2tCK;
        ctrl->tRAS /= WCK2tCK;
        ctrl->tRP /= WCK2tCK;
    }
}

void poll_timings_tigerlake_h(struct ecc_info *ctrl)
{
    tgl_data *tgldata = (tgl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;
    unsigned char ddr_type = INTEL_TIGERLAKE_DDR4;
    for (UINT8 mc = 0; mc < 2; mc++)
    {
        ddr_type = BitExtract(tgldata->mad_inter_ch[mc], 2, 0);
        switch (ddr_type)
        {
        case INTEL_TIGERLAKE_DDR5:
            freq_mult = BitExtract(tgldata->capid0_e, 11, 7);
            break;
        case INTEL_TIGERLAKE_LPDDR5:
            freq_mult = BitExtract(tgldata->capid0_e, 5, 1);
            break;
        case INTEL_TIGERLAKE_DDR4:
            freq_mult = BitExtract(tgldata->capid0_c, 27, 23);
            break;
        case INTEL_TIGERLAKE_LPDDR4:
            freq_mult = BitExtract(tgldata->capid0_c, 21, 17);
            break;
        default:
            continue;
        }
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - [MC%d] freq_mult=%d", mc, freq_mult);

        for (int ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long dimm_l_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            unsigned long long dimm_s_size = LShiftU64(BitExtract(tgldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            unsigned long long ch_size = dimm_l_size + dimm_s_size;

            if (ch_size == 0)
                continue;

            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_TC_PRE(mc, ch)));
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_TC_ODT(mc, ch)));
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_H_MCHBAR_SC_GS_CFG(mc, ch)));

            unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 22, 16);
            unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 47, 41);
            unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 40, 33);
            unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 6, 0);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - [MC%d][Ch %d] TC_PRE=" I64HEXFMT " TC_ODT=" I64HEXFMT " (%d-%d-%d-%d)", mc, ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

            if (tCL < 4 ||  /* tCL > 72 || */
                tRCD < 8 || /* tRCD > 59 || */
                tRP < 8 ||  /* tRP > 60 || */
                tRAS < 28 /* || tRAS > 136 */)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d][Ch %d] SC_GS_CFG=" I64HEXFMT " (GEAR2=%d)", mc, ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31));
            gear_mode = BitExtract(sc_gs_cfg, 31, 31) ? 2 : 1;
        }
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d, GEAR_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8), BitExtract(mc_bios_req, 16, 16));
    unsigned long mc_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_MC_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - MC_BIOS_DATA=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d, GEAR_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 7, 0), BitExtract(mc_bios_data, 11, 8), BitExtract(mc_bios_data, 16, 16));

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = (unsigned int)BitExtractULL(sa_perf_status, 9, 2);
    unsigned int qclk_ref = (unsigned int)BitExtractULL(sa_perf_status, 10, 10);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_TIGERLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_tigerlake_h - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }

    if (ddr_type == INTEL_TIGERLAKE_LPDDR5)
    {
        // Once the data transfer rate drops to 3200 Mbps or slower, it is possible to change the CK to WCK ratio from 1:4 to 1:2
        // Timings are in units of WCK for LPDDR5
        unsigned char WCK2tCK = (ctrl->memclk << 1) > 3200 ? 4 : 2;

        ctrl->tAA /= WCK2tCK;
        ctrl->tRCD /= WCK2tCK;
        ctrl->tRAS /= WCK2tCK;
        ctrl->tRP /= WCK2tCK;
    }
}
/*
 * Alder Lake memory controller
 *
 * Reference: Alder Lake P/M Processor External Design Specification, Volume 2b of 2 (Document Number: 619503)
 */
#define INTEL_ALDERLAKE_MCHBAR 0x48
#define INTEL_ALDERLAKE_MCHBAR_HI 0x4C

#define INTEL_ALDERLAKE_TOM 0xA0
#define INTEL_ALDERLAKE_TOM_HI 0xA4
#define INTEL_ALDERLAKE_TOUUD 0xA8
#define INTEL_ALDERLAKE_TOUUD_HI 0xAC
#define INTEL_ALDERLAKE_TOLUD 0xBC

#define INTEL_ALDERLAKE_CAPID0_A 0xE4
#define INTEL_ALDERLAKE_CAPID0_B 0xE8
#define INTEL_ALDERLAKE_CAPID0_C 0xEC
#define INTEL_ALDERLAKE_CAPID0_E 0xF0

#define INTEL_ALDERLAKE_CAPID0_A_ECCDIS(reg) ((reg >> 25) & 1)
#define INTEL_ALDERLAKE_CAPID0_A_DDPCD(reg) ((reg >> 14) & 1)
#define INTEL_ALDERLAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)

#define INTEL_ALDERLAKE_CAPID0_E_IBECC_DIS(reg) ((reg >> 12) & 1)

#define INTEL_ALDERLAKE_ERRSTS 0xC8

#define INTEL_ALDERLAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_ALDERLAKE_MCHBAR_MC_BIOS_REQ (0x5E00)
#define INTEL_ALDERLAKE_MCHBAR_MC_BIOS_DATA (0x5E04)
#define INTEL_ALDERLAKE_MCHBAR_BCLK_FREQ (0x5F60)
#define INTEL_ALDERLAKE_MCHBAR_IBECC_ACTIVATE(mc) (0xD400 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_IBECC_ERROR_LOG(mc) (0xD468 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_ADDR_COMPARE(mc) (0xD450 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_ADDR_MASK(mc) (0xD458 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_COUNT(mc) (0xD460 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_CONTROL(mc) (0xD464 + (mc * 0x10000))

#define INTEL_ALDERLAKE_MCHBAR_MAD_INTER_CH(mc) (0xD800 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_MAD_INTRA_CH0(mc) (0xD804 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_MAD_INTRA_CH1(mc) (0xD808 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_MAD_DIMM_CH0(mc) (0xD80C + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_MAD_DIMM_CH1(mc) (0xD810 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_CHANNEL_HASH(mc) (0xD824 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_CHANNEL_EHASH(mc) (0xD828 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_MAD_MC_HASH(mc) (0xD9B8 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_REMAPBASE(mc) (0xD890 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_REMAPLIMIT(mc) (0xD898 + (mc * 0x10000))

#define INTEL_ALDERLAKE_MCHBAR_TC_PRE(mc, ch) (0xE000 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_ALDERLAKE_MCHBAR_TC_ODT(mc, ch) (0xE070 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_ALDERLAKE_MCHBAR_SC_GS_CFG(mc, ch) (0xE088 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_ALDERLAKE_MCHBAR_MC_INIT_STATE(mc) (0xE454 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_ECCERRLOG0(mc, ch) (0xE048 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_ALDERLAKE_MCHBAR_ECCERRLOG1(mc, ch) (0xE04C + (mc * 0x10000) + (ch * 0x800))
#define INTEL_ALDERLAKE_MCHBAR_ECCINJCOUNT(mc, ch) (0xE4FC + (mc * 0x10000) + (ch * 0x800))
#define INTEL_ALDERLAKE_MCHBAR_ECCADDRCOMP(mc) (0xD888 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_ECCADDRMASK(mc) (0xD958 + (mc * 0x10000))
#define INTEL_ALDERLAKE_MCHBAR_ECC_DEBUG(mc, ch) (0xE038 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_ALDERLAKE_MCHBAR_MC_LOCK(mc) (0xD8FC + (mc * 0x10000))

#define INTEL_ALDERLAKE_ECCERRLOG0_SYN(reg) ((reg >> 16) & 0x00ff)
#define INTEL_ALDERLAKE_ECCERRLOG0_BANK(reg) ((reg >> 29) & 0x07)
#define INTEL_ALDERLAKE_ECCERRLOG0_RANK(reg) ((reg >> 27) & 0x03)
#define INTEL_ALDERLAKE_ECCERRLOG1_COL(reg) ((reg >> 18) & 0x07ff)
#define INTEL_ALDERLAKE_ECCERRLOG1_ROW(reg) (reg & 0x3ffff)

#define INTEL_ALDERLAKE_IBECC_ACTIVATE_IBECC_EN(reg) (reg & 1)

#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERRSTS (1ULL << 63)
#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERRSTS (1ULL << 62)
#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_ERRSYND(reg) (BitExtractULL(reg, 61, 46))
#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_ERRADD(reg) (BitExtractULL(reg, 45, 5))

#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW (1 << 4)
#define INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW (1 << 3)

#define INTEL_ALDERLAKE_DDR4 0
#define INTEL_ALDERLAKE_DDR5 1
#define INTEL_ALDERLAKE_LPDDR5 2
#define INTEL_ALDERLAKE_LPDDR4 3

typedef struct
{
    unsigned long capid0_a;
    unsigned long capid0_c;
    unsigned long capid0_e;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size[2];
    unsigned long mc_hash[2];
    unsigned long mad_inter_ch[2];
    unsigned long ch_hash[2];
    unsigned long ch_ehash[2];
    unsigned long mad_intra[4], mad_dimm[4];
} adl_data;

static void setup_alderlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    int mc;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Alder Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(adl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    adl_data *adldata = (adl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_ALDERLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFC0000ULL; // MCHBAR - 38:17

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_CAPID0_A, 4, &adldata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", adldata->capid0_a, INTEL_ALDERLAKE_CAPID0_A_ECCDIS(adldata->capid0_a) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_CAPID0_C, 4, &adldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", adldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_CAPID0_E, 4, &adldata->capid0_e);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_E=%08x (IBECC disable: %s)", adldata->capid0_e, INTEL_ALDERLAKE_CAPID0_E_IBECC_DIS(adldata->capid0_e) ? L"yes" : L"no");
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_ALDERLAKE_CAPID0_A_ECCDIS(adldata->capid0_a) && INTEL_ALDERLAKE_CAPID0_E_IBECC_DIS(adldata->capid0_e))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;
        unsigned long errsts;

        if (INTEL_ALDERLAKE_CAPID0_A_ECCDIS(adldata->capid0_a) == 0)
            ctrl->cap |= ECC_CORRECT;
        if (INTEL_ALDERLAKE_CAPID0_E_IBECC_DIS(adldata->capid0_e) == 0)
            ctrl->cap |= __ECC_INBAND;

        for (mc = 0; mc < 2; mc++)
        {
            mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_INTRA_CH0(mc)));
            mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_INTRA_CH1(mc)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mc, mad0, mad1);
            MtSupportDebugWriteLine(gBuffer);

            if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
                (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
                ctrl->mode = ECC_CORRECT;

            if (INTEL_ALDERLAKE_CAPID0_E_IBECC_DIS(adldata->capid0_e) == 0)
            {
                ulong ibecc_act = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_ACTIVATE(mc)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ACTIVATE=%08x", mc, ibecc_act);
                MtSupportDebugWriteLine(gBuffer);

                if (ibecc_act == 0xffffffff)
                    AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ACTIVATE is invalid");
                if (INTEL_ALDERLAKE_IBECC_ACTIVATE_IBECC_EN(ibecc_act))
                {
                    unsigned long long errlog;

                    errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ERROR_LOG=" I64HEXFMT, mc, errlog);
                    MtSupportDebugWriteLine(gBuffer);

                    if (errlog != (unsigned long long)-1)
                    {
                        ctrl->mode |= __ECC_INBAND;
                        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] IBECC is enabled", mc);

                        /* Clear the error status */
                        errlog |= INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERRSTS | INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW | INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW;
                        writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)), errlog);
                    }
                    else
                        AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ERROR_LOG is invalid");
                }
            }
        }

        pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_ERRSTS, 2, &errsts);

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Clear the error status */
        pci_conf_write(0, 0, 0, INTEL_ALDERLAKE_ERRSTS, 2, errsts);
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    adldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 41, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    adldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", adldata->tolud, adldata->tom);

    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_ALDERLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    SetMem(adldata->ms_total_size, sizeof(adldata->ms_total_size), 0);

    for (mc = 0; mc < 2; mc++)
    {
        unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
        int ch_l_map = 0, dimm_l_map = 0;
        unsigned long mc_init_state;
        int ch;

        adldata->mc_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_MC_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_MC_HASH=%08x", mc, adldata->mc_hash[mc]);

        if (adldata->mc_hash[mc] == 0xffffffff)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] invalid MAD_MC_HASH - MC may not exist", mc);
            continue;
        }

        remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_REMAPBASE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPBASE=" I64HEXFMT, mc, remapbase);

        remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_REMAPLIMIT(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPLIMIT=" I64HEXFMT, mc, remaplimit);

        mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MC_INIT_STATE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MC_INIT_STATE=%08x", mc, mc_init_state);

        adldata->mad_inter_ch[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_INTER_CH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTER_CH=%08x", mc, adldata->mad_inter_ch[mc]);

        ch_s_size = LShiftU64(BitExtract(adldata->mad_inter_ch[mc], 19, 12), 29);
        ch_l_map = BitExtract(adldata->mad_inter_ch[mc], 4, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch width=x%d", mc, 1 << (BitExtract(adldata->mad_inter_ch[mc], 28, 27) + 4));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch S size=%ld", mc, ch_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch L map=%d", mc, ch_l_map);

        unsigned char ddr_type = BitExtract(adldata->mad_inter_ch[mc], 2, 0);
        if (ddr_type < 4)
        {
            static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5", L"LPDDR5", L"LPDDR4"};
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DDR type=%s", mc, DDR_TYPE[ddr_type]);
        }

        adldata->ch_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_CHANNEL_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_HASH=%08x", mc, adldata->ch_hash[mc]);

        adldata->ch_ehash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_CHANNEL_EHASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_EHASH=%08x", mc, adldata->ch_ehash[mc]);

        if (BitExtract(adldata->capid0_a, 12, 12) == 0)
            ctrl->chmode = 2;

        UINT8 chmode = 0;
        adldata->ms_total_size[mc] = 0;
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_TC_PRE(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_PRE=" I64HEXFMT, mc, ch, tc_pre);
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_TC_ODT(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_ODT=" I64HEXFMT, mc, ch, tc_odt);
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_SC_GS_CFG(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT, mc, ch, sc_gs_cfg);

            adldata->mad_intra[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_INTRA_CH0(mc) + 4 * ch));
            adldata->mad_dimm[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_DIMM_CH0(mc) + 4 * ch));

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTRA_CH%d=%08x", mc, ch, adldata->mad_intra[mc * 2 + ch]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_DIMM_CH%d=%08x", mc, ch, adldata->mad_dimm[mc * 2 + ch]);

            dimm_l_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            dimm_s_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            dimm_l_map = BitExtract(adldata->mad_intra[mc * 2 + ch], 0, 0);

            adldata->ms_total_size[mc] += dimm_s_size;
            adldata->ms_total_size[mc] += dimm_l_size;

            unsigned int dimm_l_ranks = BitExtract(adldata->mad_dimm[mc * 2 + ch], 10, 9) + 1;
            unsigned int dimm_s_ranks = BitExtract(adldata->mad_dimm[mc * 2 + ch], 27, 26) + 1;
            unsigned int dimm_l_chipwidth = 1 << (BitExtract(adldata->mad_dimm[mc * 2 + ch], 8, 7) + 3);
            unsigned int dimm_s_chipwidth = 1 << (BitExtract(adldata->mad_dimm[mc * 2 + ch], 25, 24) + 3);

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L size=%ld", mc, ch, dimm_l_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L ranks=%d", mc, ch, dimm_l_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L width=x%d", mc, ch, dimm_l_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S size=%ld", mc, ch, dimm_s_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S ranks=%d", mc, ch, dimm_s_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S width=x%d", mc, ch, dimm_s_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L map=%d", mc, ch, dimm_l_map);

            if (ch == 0)
            {
                ctrl->numranks[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
                ctrl->numranks[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
                ctrl->chipwidth[mc * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);
            }
            if (dimm_l_size > 0 || dimm_s_size > 0)
                chmode++;
        }
        if (chmode > ctrl->chmode)
            ctrl->chmode = chmode;

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] total size=%ld", mc, adldata->ms_total_size[mc]);

#if 0
        if (mc_hash & 1)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MC hash is enabled. Disabling...", mc);
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_MC_HASH(mc)), mc_hash & ~1);

            mc_hash = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MAD_MC_HASH(mc)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] New MAD_MC_HASH=%08x", mc, mc_hash);

        }
#endif
    }
}

static void poll_alderlake(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ALDERLAKE_ERRSTS, 2, &errsts);
    if (errsts)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);
    }
    // ECC errors
    for (UINT8 mc = 0; mc < 2; mc++)
    {
#if 0
        unsigned long mask = (0x03 << (mc * 8));
        if ((errsts & mask) == 0)
            continue;
#endif
        for (UINT8 ch = 0; ch < 2; ch++)
        {
            UINT32 ECCerrlog0;
            UINT32 ECCerrlog1;

            // Get the ECC error details
            ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCERRLOG0(mc, ch)));
            ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCERRLOG1(mc, ch)));
            if (ECCerrlog0 != 0xffffffff && ECCerrlog0 &&
                ECCerrlog1 != 0xffffffff && ECCerrlog1)
            {
                UINT32 col, row;
                UINT8 bank, rank;
                UINT32 syndrome;
                UINT8 slot;
                UINT8 corrected;

                AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] ERRLOG0[%d]=%08x", mc, ch, ECCerrlog0);
                AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] ERRLOG1[%d]=%08x", mc, ch, ECCerrlog1);

                syndrome = INTEL_ALDERLAKE_ECCERRLOG0_SYN(ECCerrlog0);
                col = INTEL_ALDERLAKE_ECCERRLOG1_COL(ECCerrlog1);
                row = INTEL_ALDERLAKE_ECCERRLOG1_ROW(ECCerrlog1);
                bank = INTEL_ALDERLAKE_ECCERRLOG0_BANK(ECCerrlog0);
                rank = INTEL_ALDERLAKE_ECCERRLOG0_RANK(ECCerrlog0);

                slot = rank < 4 ? 0 : 1;

                /* Parse the error location and error type */
                corrected = BitExtract(ECCerrlog0, 2, 2) ? 0 : 1;

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, mc, slot);
            }
        }
    }

    if (ctrl->mode & __ECC_INBAND)
    {
        // IBECC errors
        /*  Bit 7 IBECC Uncorrectable Error(IBECC_UC) :
                This bit is deprecated and kept for backwards compatibility.
                IBECC error messages are logged in the MCA bank.
            Bit 6 IBECC Correctable Error(IBECC_COR) :
                This bit is deprecated and kept for backwards compatibility.
                IBECC error messages are logged in the MCA bank.
        */
        for (int mc = 0; mc < 2; mc++)
        {
            unsigned long long errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)));

            if ((errlog != (unsigned long long)-1) && // check register is valid
                (errlog & (INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERRSTS)))
            {
                unsigned long long addr;
                addr = INTEL_ALDERLAKE_IBECC_ERROR_LOG_ERRADD(errlog);
                UINT32 syndrome = (int)INTEL_ALDERLAKE_IBECC_ERROR_LOG_ERRSYND(errlog);
                BOOLEAN corrected = (errlog & INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERRSTS) == 0;

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] IBECC_ERROR_LOG=" I64HEXFMT " (addr=%p, synd=%04x, corrected=%d)", mc, errlog, (PVOID)addr, syndrome, corrected);
                MtSupportDebugWriteLine(gBuffer);

                /* Report the error */
                MtSupportReportIBECCError((UINTN)addr, corrected, syndrome, -1, -1, -1);

                /* Clear the error status */
                errlog |= INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERRSTS | INTEL_ALDERLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW | INTEL_ALDERLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW;
                writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_ERROR_LOG(mc)), errlog);
            }
        }
    }

    if (errsts & 0x0FFF)
    {
        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ALDERLAKE_ERRSTS, 2, errsts);
    }
}

BOOLEAN inject_alderlake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    int mc, channel;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT

    for (mc = 0; mc < 2; mc++)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - MC Lock = %08x", readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_MC_LOCK(mc))));

        if (ctrl->mode & __ECC_DETECT)
        {
            unsigned long long val;
            val = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCADDRCOMP(mc)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] ECC Addr Comp = " I64HEXFMT, mc, val);

            val = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCADDRMASK(mc)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] ECC Addr Mask = " I64HEXFMT, mc, val);
        }

        if (ctrl->mode & __ECC_INBAND)
        {
            unsigned long long val;
            val = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_ADDR_COMPARE(mc)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] IBECC Addr Comp = " I64HEXFMT, mc, val);

            val = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_ADDR_MASK(mc)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] IBECC Addr Mask = " I64HEXFMT, mc, val);
        }

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            unsigned int val;
            UINT32 eccdbg = 0;
            if (ctrl->mode & __ECC_DETECT)
            {
                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCINJCOUNT(mc, channel)));

                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d|Ch%d] ECC Inj count = %08x", mc, channel, val);

                unsigned int newval = 0x50;
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCINJCOUNT(mc, channel)), newval);

                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECCINJCOUNT(mc, channel)));

                if (val != newval)
                {
                    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC Inj count to %08x", mc, channel, newval);
                    ret = FALSE;
                }

                eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECC_DEBUG(mc, channel)));

                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d|Ch%d] ECC_DEBUG = %08x", mc, channel, eccdbg);
            }

            if ((ctrl->mode & __ECC_INBAND) && channel == 0) // Register shared for both channels
            {
                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_COUNT(mc)));

                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] IBECC Inj count = %08x", mc, val);

                unsigned int newval = 0x50;
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_COUNT(mc)), newval);

                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_COUNT(mc)));

                if (val != newval)
                {
                    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] **ERROR** Unable to modify IBECC Inj count to %08x", mc, newval);
                    ret = FALSE;
                }

                eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_CONTROL(mc)));

                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] IBECC Inj control = %08x", mc, eccdbg);
            }

            // Error Injection Mode (ECC_INJECT):
            // ECC error inject options :
            //  000b : No ECC error injection.
            //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
            //  011b : Inject correctable ECC error on ECC error insertion counter.
            //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
            //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
            eccdbg &= ~7;
            if (enable == 0)
                eccdbg &= ~0x7;
            else if (uncorrectable == 1)
                eccdbg |= 0x7;
            else if (uncorrectable == 0)
                eccdbg |= 0x3;

            if (ctrl->mode & __ECC_DETECT)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d|Ch%d] new ECC_DEBUG = %08x", mc, channel, eccdbg);

                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECC_DEBUG(mc, channel)), eccdbg);

                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_ECC_DEBUG(mc, channel)));

                if (val != eccdbg)
                {
                    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC_DEBUG to %08x", mc, channel, eccdbg);
                    ret = FALSE;
                }
            }

            if ((ctrl->mode & __ECC_INBAND) && channel == 0) // Register shared for both channels
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] new IBECC_INJ_CONTROL = %08x", mc, eccdbg);

                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_CONTROL(mc)), eccdbg);

                val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_IBECC_INJ_CONTROL(mc)));

                if (val != eccdbg)
                {
                    AsciiFPrint(DEBUG_FILE_HANDLE, "inject_alderlake - [MC%d] **ERROR** Unable to modify IBECC_INJ_CONTROL to %08x", mc, eccdbg);
                    ret = FALSE;
                }
            }
        }
    }
    return ret;
}

void poll_timings_alderlake(struct ecc_info *ctrl)

{
    adl_data *adldata = (adl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;
    unsigned char ddr_type = INTEL_ALDERLAKE_LPDDR4;

    for (UINT8 mc = 0; mc < 2; mc++)
    {
        ddr_type = BitExtract(adldata->mad_inter_ch[mc], 2, 0);
        switch (ddr_type)
        {
        case INTEL_ALDERLAKE_DDR5:
            freq_mult = BitExtract(adldata->capid0_e, 11, 7);
            break;
        case INTEL_ALDERLAKE_LPDDR5:
            freq_mult = BitExtract(adldata->capid0_e, 5, 1);
            break;
        case INTEL_ALDERLAKE_DDR4:
            freq_mult = BitExtract(adldata->capid0_c, 27, 23);
            break;
        case INTEL_ALDERLAKE_LPDDR4:
            freq_mult = BitExtract(adldata->capid0_c, 21, 17);
            break;
        default:
            continue;
        }
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_alderlake - [MC%d] freq_mult=%d", mc, freq_mult);

        for (int ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long dimm_l_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            unsigned long long dimm_s_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            unsigned long long ch_size = dimm_l_size + dimm_s_size;

            if (ch_size == 0)
                continue;

            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_TC_PRE(mc, ch)));
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_TC_ODT(mc, ch)));
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_SC_GS_CFG(mc, ch)));

            unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 22, 16);
            unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 58, 51);
            unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 50, 42);
            unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 7, 0);

            if (tCL < 4 ||  /* tCL > 72 || */
                tRCD < 8 || /* tRCD > 59 || */
                tRP < 8 ||  /* tRP > 60 || */
                tRAS < 28 /* || tRAS > 136 */)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT " (GEAR2=%d GEAR4=%d)", mc, ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31), BitExtract(sc_gs_cfg, 15, 15));
            gear_mode = BitExtract(sc_gs_cfg, 15, 15) ? 4 : BitExtract(sc_gs_cfg, 31, 31) ? 2
                                                                                          : 1;
        }
    }

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_SA_PERF_STATUS));
    unsigned int qclk_ratio = (unsigned int)BitExtractULL(sa_perf_status, 9, 2);
    unsigned int qclk_ref = (unsigned int)BitExtractULL(sa_perf_status, 10, 10);
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_alderlake - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, qclk_ratio, qclk_ref);
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ALDERLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_alderlake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_alderlake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }

    if (ddr_type == INTEL_ALDERLAKE_LPDDR5)
    {
        // Once the data transfer rate drops to 3200 Mbps or slower, it is possible to change the CK to WCK ratio from 1:4 to 1:2
        // Timings are in units of WCK for LPDDR5
        unsigned char WCK2tCK = (ctrl->memclk << 1) > 3200 ? 4 : 2;

        ctrl->tAA /= WCK2tCK;
        ctrl->tRCD /= WCK2tCK;
        ctrl->tRAS /= WCK2tCK;
        ctrl->tRP /= WCK2tCK;
    }
}

int decode_alderlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int i;
    int mc = -1, ch = -1, subch = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long paddr, imc_addr, ch_addr, subch_addr, dimm_addr, rank_addr;

    int intlv_lsb = 0, hash_mode = 0;
    unsigned long long hash_mask = 0;
    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ms_l_map = 0, ch_l_map = 0, dimm_l_map = 0;
    unsigned char ddr_type;
    int numranks = 1;

    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chipwidth = 8;
    int numwords;
    unsigned long wordmask;
    int chiperrs = 0;

    adl_data *adldata = (adl_data *)ctrl->userdata;

    if (addr >= adldata->tom)
        paddr = addr - adldata->tom + adldata->tolud;
    else
        paddr = addr;

    ms_l_map = adldata->ms_total_size[0] < adldata->ms_total_size[1] ? 1 : 0;

    hash_mask = 0x82600;
    if (adldata->mc_hash[0] != 0xffffffff)
    {
        hash_mode = BitExtract(adldata->mc_hash[0], 0, 0);
        intlv_lsb = BitExtract(adldata->mc_hash[0], 3, 1) + 6;
    }
    else
    {
        hash_mode = BitExtract(adldata->mc_hash[1], 0, 0);
        intlv_lsb = BitExtract(adldata->mc_hash[1], 3, 1) + 6;
    }
    decode_subaddr(paddr, intlv_lsb, hash_mode, hash_mask, ms_l_map ? adldata->ms_total_size[0] : adldata->ms_total_size[1], ms_l_map, &mc, &imc_addr);

    ch_s_size = LShiftU64(BitExtract(adldata->mad_inter_ch[mc], 19, 12), 29);
    ch_l_map = BitExtract(adldata->mad_inter_ch[mc], 4, 4);
    ddr_type = BitExtract(adldata->mad_inter_ch[mc], 2, 0);

    hash_mode = BitExtract(adldata->ch_hash[mc], 28, 28);
    intlv_lsb = hash_mode ? (BitExtract(adldata->ch_hash[mc], 26, 24) + 6) : 6;
    hash_mask = LShiftU64(BitExtract(adldata->ch_hash[mc], 19, 6), 6);

    decode_subaddr(imc_addr, intlv_lsb, hash_mode, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);

    dimm_l_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
    dimm_s_size = LShiftU64(BitExtract(adldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
    dimm_l_map = BitExtract(adldata->mad_intra[mc * 2 + ch], 0, 0);

    if (ddr_type == INTEL_ALDERLAKE_LPDDR5) // LPDDR5
    {
        hash_mode = BitExtract(adldata->ch_ehash[mc], 28, 28);
        intlv_lsb = hash_mode ? (BitExtract(adldata->ch_ehash[mc], 26, 24) + 6) : 6;
        hash_mask = LShiftU64(BitExtract(adldata->ch_ehash[mc], 19, 6), 6);

        decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &subch, &subch_addr);
    }

    int ddr5 = (ddr_type == INTEL_ALDERLAKE_DDR5 || ddr_type == INTEL_ALDERLAKE_LPDDR5);
    int maxranks = MAX(BitExtract(adldata->mad_dimm[mc * 2 + ch], 10, 9) + 1, BitExtract(adldata->mad_dimm[mc * 2 + ch], 27, 26) + 1);

    hash_mode = 1;
    if (ddr5)
    {
        hash_mask = 0x820000;
        intlv_lsb = 17;
    }
    else
    {
        if (ctrl->chipwidth[mc * 2] == 16)
        {
            hash_mask = 0x90000; // DIMM mask
            intlv_lsb = 16;
        }
        else
        {
            hash_mask = maxranks >= 2 ? 0x420000 : 0x220000;
            intlv_lsb = 17;
        }
    }
    decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &dimm, &dimm_addr);

    if (dimm_l_map == dimm)
        numranks = BitExtract(adldata->mad_dimm[mc * 2 + ch], 10, 9) + 1;
    else
        numranks = BitExtract(adldata->mad_dimm[mc * 2 + ch], 27, 26) + 1;

    rank = 0;
    if (numranks > 1)
    {
        hash_mode = 1;
        intlv_lsb = 15;
        hash_mask = ddr5 ? 0x208000 : 0x88000; // Rank uses hash value from rocketlake when decoding DDR4

        decode_subaddr(dimm_addr, intlv_lsb, hash_mode, hash_mask, dimm_l_map == dimm ? dimm_l_size : dimm_s_size, dimm_l_map, &rank, &rank_addr);
    }

    if (ctrl->chipwidth[mc * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[mc * 2 + dimm];
    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (ddr5)
    {
        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = ch * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - ch) * numwords + (numwords - i - 1);

                chiperrs++;
            }
        }
    }
    else // DDR4
    {
        if (esize == 4)
        { // 32 bit error

            for (i = 0; i < numwords; i++)
            {
                if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                {
                    int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                    if (rank == 0)
                        chip = unaligned8 * numwords + i;
                    else
                        chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                    chiperrs++;
                }
            }
        }
        else // 64 bit error
        {
            unsigned long lo = ebits & 0xffffffff;
            unsigned long hi = ebits >> 32;

            for (i = 0; i < numwords; i++)
            {
                if (((lo >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (rank == 0)
                        chip = i;
                    else
                        chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                    chiperrs++;
                }

                if (((hi >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (rank == 0)
                        chip = numwords + i;
                    else
                        chip = rank * numwords * 2 + (numwords - i - 1);

                    chiperrs++;
                }
            }
        }
    }
    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_adl - C(%p,%08x,%d,%d,%d,%d,%d)", addr, ebits32, mc, ch, subch, dimm, rank);

    if (pch)
        *pch = mc;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    if (subaddr)
        *subaddr = dimm_addr;

    return 0;
}

/*
 * Meteor Lake memory controller
 *
 * Reference: Meteor Lake U/H and U Type4 External Design Specification (EDS) Volume 2 of 2 (Document Number: 657165)
 */
#define INTEL_METEORLAKE_MCHBAR 0x48
#define INTEL_METEORLAKE_MCHBAR_HI 0x4C

#define INTEL_METEORLAKE_TOM 0xA0
#define INTEL_METEORLAKE_TOM_HI 0xA4
#define INTEL_METEORLAKE_TOUUD 0xA8
#define INTEL_METEORLAKE_TOUUD_HI 0xAC
#define INTEL_METEORLAKE_TOLUD 0xBC

#define INTEL_METEORLAKE_CAPID0_A 0xE4
#define INTEL_METEORLAKE_CAPID0_B 0xE8
#define INTEL_METEORLAKE_CAPID0_C 0xEC
#define INTEL_METEORLAKE_CAPID0_E 0xF0

#define INTEL_METEORLAKE_CAPID0_A_ECCDIS(reg) ((reg >> 25) & 1)
#define INTEL_METEORLAKE_CAPID0_A_DDPCD(reg) ((reg >> 14) & 1)
#define INTEL_METEORLAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)

#define INTEL_METEORLAKE_CAPID0_E_IBECC_DIS(reg) ((reg >> 18) & 1)

#define INTEL_METEORLAKE_MCHBAR_SA_PERF_STATUS (0x5918)
#define INTEL_METEORLAKE_MCHBAR_BCLK_FREQ (0x5F60)
#define INTEL_METEORLAKE_MCHBAR_MAD_INTER_CH(mc) (0xD800 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_MAD_INTRA_CH0(mc) (0xD804 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_MAD_INTRA_CH1(mc) (0xD808 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_MAD_DIMM_CH0(mc) (0xD80C + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_MAD_DIMM_CH1(mc) (0xD810 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_CHANNEL_HASH(mc) (0xD824 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_CHANNEL_EHASH(mc) (0xD828 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_MAD_MC_HASH(mc) (0xD9B8 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_REMAPBASE(mc) (0xD890 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_REMAPLIMIT(mc) (0xD898 + (mc * 0x10000))

#define INTEL_METEORLAKE_MCHBAR_TC_PRE(mc, ch) (0xE000 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_TC_RDRD(mc, ch) (0xE00C + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_TC_CAS(mc, ch) (0xE070 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_SC_GS_CFG(mc, ch) (0xE088 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_TC_ACT(mc, ch) (0xE138 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_METEORLAKE_MCHBAR_ECCERRLOG0(mc, ch) (0xE048 + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_ECCERRLOG1(mc, ch) (0xE04C + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_ECC_INJECT_COUNT(mc, ch) (0xE4FC + (mc * 0x10000) + (ch * 0x800))
#define INTEL_METEORLAKE_MCHBAR_ECC_INJ_ADDR_COMPARE(mc) (0xD888 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_ECC_INJ_ADDR_MASK(mc) (0xD958 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_ECC_DEBUG(mc, ch) (0xE038 + (mc * 0x10000) + (ch * 0x800))

#define INTEL_METEORLAKE_MCHBAR_MC_LOCK(mc) (0xD8FC + (mc * 0x10000))

#define INTEL_METEORLAKE_ECCERRLOG0_SYN(reg) (BitExtract(reg, 23, 16))
#define INTEL_METEORLAKE_ECCERRLOG0_BANK(reg) (BitExtract(reg, 31, 29))
#define INTEL_METEORLAKE_ECCERRLOG0_RANK(reg) (BitExtract(reg, 28, 27))
#define INTEL_METEORLAKE_ECCERRLOG0_MERR_OVERFLOW(reg) (BitExtract(reg, 3, 3))
#define INTEL_METEORLAKE_ECCERRLOG0_MERRSTS(reg) (BitExtract(reg, 2, 2))
#define INTEL_METEORLAKE_ECCERRLOG0_CERR_OVERFLOW(reg) (BitExtract(reg, 1, 1))
#define INTEL_METEORLAKE_ECCERRLOG0_CERRSTS(reg) (BitExtract(reg, 0, 0))

#define INTEL_METEORLAKE_ECCERRLOG1_COL(reg) (BitExtract(reg, 25, 18))
#define INTEL_METEORLAKE_ECCERRLOG1_ROW(reg) (BitExtract(reg, 17, 0))

#define INTEL_METEORLAKE_MCHBAR_IBECC_ACTIVATE 0xD400
#define INTEL_METEORLAKE_IBECC_ACTIVATE_IBECC_EN(reg) (reg & 1)

#define INTEL_METEORLAKE_MCHBAR_IBECC_ERROR_LOG 0xD570
#define INTEL_METEORLAKE_IBECC_ERROR_LOG_MERRSTS (1ULL << 63)
#define INTEL_METEORLAKE_IBECC_ERROR_LOG_CERRSTS (1ULL << 62)
#define INTEL_METEORLAKE_IBECC_ERROR_LOG_ERRSYND(reg) (BitExtractULL(reg, 61, 46))
#define INTEL_METEORLAKE_IBECC_ERROR_LOG_ERRADD(reg) (BitExtractULL(reg, 38, 5))

#define INTEL_METEORLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW (1 << 4)
#define INTEL_METEORLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW (1 << 3)

#define INTEL_METEORLAKE_MCHBAR_IBECC_INJ_CONTROL(mc) (0xD598 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_IBECC_INJ_ADDR_MASK(mc) (0xD580 + (mc * 0x10000))
#define INTEL_METEORLAKE_MCHBAR_IBECC_INJ_ADDR_BASE(mc) (0xD588 + (mc * 0x10000))

#define INTEL_METEORLAKE_MCHBAR_MEMSS_PMA_CR_BIOS_REQ 0x13d08
#define INTEL_METEORLAKE_MCHBAR_MEMSS_PMA_CR_BIOS_DATA 0x13d10

#define INTEL_METEORLAKE_DDR4 0
#define INTEL_METEORLAKE_DDR5 1
#define INTEL_METEORLAKE_LPDDR5 2
#define INTEL_METEORLAKE_LPDDR4 3

typedef struct
{
    unsigned long capid0_a;
    unsigned long capid0_b;
    unsigned long capid0_c;
    unsigned long capid0_e;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size[2];
    unsigned long mc_hash[2];
    unsigned long mad_inter_ch[2];
    unsigned long ch_hash[2];
    unsigned long ch_ehash[2];
    unsigned long mad_intra[4], mad_dimm[4];
} mtl_data;

static void setup_meteorlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong ibecc_act;
    int mc;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Meteor Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(mtl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    mtl_data *mtldata = (mtl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_METEORLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = LShiftU64(BitExtractULL(LShiftU64(mchbar_high, 32) | mchbar_low, 41, 17), 17); // MCHBAR - 41:17

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_CAPID0_A, 4, &mtldata->capid0_a);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x (ECC capable: %s)", mtldata->capid0_a, INTEL_METEORLAKE_CAPID0_A_ECCDIS(mtldata->capid0_a) ? L"no" : L"yes");
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_CAPID0_B, 4, &mtldata->capid0_b);

    AsciiFPrint(DEBUG_FILE_HANDLE, "CAPID0_B=%08x", mtldata->capid0_b);

    ctrl->cap = ECC_NONE;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    if (INTEL_METEORLAKE_CAPID0_A_ECCDIS(mtldata->capid0_a))
    {
        ctrl->cap = ECC_NONE;
        ctrl->mode = ECC_NONE;
    }
    else
    {
        unsigned long mad0;
        unsigned long mad1;

        ctrl->cap = ECC_CORRECT;

        for (mc = 0; mc < 2; mc++)
        {
            mad0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_INTRA_CH0(mc)));
            mad1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_INTRA_CH1(mc)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] INTRA_MAD_0=%08x, INTRA_MAD_1=%08x", mc, mad0, mad1);
            MtSupportDebugWriteLine(gBuffer);

            if ((mad0 != 0xffffffff && (BitExtract(mad0, 13, 12) & 0x3) != 0) ||
                (mad1 != 0xffffffff && (BitExtract(mad1, 13, 12) & 0x3) != 0)) // ECC Channel Configuration (ECC) - 13:12 (3: ECC active in both IO and ECC logic)
                ctrl->mode = ECC_CORRECT;

            for (int ch = 0; ch < 2; ch++)
            {
                UINT32 ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECCERRLOG0(mc, ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG0[%d]=%08x", mc, ch, ECCerrlog0);
                MtSupportDebugWriteLine(gBuffer);

                /* Clear the error status */
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECCERRLOG0(mc, ch)), ECCerrlog0);
            }
        }
    }

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_CAPID0_C, 4, &mtldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", mtldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_CAPID0_E, 4, &mtldata->capid0_e);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_E=%08x (IBECC disable: %s)", mtldata->capid0_e, INTEL_METEORLAKE_CAPID0_E_IBECC_DIS(mtldata->capid0_e) ? L"yes" : L"no");
    MtSupportDebugWriteLine(gBuffer);

    if (INTEL_METEORLAKE_CAPID0_E_IBECC_DIS(mtldata->capid0_e) == 0)
    {
        ctrl->cap |= __ECC_INBAND;

        ibecc_act = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_IBECC_ACTIVATE));

        AsciiSPrint(gBuffer, BUF_SIZE, "IBECC_ACTIVATE=%08x", ibecc_act);
        MtSupportDebugWriteLine(gBuffer);

        if (ibecc_act == 0xffffffff)
            AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ACTIVATE is invalid");
        if (INTEL_METEORLAKE_IBECC_ACTIVATE_IBECC_EN(ibecc_act))
        {
            unsigned long long errlog;

            errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_IBECC_ERROR_LOG));

            AsciiSPrint(gBuffer, BUF_SIZE, "IBECC_ERROR_LOG=" I64HEXFMT, errlog);
            MtSupportDebugWriteLine(gBuffer);

            if (errlog != (unsigned long long)-1)
            {
                ctrl->mode |= __ECC_INBAND;
                AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] IBECC is enabled", mc);

                /* Clear the error status */
                errlog |= INTEL_METEORLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_METEORLAKE_IBECC_ERROR_LOG_CERRSTS | INTEL_METEORLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW | INTEL_METEORLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW;
                writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_IBECC_ERROR_LOG), errlog);
            }
            else
                AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ERROR_LOG is invalid");
        }
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    mtldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 41, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    mtldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", mtldata->tolud, mtldata->tom);

    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_METEORLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    SetMem(mtldata->ms_total_size, sizeof(mtldata->ms_total_size), 0);

    for (mc = 0; mc < 2; mc++)
    {
        unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
        int ch_l_map = 0, dimm_l_map = 0;
        int ch;

        mtldata->mc_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_MC_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_MC_HASH=%08x", mc, mtldata->mc_hash[mc]);

        if (mtldata->mc_hash[mc] == 0xffffffff)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] invalid MAD_MC_HASH - MC may not exist", mc);
            continue;
        }

        remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_REMAPBASE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPBASE=" I64HEXFMT, mc, remapbase);

        remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_REMAPLIMIT(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] REMAPLIMIT=" I64HEXFMT, mc, remaplimit);

        mtldata->mad_inter_ch[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_INTER_CH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTER_CH=%08x", mc, mtldata->mad_inter_ch[mc]);

        ch_s_size = LShiftU64(BitExtract(mtldata->mad_inter_ch[mc], 19, 12), 29);
        ch_l_map = BitExtract(mtldata->mad_inter_ch[mc], 4, 4);

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch width=x%d", mc, 1 << (BitExtract(mtldata->mad_inter_ch[mc], 28, 27) + 4));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch S size=%ld", mc, ch_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch L map=%d", mc, ch_l_map);

        unsigned char ddr_type = BitExtract(mtldata->mad_inter_ch[mc], 2, 0);
        if (ddr_type < 4)
        {
            static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5", L"LPDDR5", L"LPDDR4"};
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] DDR type=%s", mc, DDR_TYPE[ddr_type]);
        }

        mtldata->ch_hash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_CHANNEL_HASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_HASH=%08x", mc, mtldata->ch_hash[mc]);

        mtldata->ch_ehash[mc] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_CHANNEL_EHASH(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] CHANNEL_EHASH=%08x", mc, mtldata->ch_ehash[mc]);

        if (BitExtract(mtldata->capid0_a, 12, 12) == 0)
            ctrl->chmode = 2;

        UINT8 chmode = 0;
        mtldata->ms_total_size[mc] = 0;
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_TC_PRE(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_PRE=" I64HEXFMT, mc, ch, tc_pre);
            unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_TC_CAS(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] TC_ODT=" I64HEXFMT, mc, ch, tc_odt);
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_SC_GS_CFG(mc, ch)));
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT, mc, ch, sc_gs_cfg);

            mtldata->mad_intra[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_INTRA_CH0(mc) + 4 * ch));
            mtldata->mad_dimm[mc * 2 + ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MAD_DIMM_CH0(mc) + 4 * ch));

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_INTRA_CH%d=%08x", mc, ch, mtldata->mad_intra[mc * 2 + ch]);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MAD_DIMM_CH%d=%08x", mc, ch, mtldata->mad_dimm[mc * 2 + ch]);

            dimm_l_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            dimm_s_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            dimm_l_map = BitExtract(mtldata->mad_intra[mc * 2 + ch], 0, 0);

            mtldata->ms_total_size[mc] += dimm_s_size;
            mtldata->ms_total_size[mc] += dimm_l_size;

            unsigned int dimm_l_ranks = BitExtract(mtldata->mad_dimm[mc * 2 + ch], 9, 9) + 1;
            unsigned int dimm_s_ranks = BitExtract(mtldata->mad_dimm[mc * 2 + ch], 26, 26) + 1;
            unsigned int dimm_l_chipwidth = 1 << (BitExtract(mtldata->mad_dimm[mc * 2 + ch], 7, 7) + 3);
            unsigned int dimm_s_chipwidth = 1 << (BitExtract(mtldata->mad_dimm[mc * 2 + ch], 24, 24) + 3);

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L size=%ld", mc, ch, dimm_l_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L ranks=%d", mc, ch, dimm_l_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L width=x%d", mc, ch, dimm_l_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S size=%ld", mc, ch, dimm_s_size);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S ranks=%d", mc, ch, dimm_s_ranks);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM S width=x%d", mc, ch, dimm_s_chipwidth);
            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] Ch%d DIMM L map=%d", mc, ch, dimm_l_map);

            ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
            ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
            ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
            ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

            if (dimm_l_size > 0 || dimm_s_size > 0)
                chmode++;
        }
        if (chmode > ctrl->chmode)
            ctrl->chmode = chmode;

        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] total size=%ld", mc, mtldata->ms_total_size[mc]);
    }
}

static void poll_meteorlake(struct ecc_info *ctrl)
{
    // ECC errors
    for (UINT8 mc = 0; mc < 2; mc++)
    {
        for (UINT8 ch = 0; ch < 2; ch++)
        {
            UINT32 ECCerrlog0;
            UINT32 ECCerrlog1;

            // Get the ECC error details
            ECCerrlog0 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECCERRLOG0(mc, ch)));

            if (ECCerrlog0 != 0xffffffff && (INTEL_METEORLAKE_ECCERRLOG0_CERRSTS(ECCerrlog0) || INTEL_METEORLAKE_ECCERRLOG0_MERRSTS(ECCerrlog0)))
            {
                UINT32 col, row;
                UINT8 bank, rank;
                UINT32 syndrome;
                UINT8 slot;
                UINT8 corrected;

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG0[%d]=%08x", mc, ch, ECCerrlog0);
                MtSupportDebugWriteLine(gBuffer);

                ECCerrlog1 = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECCERRLOG1(mc, ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "[MC%d] ERRLOG1[%d]=%08x", mc, ch, ECCerrlog1);
                MtSupportDebugWriteLine(gBuffer);

                syndrome = INTEL_METEORLAKE_ECCERRLOG0_SYN(ECCerrlog0);
                col = INTEL_METEORLAKE_ECCERRLOG1_COL(ECCerrlog1);
                row = INTEL_METEORLAKE_ECCERRLOG1_ROW(ECCerrlog1);
                bank = INTEL_METEORLAKE_ECCERRLOG0_BANK(ECCerrlog0);
                rank = INTEL_METEORLAKE_ECCERRLOG0_RANK(ECCerrlog0);

                slot = rank < 4 ? 0 : 1;

                /* Parse the error location and error type */
                corrected = INTEL_METEORLAKE_ECCERRLOG0_CERRSTS(ECCerrlog0);

                /* Report the error */
                MtSupportReportECCError_dimm(col, row, bank, rank, corrected, syndrome, -1, mc, slot);
            }
        }
    }

    // IBECC errors
    unsigned long long addr;
    unsigned long long errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_IBECC_ERROR_LOG));

    if ((errlog != (unsigned long long)-1) &&
        (errlog != 0))
    {
        UINT32 syndrome;
        UINT8 corrected;

        AsciiSPrint(gBuffer, BUF_SIZE, "IBECC_ERROR_LOG=" I64HEXFMT, errlog);
        MtSupportDebugWriteLine(gBuffer);

        addr = INTEL_METEORLAKE_IBECC_ERROR_LOG_ERRADD(errlog);
        syndrome = (int)INTEL_METEORLAKE_IBECC_ERROR_LOG_ERRSYND(errlog);
        corrected = (errlog & INTEL_METEORLAKE_IBECC_ERROR_LOG_MERRSTS) == 0;

        /* Report the error */
        MtSupportReportIBECCError((UINTN)addr, corrected, syndrome, -1, -1, -1);

        /* Clear the error status */
        errlog |= INTEL_METEORLAKE_IBECC_ERROR_LOG_MERRSTS | INTEL_METEORLAKE_IBECC_ERROR_LOG_CERRSTS | INTEL_METEORLAKE_IBECC_ERROR_LOG_MERR_OVERFLOW | INTEL_METEORLAKE_IBECC_ERROR_LOG_CERR_OVERFLOW;
        writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_IBECC_ERROR_LOG), errlog);
    }
}

BOOLEAN inject_meteorlake(int index, int uncorrectable, int enable)
{
    BOOLEAN ret = TRUE;
    int mc, channel;
    UINT32 eccdbg = 0;
    unsigned int val;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return FALSE;

    ctrl = &s_ctrl[index];

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT

    for (mc = 0; mc < 2; mc++)
    {
#if 0
        val = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MC_LOCK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");
#endif
        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_INJ_ADDR_COMPARE(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d] ECC Addr Comp = %08x", mc, val);

        val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_INJ_ADDR_MASK(mc)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d] ECC Addr Mask = %08x", mc, val);

#if 0
        if (uncorrectable < 0)
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECCINJCOUNT_C0), 0xffffffff);
        else
#endif

        for (channel = 0; channel < ctrl->numch; channel++)
        {
            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_INJECT_COUNT(mc, channel)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d|Ch%d] ECC Inj count = %08x", mc, channel, val);

            unsigned int newval = 0x50;
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_INJECT_COUNT(mc, channel)), newval);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_INJECT_COUNT(mc, channel)));

            if (val != newval)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC Inj count to %08x", mc, channel, newval);
                ret = FALSE;
            }

            eccdbg = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_DEBUG(mc, channel)));

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d|Ch%d] ECC_DEBUG = %08x", mc, channel, eccdbg);

            eccdbg &= 0xFFFFFFF8;

            // Error Injection Mode (ECC_INJECT):
            // ECC error inject options :
            //  000b : No ECC error injection.
            //  001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
            //  011b : Inject correctable ECC error on ECC error insertion counter.
            //  101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
            //  111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
            if (enable == 0)
                eccdbg &= ~0x7;
            else if (uncorrectable == 1)
                eccdbg |= 0x7;
            else if (uncorrectable == 0)
                eccdbg |= 0x3;

            AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d|Ch%d] new ECC_DEBUG = %08x", mc, channel, eccdbg);

            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_DEBUG(mc, channel)), eccdbg);

            val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_ECC_DEBUG(mc, channel)));

            if (val != eccdbg)
            {
                AsciiFPrint(DEBUG_FILE_HANDLE, "inject_meteorlake - [MC%d|Ch%d]  **ERROR** Unable to modify ECC_DEBUG to %08x", mc, channel, eccdbg);
                ret = FALSE;
            }
        }
    }
    return ret;
}

void poll_timings_meteorlake(struct ecc_info *ctrl)
{
    mtl_data *mtldata = (mtl_data *)ctrl->userdata;

    unsigned int freq_mult = 0;
    unsigned int gear_mode = 1;
    unsigned char ddr_type = INTEL_METEORLAKE_DDR5;
    for (UINT8 mc = 0; mc < 2; mc++)
    {
        unsigned char ddr_overclock = BitExtract(mtldata->capid0_a, 3, 3);
        if (ddr_overclock == 0)
        {
            ddr_type = BitExtract(mtldata->mad_inter_ch[mc], 2, 0);
            switch (ddr_type)
            {
            case INTEL_METEORLAKE_DDR4:
                freq_mult = BitExtract(mtldata->capid0_c, 27, 23);
                break;
            case INTEL_METEORLAKE_DDR5:
                freq_mult = BitExtract(mtldata->capid0_e, 17, 10);
                break;
            case INTEL_METEORLAKE_LPDDR5:
                freq_mult = BitExtract(mtldata->capid0_e, 8, 1);
                break;
            case INTEL_METEORLAKE_LPDDR4:
                freq_mult = BitExtract(mtldata->capid0_c, 21, 17);
                break;
            default:
                continue;
            }
            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - [MC%d] freq_mult=%d", mc, freq_mult);
        }

        for (int ch = 0; ch < ctrl->numch; ch++)
        {

            unsigned long long dimm_l_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
            unsigned long long dimm_s_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
            unsigned long long ch_size = dimm_l_size + dimm_s_size;

            if (ch_size == 0)
                continue;

            unsigned long long tc_cas = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_TC_CAS(mc, ch)));
            unsigned long long tc_pre = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_TC_PRE(mc, ch)));
            unsigned long long tc_act = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_TC_ACT(mc, ch)));
            unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_SC_GS_CFG(mc, ch)));

            unsigned char tCL = (unsigned char)BitExtractULL(tc_cas, 22, 16);
            unsigned char tRCD = (unsigned char)BitExtractULL(tc_act, 29, 22);
            unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 53, 45);
            unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 7, 0);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - [MC%d][Ch %d] TC_CAS=" I64HEXFMT " TC_PRE=" I64HEXFMT " TC_ACT=" I64HEXFMT " (%d-%d-%d-%d)", mc, ch, tc_cas, tc_pre, tc_act, tCL, tRCD, tRP, tRAS);

            if (tCL < 4 ||  /* tCL > 72 || */
                tRCD < 8 || /* tRCD > 59 || */
                tRP < 10 || /* tRP > 76 || */
                tRAS < 28 /* || tRAS > 136 */)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;

            AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d, Ch%d] SC_GS_CFG=" I64HEXFMT " (gear_mode=%d)", mc, ch, sc_gs_cfg, BitExtract(sc_gs_cfg, 31, 31));
            gear_mode = BitExtract(sc_gs_cfg, 31, 31) ? 4
                                                      : 2;
        }
    }

    unsigned long cr_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MEMSS_PMA_CR_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - MEMSS_PMA_CR_BIOS_REQ=%08x (MAX_BW_MBPS=%d, GEAR_TYPE=%d, QCLK_RATIO=%d)", cr_bios_req, BitExtract(cr_bios_req, 28, 9), BitExtract(cr_bios_req, 8, 8), BitExtract(cr_bios_req, 7, 0));
    unsigned long cr_bios_data = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_MEMSS_PMA_CR_BIOS_DATA));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - MEMSS_PMA_CR_BIOS_DATA=%08x (GEAR_TYPE=%d, QCLK_RATIO=%d)", cr_bios_data, BitExtract(cr_bios_data, 8, 8), BitExtract(cr_bios_data, 7, 0));
    unsigned int qclk_ratio = BitExtract(cr_bios_data, 7, 0);

    unsigned long long sa_perf_status = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_SA_PERF_STATUS));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - SA_PERF_STATUS=" I64HEXFMT " (qclk_ratio=%d, qclk_ref=%d)", sa_perf_status, BitExtractULL(sa_perf_status, 9, 2), BitExtractULL(sa_perf_status, 10, 10));
    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_METEORLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_meteorlake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        // Qclk ratio with reference of 33.33MHz.
        ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode / 3) / (2 * 1000);
    }

    if (ddr_type == INTEL_METEORLAKE_LPDDR5)
    {
        // Once the data transfer rate drops to 3200 Mbps or slower, it is possible to change the CK to WCK ratio from 1:4 to 1:2
        // Timings are in units of WCK for LPDDR5
        unsigned char WCK2tCK = (ctrl->memclk << 1) > 3200 ? 4 : 2;

        ctrl->tAA /= WCK2tCK;
        ctrl->tRCD /= WCK2tCK;
        ctrl->tRAS /= WCK2tCK;
        ctrl->tRP /= WCK2tCK;
    }
}

int decode_meteorlake(struct ecc_info *ctrl, unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
    int i;
    int mc = -1, ch = -1, subch = -1, dimm = -1, rank = -1, chip = -1;
    unsigned long long paddr, imc_addr, ch_addr, subch_addr, dimm_addr, rank_addr;

    int intlv_lsb = 0, hash_mode = 0;
    unsigned long long hash_mask = 0;
    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ms_l_map = 0, ch_l_map = 0, dimm_l_map = 0;
    unsigned char ddr_type;
    int numranks = 1;

    unsigned long ebits32 = (unsigned long)((RShiftU64(ebits, 32) & 0x0ffffffffull) | (ebits & 0x0ffffffffull));
    int chipwidth = 8;
    int errword = -1;
    int numwords;
    unsigned long wordmask;
    int chiperrs = 0;

    mtl_data *mtldata = (mtl_data *)ctrl->userdata;

    if (addr >= mtldata->tom)
        paddr = addr - mtldata->tom + mtldata->tolud;
    else
        paddr = addr;

    ms_l_map = mtldata->ms_total_size[0] < mtldata->ms_total_size[1] ? 1 : 0;

    hash_mask = 0x82600;
    if (mtldata->mc_hash[0] != 0xffffffff)
    {
        hash_mode = BitExtract(mtldata->mc_hash[0], 0, 0);
        intlv_lsb = BitExtract(mtldata->mc_hash[0], 3, 1) + 6;
    }
    else
    {
        hash_mode = BitExtract(mtldata->mc_hash[1], 0, 0);
        intlv_lsb = BitExtract(mtldata->mc_hash[1], 3, 1) + 6;
    }
    decode_subaddr(paddr, intlv_lsb, 1, hash_mask, ms_l_map ? mtldata->ms_total_size[0] : mtldata->ms_total_size[1], ms_l_map, &mc, &imc_addr);

    ch_s_size = LShiftU64(BitExtract(mtldata->mad_inter_ch[mc], 19, 12), 29);
    ch_l_map = BitExtract(mtldata->mad_inter_ch[mc], 4, 4);
    ddr_type = BitExtract(mtldata->mad_inter_ch[mc], 2, 0);

    hash_mode = BitExtract(mtldata->ch_hash[mc], 28, 28);
    intlv_lsb = BitExtract(mtldata->ch_hash[mc], 26, 24) + 6;
    hash_mask = LShiftU64(BitExtract(mtldata->ch_hash[mc], 19, 6), 6);
    if (hash_mode)
    {
        decode_subaddr(imc_addr, intlv_lsb, hash_mode, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);
    }
    else
    {
        int ranks = BitExtract(mtldata->mad_dimm[mc * 2 + ch_l_map], 10, 9) + 1;
        if (ranks >= 2)
        {
            hash_mask = 0x12f00;
            decode_subaddr(imc_addr, intlv_lsb, 1, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);
        }
        else
        {
            decode_subaddr(imc_addr, intlv_lsb, 1, hash_mask, ch_s_size, ch_l_map, &ch, &ch_addr);
        }
    }

    dimm_l_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 6, 0), 29);
    dimm_s_size = LShiftU64(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 22, 16), 29);
    dimm_l_map = BitExtract(mtldata->mad_intra[mc * 2 + ch], 0, 0);

    if (ddr_type == INTEL_METEORLAKE_LPDDR5) // LPDDR5
    {
        hash_mode = BitExtract(mtldata->ch_ehash[mc], 28, 28);
        intlv_lsb = hash_mode ? (BitExtract(mtldata->ch_ehash[mc], 26, 24) + 6) : 6;
        hash_mask = LShiftU64(BitExtract(mtldata->ch_ehash[mc], 19, 6), 6);

        decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &subch, &subch_addr);
    }

    int ddr5 = (ddr_type == INTEL_METEORLAKE_DDR5 || ddr_type == INTEL_METEORLAKE_LPDDR5);
    int maxranks = MAX(BitExtract(mtldata->mad_dimm[mc * 2 + ch], 10, 9) + 1, BitExtract(mtldata->mad_dimm[mc * 2 + ch], 27, 26) + 1);

    hash_mode = 1;
    if (ddr5)
    {
        hash_mask = 0x820000;
        intlv_lsb = 17;
    }
    else
    {
        if (ctrl->chipwidth[mc * 2] == 16)
        {
            hash_mask = 0x90000; // DIMM mask
            intlv_lsb = 16;
        }
        else
        {
            hash_mask = maxranks >= 2 ? 0x420000 : 0x220000;
            intlv_lsb = 17;
        }
    }
    decode_subaddr(ch_addr, intlv_lsb, hash_mode, hash_mask, dimm_s_size, dimm_l_map, &dimm, &dimm_addr);

    if (dimm_l_map == dimm)
        numranks = BitExtract(mtldata->mad_dimm[mc * 2 + ch], 10, 9) + 1;
    else
        numranks = BitExtract(mtldata->mad_dimm[mc * 2 + ch], 27, 26) + 1;

    rank = 0;
    if (numranks > 1)
    {
        hash_mode = 1;
        intlv_lsb = 15;
        hash_mask = ddr5 ? 0x208000 : 0x88000; // Rank uses hash value from rocketlake when decoding DDR4

        decode_subaddr(dimm_addr, intlv_lsb, hash_mode, hash_mask, dimm_l_map == dimm ? dimm_l_size : dimm_s_size, dimm_l_map, &rank, &rank_addr);
    }

    if (ctrl->chipwidth[mc * 2 + dimm] > 0)
        chipwidth = ctrl->chipwidth[mc * 2 + dimm];

    numwords = 32 / chipwidth;
    wordmask = (unsigned long)(LShiftU64(1, chipwidth) - 1);

    if (ddr5)
    {
        for (i = 0; i < numwords; i++)
        {
            if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
            {
                if (rank == 0)
                    chip = mc * numwords + i;
                else
                    chip = rank * numwords * 2 + (1 - mc) * numwords + (numwords - i - 1);

                errword = i;
                chiperrs++;
            }
        }
    }
    else // DDR4
    {
        if (esize == 4)
        { // 32 bit error

            for (i = 0; i < numwords; i++)
            {
                if (((ebits32 >> (i * chipwidth)) & wordmask) != 0)
                {
                    int unaligned8 = (addr & 0x7) != 0 ? 1 : 0; // 1 if 8-byte aligned address, 0 otherwise

                    if (rank == 0)
                        chip = unaligned8 * numwords + i;
                    else
                        chip = rank * numwords * 2 + (1 - unaligned8) * numwords + (numwords - i - 1);

                    chiperrs++;
                }
            }
        }
        else // 64 bit error
        {
            unsigned long lo = ebits & 0xffffffff;
            unsigned long hi = ebits >> 32;

            for (i = 0; i < numwords; i++)
            {
                if (((lo >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (rank == 0)
                        chip = i;
                    else
                        chip = rank * numwords * 2 + numwords + (numwords - i - 1);

                    chiperrs++;
                }

                if (((hi >> (i * chipwidth)) & wordmask) != 0)
                {
                    if (rank == 0)
                        chip = numwords + i;
                    else
                        chip = rank * numwords * 2 + (numwords - i - 1);

                    chiperrs++;
                }
            }
        }
    }
    if (chiperrs != 1)
        chip = -1;

    AsciiFPrint(DEBUG_FILE_HANDLE, "decode_mtl - C(%p,%08x,%d,%d,%d,%d,%d)", addr, ebits32, mc, ch, subch, dimm, rank);

    if (form_factor != ChipMapFormFactorCSodimm)
    {
        if (numranks >= 2)
        {
            // If both channels occupied, get the actual channel by mc XOR ch
            if (imc_addr < 2 * ch_s_size)
                ch = mc ^ ch;
        }
        AsciiFPrint(DEBUG_FILE_HANDLE, "decode_mtl - D(%p,%08x,%d,%d,%d,%d,%d)", addr, ebits32, mc, ch, subch, dimm, rank);
    }

    if (form_factor == ChipMapFormFactorSodimm)
    {
        if (chiperrs == 1)
        {
            // For SODIMMs, mc determines the rank
            if (mc == 1)
                chip = (1 - rank) * numwords + errword;
            else
                chip = (1 - mc) * numwords * 2 + (1 - rank) * numwords + (numwords - errword - 1);
        }

        AsciiFPrint(DEBUG_FILE_HANDLE, "decode_mtl - E(%p,%08x,%d,%d,%d,%d,%d)", addr, ebits32, mc, ch, subch, dimm, rank);
    }

    if (pch)
        *pch = ch;

    if (pdimm)
        *pdimm = dimm;

    if (prank)
        *prank = rank;

    if (pchip)
        *pchip = chip;

    if (subaddr)
        *subaddr = dimm_addr;

    return 0;
}

/*
 * Ice Lake SP (Ice Lake Scalable Performance)
 *
 * Reference: 3rd Gen Intel Xeon Scalable Processor, Codename Ice Lake External Design Specification (EDS), Volume Two: Registers (Doc. No.: 574942, Revision: 2.1)
 */
#define INTEL_ICELAKE_SP_MCMTR(ch) (0x20EF8 + ch * 0x4000)
#define INTEL_ICELAKE_SP_SCRUBCTL(ch) (0x20E28 + ch * 0x4000)

#define INTEL_ICELAKE_SP_MC0_DP_CHKN_BIT(ch) (0x23414 + ch * 0x4000)
#define INTEL_ICELAKE_SP_DIS_CORR_ERR_LOG(ch) (0x22D24 + ch * 0x4000)

#define INTEL_ICELAKE_SP_CORRERRCNT_0(ch) (0x22C18 + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRCNT_1(ch) (0x22C1C + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRCNT_2(ch) (0x22C20 + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRCNT_3(ch) (0x22C24 + ch * 0x4000)

#define INTEL_ICELAKE_SP_CORRERRTHRSHLD_0(ch) (0x22C30 + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRTHRSHLD_1(ch) (0x22C34 + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRTHRSHLD_2(ch) (0x22C38 + ch * 0x4000)
#define INTEL_ICELAKE_SP_CORRERRTHRSHLD_3(ch) (0x22C3C + ch * 0x4000)

#define INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRCD(ch) (0x228B8 + ch * 0x4000)
#define INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TCL_TWL(ch) (0x228C0 + ch * 0x4000)
#define INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRTP_TWR(ch) (0x228C4 + ch * 0x4000)
#define INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRP_TRC_TRAS(ch) (0x228C8 + ch * 0x4000)
#define INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRDA_TWRA_TWRPRE(ch) (0x228CC + ch * 0x4000)

#define INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_LO 0x1C0
#define INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_HI 0x1C4
#define INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_LO 0x1C8
#define INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_HI 0x1CC
#define INTEL_ICELAKE_SP_RSP_FUNC_RANK_BANK_MATCH 0x1D0
#define INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK 0x200
#define INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 0x204
#define INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA 0x208

#define INTEL_ICELAKE_SP_CAPID1_CFG 0x88
#define INTEL_ICELAKE_SP_CAPID3_CFG 0x90
#define INTEL_ICELAKE_SP_DEFEATURES0 0xe4

#define INTEL_ICELAKE_SP_MMCFG_BASE 0x90
#define INTEL_ICELAKE_SP_MMCFG_LIMIT 0x98

#define INTEL_ICELAKE_SP_MMIO_BASE 0xD0

#define INTEL_ICELAKE_SP_MEM0_BAR 0xD8
#define INTEL_ICELAKE_SP_MEM1_BAR 0xDC
#define INTEL_ICELAKE_SP_MEM2_BAR 0xE0
#define INTEL_ICELAKE_SP_MEM3_BAR 0xE4
#define INTEL_ICELAKE_SP_MEM4_BAR 0xE8
#define INTEL_ICELAKE_SP_MEM5_BAR 0xEC
#define INTEL_ICELAKE_SP_MEM6_BAR 0xF0
#define INTEL_ICELAKE_SP_MEM7_BAR 0xF4

#define INTEL_ICELAKE_SP_MC_BIOS_REQ_CFG 0x98
#define INTEL_ICELAKE_SP_MC_BIOS_DATA_CFG 0x9C

#define INTEL_ICELAKE_SP_CPUBUSNO_CFG 0xD0

#define MSR_CPU_BUSNUMBER 0x128

static void setup_icelake_sp(struct ecc_info *ctrl)
{
    unsigned long val = 0;
    unsigned long cpubusno_cfg = 0;
    unsigned long capid3 = 0;
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
    unsigned long pci_id = 0;
    UINT64 mmcfg = 0, mmcfglim = 0;
    unsigned int correrrcnt = 0, correrrthrshld = 0;

    int i;
    int rank;
    int ch, slot;

    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;
    int numbanks = 0;

    const int NUM_IMC = 4;
    const int CH_PER_IMC = 2;
    const int NUM_IMC_BANKS = NUM_IMC * CH_PER_IMC;
    const unsigned long imc_bank_id[] = {13, 14, 17, 18, 21, 22, 25, 26};

    unsigned char cpubusno[2];

    UINTN CPUPkg = 0;
    UINTN NumPkg = MPSupportGetNumPackages();

    MtSupportDebugWriteLine("Intel Ice Lake-SP chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;
    ctrl->mchbar = 0;

    pci_conf_read(ctrl->bus, 0, 2, INTEL_ICELAKE_SP_CPUBUSNO_CFG, 4, &cpubusno_cfg);
    AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP CPUBUSNO_CFG=%08x", cpubusno_cfg);
    MtSupportDebugWriteLine(gBuffer);

    cpubusno[0] = BitExtract(cpubusno_cfg, 7, 0);
    cpubusno[1] = BitExtract(cpubusno_cfg, 15, 8);

    pci_conf_read(cpubusno[1], 30, 3, INTEL_ICELAKE_SP_CAPID3_CFG, 4, &capid3);
    AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP - CAPID3 = %08x (DISABLE_ECC = %d)", capid3, (capid3 >> 10) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid3 >> 10) & 0x1) == 0) // DISABLE_ECC = 0
    {
        ctrl->mode = ECC_CORRECT;
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    if (1)
    {
        unsigned long mmcfg_hi = 0, mmcfg_lo = 0;
        unsigned long mmcfglim_hi = 0, mmcfglim_lo = 0;
        pci_conf_read(0, 0, 0, INTEL_ICELAKE_SP_MMCFG_BASE, 4, &mmcfg_lo);
        pci_conf_read(0, 0, 0, INTEL_ICELAKE_SP_MMCFG_BASE + 4, 4, &mmcfg_hi);
        mmcfg = LShiftU64(BitExtractULL(LShiftU64(mmcfg_hi, 32) | mmcfg_lo, 51, 26), 26);

        pci_conf_read(0, 0, 0, INTEL_ICELAKE_SP_MMCFG_LIMIT, 4, &mmcfglim_lo);
        pci_conf_read(0, 0, 0, INTEL_ICELAKE_SP_MMCFG_LIMIT + 4, 4, &mmcfglim_hi);
        mmcfglim = LShiftU64(BitExtractULL(LShiftU64(mmcfglim_hi, 32) | mmcfglim_lo, 51, 26), 26);

        AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP MMCFGBase=" I64HEXFMT ", MMCFGLim=" I64HEXFMT, mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP Device 0, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(cpubusno[1], 29, 1, 0, 4, &pci_id);
        if (pci_id == 0x34578086)
        {
            unsigned long mmcfg_rule_hi = 0;
            unsigned long mmcfg_rule_lo = 0;
            UINT64 mmcfg_rule;

            pci_conf_read(cpubusno[1], 29, 1, 0xc0, 4, &mmcfg_rule_lo);
            pci_conf_read(cpubusno[1], 29, 1, 0xc4, 4, &mmcfg_rule_hi);

            mmcfg_rule = LShiftU64(mmcfg_rule_hi, 32) | mmcfg_rule_lo;

            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0xFFFFFFC000000ULL;
                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=" I64HEXFMT ", MMCFG=" I64HEXFMT, cpubusno[1], 29, 1, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    ctrl->mchbar = mmcfg;

    pci_conf_read(cpubusno[0], 0, 1, INTEL_ICELAKE_SP_MMIO_BASE, 4, &val);
    AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP MMIO_BASE=%08x", val);
    MtSupportDebugWriteLine(gBuffer);

    UINT64 mmio_base = LShiftU64(BitExtract(val, 28, 0), 23);

    // Get MEM0_BAR - MEM4_BAR register
    for (i = 0; i < NUM_IMC; i++)
    {
        unsigned long mem_bar = 0, mem_bar_lim = 0;

        pci_conf_read(cpubusno[0], 0, 1, INTEL_ICELAKE_SP_MEM0_BAR + 4 * i, 4, &val);
        AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP MEM%d_BAR=%08x", i, val);
        MtSupportDebugWriteLine(gBuffer);
        if (val & (1 << 31))
        {
            mem_bar = (val & 0x7ff) << 12;
            mem_bar_lim = ((val >> 13) & 0x7ff) << 12;
            AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP MEM%d_BAR BASE_ADDR=%08x, LIMIT=%08x", i, mem_bar, mem_bar_lim);
            MtSupportDebugWriteLine(gBuffer);
        }

        if (mem_bar > 0 && mem_bar_lim > 0 && mem_bar <= mem_bar_lim) // Sanity check
        {
            ctrl->membar[i] = mmio_base | mem_bar;

            AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d] MMIO Base=" I64HEXFMT, i, ctrl->membar[i]);
            MtSupportDebugWriteLine(gBuffer);

            for (ch = 0; ch < ctrl->numch; ch++)
            {
                UINTN baseaddr = (UINTN)(ctrl->membar[i]);
                /* Check for ECC & Scrub */
                mc_mtr = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_MCMTR(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] MCMTR=%08x", i, ch, mc_mtr);
                MtSupportDebugWriteLine(gBuffer);

                if (mc_mtr == 0xffffffff)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] registers may not exist", i, ch);
                    MtSupportDebugWriteLine(gBuffer);
                    continue;
                }

                unsigned long chn_disable = BitExtract(mc_mtr, 18, 18);
                if (!chn_disable)
                    ctrl->chmode++;

                unsigned long ecc_en = BitExtract(mc_mtr, 2, 2);
                if (ecc_en)
                    ctrl->mode |= ECC_CORRECT;

                mc_scrubctl = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_SCRUBCTL(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] SCRUBCTL=%08x", i, ch, mc_scrubctl);
                MtSupportDebugWriteLine(gBuffer);

                unsigned long scrub_en = BitExtract(mc_scrubctl, 31, 31);
                if (scrub_en)
                    ctrl->mode |= ECC_SCRUB;

                // Read corrected error/threshold registers
                val = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_DIS_CORR_ERR_LOG(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] dis_corr_err_log=%08x", i, ch, val);
                MtSupportDebugWriteLine(gBuffer);

                val = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_MC0_DP_CHKN_BIT(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] MC0_DP_CHKN_BIT=%08x", i, ch, val);
                MtSupportDebugWriteLine(gBuffer);

                for (rank = 0; rank < 4; rank++)
                {
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error/threshold registers
                    correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_CORRERRCNT_0(ch) + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_CORRERRTHRSHLD_0(ch) + 4 * rank));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d, Sl%d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", i, ch, slot, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                        writemmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_CORRERRCNT_0(ch) + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_CORRERRCNT_0(ch) + 4 * rank));
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                    {
                        int imcslots = ctrl->numch * ctrl->numsl;
                        int index = i * imcslots + ch * ctrl->numsl + slot;
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[index] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[index] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
            }
        }
    }

    for (CPUPkg = 0; CPUPkg < NumPkg; CPUPkg++)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ice Lake-SP CPU Pkg %d MCA registers", CPUPkg);
        UINTN CurBSP = MPSupportGetBspId();

        if (MPSupportSwitchPkg(CPUPkg) != EFI_SUCCESS)
            continue;

        // ECC errors also reported in the MSR, read and clear any previous errors
        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
        numbanks = mcgcap & 0xff;

        AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP MCG_CAP=" I64HEXFMT " (banks=%d), MCG_STATUS=" I64HEXFMT, mcgcap, numbanks, mcgstatus);
        MtSupportDebugWriteLine(gBuffer);

        for (i = 0; i < NUM_IMC_BANKS; i++)
        {
            UINT64 mcctl = 0;
            UINT64 mcstatus = 0;

            int mcbank = imc_bank_id[i];
            int imc = i / ctrl->numch;
            ch = i % ctrl->numch;

            if (mcbank >= numbanks)
                break;

            _rdmsr64(MSR_IA32_MCi_CTL(mcbank), &mcctl);
            AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] MC%d_CTL=" I64HEXFMT, imc, ch, mcbank, mcctl);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

            if (mcstatus)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Ice Lake-SP [IMC%d, Ch%d] MC%d_STATUS=" I64HEXFMT, imc, ch, mcbank, mcstatus);
                MtSupportDebugWriteLine(gBuffer);
                _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
            }
        }

        if (CurBSP != MPSupportGetBspId())
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Switching BSP back to %d", (int)CurBSP);
            MtSupportDebugWriteLine(gBuffer);

            MPSupportSwitchBSP(CurBSP);
        }
    }
}

static void poll_icelake_sp(struct ecc_info *ctrl)
{
    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;
    int numbanks = 0;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    const UINT8 NUM_IMC = 4;
    const UINT8 CH_PER_IMC = 2;
    const UINT8 NUM_IMC_BANKS = NUM_IMC * CH_PER_IMC;
    const unsigned long imc_bank_id[] = {13, 14, 17, 18, 21, 22, 25, 26};

    UINT8 ch, slot;

    UINTN NumPkg = MPSupportGetNumPackages();

    BOOLEAN reported = FALSE;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);
    for (UINT8 CPUPkg = 0; CPUPkg < NumPkg; CPUPkg++)
    {
        UINTN CurBSP = MPSupportGetBspId();

        if (MPSupportSwitchPkg(CPUPkg) != EFI_SUCCESS)
            continue;

        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
        numbanks = mcgcap & 0xff;

        for (UINT8 i = 0; i < NUM_IMC_BANKS; i++)
        {
            UINT64 mcstatus = 0;
            UINT64 mcmisc = 0;
            UINT64 mcaddr = 0;

            int mcbank = imc_bank_id[i];
            UINT8 imc = i / ctrl->numch;
            ch = i % ctrl->numch;

            if (mcbank >= numbanks)
                break;

            _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

            if (mcstatus & MCI_STATUS_VAL)
            {
                BOOLEAN uncorrected_error;
                UINT32 col, row;
                UINT8 bank, rank;
                UINT32 mserr;
                UINT64 addrmask;
                CHAR8 *errstr = "";

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)", mcbank, mcstatus,
                            (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                            (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                            (UINT32)((mcstatus >> 38) & 0x7FFF),
                            (UINT32)(mcstatus & 0xFFFF));
                MtSupportDebugWriteLine(gBuffer);

                if ((mcstatus & 0xef80) == 0x80)
                {
                    UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);

                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d] Transaction error type : ", imc, ch);
                    switch (xacttype)
                    {
                    case 0:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                        break;
                    case 1:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                        break;
                    case 2:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                        break;
                    case 3:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                        break;
                    case 4:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                        break;
                    default:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                        break;
                    }
                    MtSupportDebugWriteLine(gBuffer);
                }
                else
                    MtSupportDebugWriteLine("**WARNING** Not memory controller error");

                AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d] Model specific error: ", imc, ch);
                mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);

                errstr = "";
                switch (mserr)
                {
                case 0x0000:
                    errstr = "UnCorrectable Spare Error";
                    break;
                case 0x0001:
                    errstr = "Internal Error - End - End Address Parity Error(APPP)";
                    break;
                case 0x0002:
                    errstr = "Internal Error - Write Data Parity Error";
                    break;
                case 0x0003:
                    errstr = "Internal Error - End - End Uncorr / Corr Wr Data ECC Error";
                    break;
                case 0x0004:
                    errstr = "Internal Error - Write Byte Enable Parity Error";
                    break;
                case 0x0007:
                    errstr = "Internal Error - Transaction ID Parity Error";
                    break;
                case 0x0008:
                    errstr = "Corr Patrol Scrub Error(Non Mirror or Mirror Primary)";
                    break;
                case 0x0010:
                    errstr = "UnCorr Patrol Scrub Error(Non - mirror or Mirror Primary)";
                    break;
                case 0x0020:
                    errstr = "Corr Spare Error";
                    break;
                case 0x0080:
                    errstr = "Transient or Correctable Error for Demand or Underfill Reads(Non Mirror or Mirror Primary) or Read 2LM MetaData Error";
                    break;
                case 0x00A0:
                    errstr = "Uncorrectable Error for Demand or Underfill Reads(Non Mirror or Mirror Primary)";
                    break;
                case 0x0100:
                    errstr = "WDB Read Parity Error";
                    break;
                case 0x0108:
                    errstr = "DDR / DDRT Link Fail";
                    break;
                case 0x0111:
                    errstr = "Internal Error - PCLS Address CSR Parity Error";
                    break;
                case 0x0112:
                    errstr = "Internal Firmware Error - PCLS Illegal ADDDC Configuration Error";
                    break;
                case 0x0200:
                    errstr = "DDR4 CA Parity";
                    break;
                case 0x0400:
                    errstr = "Internal Parity Error - RPQ Scheduler Address Parity";
                    break;
                case 0x0800:
                    errstr = "Internal FW Error - 2LM unrecognized request type";
                    break;
                case 0x0801:
                    errstr = "Internal Error - 2LM read response to an invalid scoreboard entry";
                    break;
                case 0x0802:
                    errstr = "Internal Error - 2LM unexpected read response";
                    break;
                case 0x0803:
                    errstr = "Internal Error - 2LM DDR4 completion to an invalid scoreboard entry";
                    break;
                case 0x0804:
                    errstr = "Internal Error - 2LM DDRt completion to an invalid scoreboard entry";
                    break;
                case 0x0805:
                    errstr = "Internal Error - 2LM completion FIFO overflow";
                    break;
                case 0x0806:
                    errstr = "DDRT Link Parity Error";
                    break;
                case 0x0807:
                    errstr = "Internal Error - DDRT RID Uncorrectable error";
                    break;
                case 0x0809:
                    errstr = "Internal Error - DDRT RID FIFO overflow";
                    break;
                case 0x080A:
                    errstr = "Internal FW Error - DDRT Error on FNV Write credits";
                    break;
                case 0x080B:
                    errstr = "Internal Error - DDRT Error on FNV Read credits";
                    break;
                case 0x080C:
                    errstr = "Internal Error - DDRT Scheduler error";
                    break;
                case 0x080D:
                    errstr = "DDRT FNV Error(CAParity or WrECC Error)";
                    break;
                case 0x080E:
                    errstr = "DDRT FNV Thermal Error";
                    break;
                case 0x080F:
                    errstr = "Internal Error - DDRT Unexpected Data Packet During CMI Idle";
                    break;
                case 0x0810:
                    errstr = "Internal Parity Error - DDRT RPQ Request Parity Error";
                    break;
                case 0x0811:
                    errstr = "Internal Parity Error - DDRT WPQ Request Parity Error";
                    break;
                case 0x0812:
                    errstr = "Internal Error - 2LM NmFillWr CAM Multiple Hit Error";
                    break;
                case 0x0813:
                    errstr = "Internal Error - CMI Credit Oversubscription Error";
                    break;
                case 0x0814:
                    errstr = "Internal Error - CMI Total Credit Count Error";
                    break;
                case 0x0815:
                    errstr = "Internal Error - CMI Reserved Credit Pool Error";
                    break;
                case 0x0816:
                    errstr = "DDRT Link ECC Error";
                    break;
                case 0x0817:
                    errstr = "Internal Error - WDB FIFO Overflow or Underflow Errors";
                    break;
                case 0x0818:
                    errstr = "Internal Error - CMI Request FIFO Overflow Error";
                    break;
                case 0x0819:
                    errstr = "Internal Error - CMI Request FIFO Underflow Error";
                    break;
                case 0x081a:
                    errstr = "Internal Error - CMI Response FIFO Overflow Error";
                    break;
                case 0x081b:
                    errstr = "Internal Error - CMI Response FIFO Underflow Error";
                    break;
                case 0x081c:
                    errstr = "Internal Error - CMI Miscellaneous Credit Errors";
                    break;
                case 0x081d:
                    errstr = "Internal Error - CMI MC Arbiter Errors";
                    break;
                case 0x081e:
                    errstr = "Internal Error - DDRT Write Completion FIFO Overflow Error";
                    break;
                case 0x081f:
                    errstr = "Internal Error - DDRT Write Completion FIFO Underflow Error";
                    break;
                case 0x0820:
                    errstr = "Internal Error - CMI Read Completion FIFO Overflow Error";
                    break;
                case 0x0821:
                    errstr = "Internal Error - CMI Read Completion FIFO Underflow Error";
                    break;
                case 0x0822:
                    errstr = "Internal Parity Error - TME Key RF Parity Error";
                    break;
                case 0x0823:
                    errstr = "Internal Error - TME Miscellaneous CMI Errors";
                    break;
                case 0x0824:
                    errstr = "Internal Error - TME CMI Overflow Error";
                    break;
                case 0x0825:
                    errstr = "Internal Error - TME CMI Underflow Error";
                    break;
                case 0x0826:
                    errstr = "SGX TEM Secure Bit Mismatch Detected on Demand Read";
                    break;
                case 0x0827:
                    errstr = "Internal Error - TME Detected Underfill Read Completion Data Parity Error";
                    break;
                case 0x0828:
                    errstr = "Internal Error - 2LM Scoreboard Overflow Error";
                    break;
                case 0x1008:
                    errstr = "Corr Patrol Scrub Error(Mirror Secondary)";
                    break;
                }

                AsciiStrCatS(gBuffer, sizeof(gBuffer), errstr);
                MtSupportDebugWriteLine(gBuffer);

                if (mcstatus & MCI_STATUS_ADDRV)
                    _rdmsr64(MSR_IA32_MCi_ADDR(mcbank), &mcaddr);

                if (mcstatus & MCI_STATUS_MISCV)
                    _rdmsr64(MSR_IA32_MCi_MISC(mcbank), &mcmisc);

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcbank, mcaddr);
                MtSupportDebugWriteLine(gBuffer);

                col = (UINT32)BitExtractULL(mcmisc, 9, 0);
                row = (UINT32)BitExtractULL(mcmisc, 30, 10);
                bank = (UINT8)BitExtractULL(mcmisc, 36, 31);
                rank = (UINT8)BitExtractULL(mcmisc, 49, 47);

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT " (rank=%d, bank=%d, row=%d, col=%d)", mcbank, mcmisc, rank, bank, row, col);
                MtSupportDebugWriteLine(gBuffer);

                uncorrected_error = (mcstatus & (1ll << 61)) != 0;

                addrmask = LShiftU64(1, mcmisc & 0x3F);
                addrmask = ~(addrmask - 1);

                slot = rank < 4 ? 0 : 1;

#ifdef OKN_MT86
               OKN_DIMM_ADDRESS_DETAIL OknDimmAddrDetail_ECC = {0};
			   ZeroMem(&OknDimmAddrDetail_ECC, sizeof(OKN_DIMM_ADDRESS_DETAIL));
               if (EFI_SUCCESS == OknMT_TranslatedAddressFromSystemToDimm(gOknMtProtoPtr, (UINTN)(mcaddr & addrmask), &OknDimmAddrDetail_ECC.AddrDetail)) {
                   OknDimmAddrDetail_ECC.Type = DIMM_ERROR_TYPE_DATA;
               } else {
                   OknDimmAddrDetail_ECC.Type = DIMM_ERROR_TYPE_UNKOWN;
               }
               OknMT_EnqueueError(&gOknDimmErrorQueue, &OknDimmAddrDetail_ECC);
#endif // OKN_MT86

                MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, CPUPkg, NUM_IMC_BANKS + imc * ctrl->numch + ch, slot);

                _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
                reported = TRUE;
            }
        }
        if (CurBSP != MPSupportGetBspId())
            MPSupportSwitchBSP(CurBSP);
    }

    for (UINT8 i = 0; i < NUM_IMC; i++)
    {
        if (!ctrl->membar[i])
            continue;

        UINTN baseaddr = (UINTN)(ctrl->membar[i]);

        for (ch = 0; ch < ctrl->numch; ch++)
        {
            int rank;
            for (rank = 0; rank < 4; rank++)
            {
                slot = rank < 2 ? 0 : 1;
                correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_CORRERRCNT_0(ch) + 4 * rank));

                if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                {
                    int imcslots = ctrl->numch * ctrl->numsl;
                    int index = i * imcslots + ch * ctrl->numsl + slot;

                    if ((correrrcnt & 0x00007FFF) != 0)
                        dimmerrcnt[index] += correrrcnt & 0x00007FFF;

                    // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                    if ((correrrcnt & 0x7FFF0000) != 0)
                        dimmerrcnt[index] += (correrrcnt >> 16) & 0x00007FFF;

                    // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                }
            }
        }
    }

    // compare with previous dimm error count
    for (UINT8 i = 0; i < NUM_IMC; i++)
    {
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            for (slot = 0; slot < ctrl->numsl; slot++)
            {
                int imcslots = ctrl->numch * ctrl->numsl;
                int index = i * imcslots + ch * ctrl->numsl + slot;

                if (dimmerrcnt[index] != ctrl->preverrcnt[index])
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d, Sl%d] DIMM err count=%d (prev=%d)", i, ch, slot, dimmerrcnt[index], ctrl->preverrcnt[index]);
                    MtSupportDebugWriteLine(gBuffer);
                    if (reported == FALSE)
                        MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, i * ctrl->numch + ch, slot);
                }
                ctrl->preverrcnt[index] = dimmerrcnt[index];
            }
        }
    }
}

// Reference: Intel Xeon Processor D-1500 Product Family External Design Specification(EDS), Volume Two : Core and Uncore Registers (Doc. No.: 544041, Rev.: 2.5)
void inject_icelake_sp(int index, int uncorrectable, int enable)
{
#if 0
    struct ecc_info* ctrl = NULL;

    UINT64 lt_lock_memory = 0;
    ulong capid0 = 0;

    if (index < 0 || index >= s_numctrls) return;

    ctrl = &s_ctrl[index];

    _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    //  The BIOS must unlock the memory by writing all 0s to this MSR if the following conditions exist: 
    // - CPUID.(EAX=01h):EAX[31:0] == 000306Fxh (where 'x' is any stepping number) 
    // - CPUID.(EAX=01h):ECX[6] == 1 (that is, Intel TXT capable) 
    // - PCH is TXT capable (Refer to the PCH BIOS Spec and EDS for the capability detection details) 
    // - The platform is selected to be Intel TXT disabled. 
    // For all NBSPs of each socket, before memory initialization and after QPI init is completed: MSR 2E6h == 0 
    // NOTE: Attempts to read this MSR will cause a #GP fault in any configuration. Writes to this MSR on a system with non TXT capable PCH will cause a #GP fault.
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - CPUID.(EAX=01h):EAX[31:0] = %08x", cpu_id.vers.flat);
    MtSupportDebugWriteLine(gBuffer);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - CPUID.(EAX=01h):ECX[31:0] = %08x", cpu_id.fid.uint32_array[1]);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, 30, 3, 0x84, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - PCU CAPID0 = %08x (Intel TXT = %d)", capid0, (capid0 >> 19) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid0 >> 19) & 0x1) == 0) // if Intel TXT is disabled
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - writing 0 to LT_UNLOCK_MEMORY");
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_LT_UNLOCK_MEMORY, 0); // Unlock

        _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
        MtSupportDebugWriteLine(gBuffer);

        if (lt_lock_memory & 0x1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - writing " I64HEXFMT " to LT_LOCK_MEMORY", lt_lock_memory & ~0x1ULL);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_LT_LOCK_MEMORY, lt_lock_memory & ~0x1ULL); // Unlock
        }

    }
    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        UINT64 addr_match = 0, new_addr_match = 0x100000;
        UINT64 addr_mask = 0, new_addr_mask = ~new_addr_match;

        unsigned long value, new_value;

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_LO));
        addr_match = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_match, 3);// addr_match_lower - Addr Match Lower: 32-bits (Match Addr[34:3])

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_LO), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_HI));
        addr_match |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x1FFF;
        new_value |= (unsigned long)RShiftU64(new_addr_match, 35) & 0x7FF; // Addr Match Higher : 11-Bits (Match Addr[45:35])
        new_value |= (1 << 11); //  rsp_func_addr_match_en - Enabling the Address Match Response Function when set. 
        new_value |= (1 << 12); //  rsp_func_addr_match_always - The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if this field is set. Continuous address matching.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MATCH_HI), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_LO));
        addr_mask = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_mask, 3);// addr_mask_lower - Address Mask to deselect (when set) the corresponding Addr[34:3] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_LO), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_HI));
        addr_mask |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x7FF;
        new_value |= (unsigned long)RShiftU64(new_addr_mask, 35) & 0x7FF; // addr_mask_higher - Address Mask to deselect (when set) the corresponding Addr[45:35] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_ADDR_MASK_HI), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_RANK_BANK_MATCH));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_RANK_BANK_MATCH=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_RANK_BANK_MATCH, value);
        MtSupportDebugWriteLine(gBuffer);

        if ((value & (1 << 31)) == 0) // en - Enable rank and bank matching
        {
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_RANK_BANK_MATCH), value | (1 << 31));
        }

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK), 1);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK), 1);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= 0xC3FFE0E0;
        new_value |= 0x3 << 28;
        new_value |= 0x3 << 26;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_icelake_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_ICELAKE_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA), new_value);
    }
#endif
}

void poll_timings_icelake_sp(struct ecc_info *ctrl)
{
    const int NUM_IMC = 4;
    unsigned long cpubusno_cfg = 0;
    unsigned char cpubusno[2];

    for (int mc = 0; mc < NUM_IMC; mc++)
    {
        UINTN baseaddr = (UINTN)(ctrl->membar[mc]);

        for (int ch = 0; ch < ctrl->numch; ch++)
        {
            unsigned long tcl_twl = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TCL_TWL(ch)));
            unsigned long trcd = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRCD(ch)));
            unsigned long trp_trc_tras = readmmio32((unsigned int *)(baseaddr + INTEL_ICELAKE_SP_MEMORY_TIMINGS_BANK_TRP_TRC_TRAS(ch)));

            if (tcl_twl == 0xffffffff || trcd == 0xffffffff || trp_trc_tras == 0xffffffff)
                continue;

            unsigned char tCL = BitExtract(tcl_twl, 5, 0);
            unsigned char tRCD = BitExtract(trcd, 6, 0);
            unsigned char tRAS = BitExtract(trp_trc_tras, 30, 24);
            unsigned char tRP = BitExtract(trp_trc_tras, 6, 0);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake_sp - [MC%d][Ch %d] TCL_TWL=%08x TRCD=%08x TRP_TRC_TRAS=%08x (%d-%d-%d-%d)", mc, ch, tcl_twl, trcd, trp_trc_tras, tCL, tRCD, tRP, tRAS);

            if (tCL == 0 || tRCD == 0 || tRAS == 0 || tRP == 0)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;
        }
    }

    pci_conf_read(ctrl->bus, 0, 2, INTEL_ICELAKE_SP_CPUBUSNO_CFG, 4, &cpubusno_cfg);

    cpubusno[0] = BitExtract(cpubusno_cfg, 7, 0);
    cpubusno[1] = BitExtract(cpubusno_cfg, 15, 8);

    unsigned long mc_bios_req = 0;
    pci_conf_read(cpubusno[1], 30, 1, INTEL_ICELAKE_SP_MC_BIOS_REQ_CFG, 4, &mc_bios_req);

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake_sp - MC_BIOS_REQ_CFG=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 5, 0), BitExtract(mc_bios_req, 11, 8));

    unsigned int qclk_ratio = BitExtract(mc_bios_req, 5, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_req, 11, 8);

#if 0
    unsigned long mc_bios_data = 0;
    pci_conf_read(cpubusno[1], 30, 1, INTEL_ICELAKE_SP_MC_BIOS_DATA_CFG, 4, &mc_bios_data);

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake_sp - MC_BIOS_DATA_CFG=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 5, 0), BitExtract(mc_bios_data, 11, 8));

    unsigned int qclk_ratio = BitExtract(mc_bios_data, 5, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_data, 11, 8);
#endif
    if (qclk_ratio == 0)
    {
        unsigned long capid1;
        unsigned char DMFC = 0;

        pci_conf_read(cpubusno[1], 30, 3, INTEL_ICELAKE_SP_CAPID1_CFG, 4, &capid1);
        DMFC = BitExtract(capid1, 29, 26);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_icelake_sp - CAPID1_CFG=0x%08x (DMFC=%1x)", capid1, DMFC);

        switch (DMFC)
        {
        case 0b110:
            ctrl->memclk = 1600;
            break;
        case 0b101:
            ctrl->memclk = 1867;
            break;
        case 0b100:
            ctrl->memclk = 2133;
            break;
        case 0b011:
            ctrl->memclk = 2400;
            break;
        case 0b010:
            ctrl->memclk = 2667;
            break;
        case 0b001:
            ctrl->memclk = 2933;
            break;
        case 0b000:
            ctrl->memclk = 3200;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
        else // 1: 100.00Mhz
            ctrl->memclk = qclk_ratio * 100 / 2;
    }
}

/*
 * Emerald Rapids-SP (Emerald Rapids Scalable Performance)
 *
 * Reference: 5th Gen Intel Xeon Processor Scalable Family, Codename Emerald Rapids Processor Registers Specification (Doc. No.: 723370, Rev.: 2.0)
 */
#define INTEL_EMERALDRAPIDS_SP_MCMTR(ch) (0x20EF8 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_SCRUBCTL(ch) (0x20E28 + ch * 0x8000)

#define INTEL_EMERALDRAPIDS_SP_MC0_DP_CHKN_BIT(ch) (0x23414 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_DIS_CORR_ERR_LOG(ch) (0x22D24 + ch * 0x8000)

#define INTEL_EMERALDRAPIDS_SP_CORRERRCNT_0(ch) (0x22C18 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRCNT_1(ch) (0x22C1C + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRCNT_2(ch) (0x22C20 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRCNT_3(ch) (0x22C24 + ch * 0x8000)

#define INTEL_EMERALDRAPIDS_SP_CORRERRTHRSHLD_0(ch) (0x22C30 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRTHRSHLD_1(ch) (0x22C34 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRTHRSHLD_2(ch) (0x22C38 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_CORRERRTHRSHLD_3(ch) (0x22C3C + ch * 0x8000)

#define INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRCD(ch) (0x21AB8 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TCL_TWL(ch) (0x21AB0 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRTP_TWR(ch) (0x21AD0 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRP_TRC_TRAS(ch) (0x21AC8 + ch * 0x8000)
#define INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRDA_TWRA_TWRPRE(ch) (0x21AC0 + ch * 0x8000)

#define INTEL_EMERALDRAPIDS_SP_CAPID1_CFG 0x88
#define INTEL_EMERALDRAPIDS_SP_CAPID3_CFG 0x90
#define INTEL_EMERALDRAPIDS_SP_DEFEATURES0 0xe4

#define INTEL_EMERALDRAPIDS_SP_MMCFG_BASE 0x90
#define INTEL_EMERALDRAPIDS_SP_MMCFG_LIMIT 0x98

#define INTEL_EMERALDRAPIDS_SP_MMIO_BASE 0xD0

#define INTEL_EMERALDRAPIDS_SP_MEM0_BAR 0xD8
#define INTEL_EMERALDRAPIDS_SP_MEM1_BAR 0xDC
#define INTEL_EMERALDRAPIDS_SP_MEM2_BAR 0xE0
#define INTEL_EMERALDRAPIDS_SP_MEM3_BAR 0xE4
#define INTEL_EMERALDRAPIDS_SP_MEM4_BAR 0xE8
#define INTEL_EMERALDRAPIDS_SP_MEM5_BAR 0xEC
#define INTEL_EMERALDRAPIDS_SP_MEM6_BAR 0xF0
#define INTEL_EMERALDRAPIDS_SP_MEM7_BAR 0xF4

#define INTEL_EMERALDRAPIDS_SP_MC_BIOS_REQ_CFG 0x98
#define INTEL_EMERALDRAPIDS_SP_MC_BIOS_DATA_CFG 0x9C

#define INTEL_EMERALDRAPIDS_SP_CPUBUSNO_CFG 0xD0

#define MSR_CPU_BUSNUMBER 0x128

static void setup_emeraldrapids_sp(struct ecc_info *ctrl)
{
    unsigned long val = 0;
    unsigned long cpubusno_cfg = 0;
    unsigned long capid3 = 0;
    unsigned long mc_mtr = 0, mc_scrubctl = 0;
    unsigned long pci_id = 0;
    UINT64 mmcfg = 0, mmcfglim = 0;
    unsigned int correrrcnt = 0, correrrthrshld = 0;

    int i;
    int rank;
    int ch, slot;

    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;
    int numbanks = 0;

    const int NUM_IMC = 4;
    const int CH_PER_IMC = 2;
    const int NUM_IMC_BANKS = NUM_IMC * CH_PER_IMC;

    unsigned char cpubusno[2];

    UINTN CPUPkg = 0;
    UINTN NumPkg = MPSupportGetNumPackages();

    MtSupportDebugWriteLine("Intel Emerald Rapids-SP chipset init");

    // Nehalem supports Scrubbing */
    ctrl->cap = ECC_SCRUB;
    ctrl->mode = ECC_NONE;
    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;
    ctrl->mchbar = 0;

    pci_conf_read(ctrl->bus, 0, 2, INTEL_EMERALDRAPIDS_SP_CPUBUSNO_CFG, 4, &cpubusno_cfg);
    AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP CPUBUSNO_CFG=%08x", cpubusno_cfg);
    MtSupportDebugWriteLine(gBuffer);

    cpubusno[0] = BitExtract(cpubusno_cfg, 7, 0);
    cpubusno[1] = BitExtract(cpubusno_cfg, 15, 8);

    pci_conf_read(cpubusno[1], 30, 3, INTEL_EMERALDRAPIDS_SP_CAPID3_CFG, 4, &capid3);
    AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP - CAPID3 = %08x (DISABLE_ECC = %d)", capid3, (capid3 >> 10) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid3 >> 10) & 0x1) == 0) // DISABLE_ECC = 0
    {
        ctrl->mode = ECC_CORRECT;
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    if (1)
    {
        unsigned long mmcfg_hi = 0, mmcfg_lo = 0;
        unsigned long mmcfglim_hi = 0, mmcfglim_lo = 0;
        pci_conf_read(0, 0, 0, INTEL_EMERALDRAPIDS_SP_MMCFG_BASE, 4, &mmcfg_lo);
        pci_conf_read(0, 0, 0, INTEL_EMERALDRAPIDS_SP_MMCFG_BASE + 4, 4, &mmcfg_hi);
        mmcfg = LShiftU64(BitExtractULL(LShiftU64(mmcfg_hi, 32) | mmcfg_lo, 51, 26), 26);

        pci_conf_read(0, 0, 0, INTEL_EMERALDRAPIDS_SP_MMCFG_LIMIT, 4, &mmcfglim_lo);
        pci_conf_read(0, 0, 0, INTEL_EMERALDRAPIDS_SP_MMCFG_LIMIT + 4, 4, &mmcfglim_hi);
        mmcfglim = LShiftU64(BitExtractULL(LShiftU64(mmcfglim_hi, 32) | mmcfglim_lo, 51, 26), 26);

        AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP MMCFGBase=" I64HEXFMT ", MMCFGLim=" I64HEXFMT, mmcfg, mmcfglim);
        MtSupportDebugWriteLine(gBuffer);
    }
    else
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP Device 0, Function 0 not found");
        MtSupportDebugWriteLine(gBuffer);

        pci_conf_read(cpubusno[1], 29, 1, 0, 4, &pci_id);
        if (pci_id == 0x34578086)
        {
            unsigned long mmcfg_rule_hi = 0;
            unsigned long mmcfg_rule_lo = 0;
            UINT64 mmcfg_rule;

            pci_conf_read(cpubusno[1], 29, 1, 0xc0, 4, &mmcfg_rule_lo);
            pci_conf_read(cpubusno[1], 29, 1, 0xc4, 4, &mmcfg_rule_hi);

            mmcfg_rule = LShiftU64(mmcfg_rule_hi, 32) | mmcfg_rule_lo;

            if (mmcfg_rule & 0x01)
            {
                mmcfg = mmcfglim = mmcfg_rule & 0xFFFFFFC000000ULL;
                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [Bus:%02X Dev:%02X Fun:%02X Reg:%02X] MMCFG_Rule=" I64HEXFMT ", MMCFG=" I64HEXFMT, cpubusno[1], 29, 1, 0xc0, mmcfg_rule, mmcfg);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }
    ctrl->mchbar = mmcfg;

    pci_conf_read(cpubusno[0], 0, 1, INTEL_EMERALDRAPIDS_SP_MMIO_BASE, 4, &val);
    AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP MMIO_BASE=%08x", val);
    MtSupportDebugWriteLine(gBuffer);

    UINT64 mmio_base = LShiftU64(BitExtract(val, 28, 0), 23);

    // Get MEM0_BAR - MEM8_BAR register
    for (i = 0; i < NUM_IMC; i++)
    {
        unsigned long mem_bar = 0, mem_bar_lim = 0;

        pci_conf_read(cpubusno[0], 0, 1, INTEL_EMERALDRAPIDS_SP_MEM0_BAR + 4 * i, 4, &val);
        AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP MEM%d_BAR=%08x", i, val);
        MtSupportDebugWriteLine(gBuffer);
        if (BitExtract(val, 31, 31)) // VALID: 1 is valid BAR and 0 is invalid BAR
        {
            mem_bar = BitExtract(val, 10, 0) << 12;
            mem_bar_lim = BitExtract(val, 23, 13) << 12;
            AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP MEM%d_BAR BASE_ADDR=%08x, LIMIT=%08x", i, mem_bar, mem_bar_lim);
            MtSupportDebugWriteLine(gBuffer);
        }

        if (mem_bar > 0 && mem_bar_lim > 0 && mem_bar <= mem_bar_lim) // Sanity check
        {
            ctrl->membar[i] = mmio_base | mem_bar;

            AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d] MMIO Base=" I64HEXFMT, i, ctrl->membar[i]);
            MtSupportDebugWriteLine(gBuffer);

            for (ch = 0; ch < ctrl->numch; ch++)
            {
                UINTN baseaddr = (UINTN)(ctrl->membar[i]);
                /* Check for ECC & Scrub */
                mc_mtr = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_MCMTR(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] MCMTR=%08x", i, ch, mc_mtr);
                MtSupportDebugWriteLine(gBuffer);

                if (mc_mtr == 0xffffffff)
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] registers may not exist", i, ch);
                    MtSupportDebugWriteLine(gBuffer);
                    continue;
                }

                unsigned long chn_disable = BitExtract(mc_mtr, 18, 18);
                if (!chn_disable)
                    ctrl->chmode++;

                unsigned long ecc_en = BitExtract(mc_mtr, 2, 2);
                if (ecc_en)
                    ctrl->mode |= ECC_CORRECT;

                mc_scrubctl = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_SCRUBCTL(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] SCRUBCTL=%08x", i, ch, mc_scrubctl);
                MtSupportDebugWriteLine(gBuffer);

                unsigned long scrub_en = BitExtract(mc_scrubctl, 31, 31);
                if (scrub_en)
                    ctrl->mode |= ECC_SCRUB;

                // Read corrected error/threshold registers
                val = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_DIS_CORR_ERR_LOG(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] dis_corr_err_log=%08x", i, ch, val);
                MtSupportDebugWriteLine(gBuffer);

                val = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_MC0_DP_CHKN_BIT(ch)));

                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] MC0_DP_CHKN_BIT=%08x", i, ch, val);
                MtSupportDebugWriteLine(gBuffer);

                for (rank = 0; rank < 4; rank++)
                {
                    slot = rank < 2 ? 0 : 1;

                    // Read corrected error/threshold registers
                    correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_CORRERRCNT_0(ch) + 4 * rank));
                    correrrthrshld = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_CORRERRTHRSHLD_0(ch) + 4 * rank));

                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d, Sl%d] CORRERRCNT_%d=%08x, CORRERRTHRSHLD_%d=%08x", i, ch, slot, rank, correrrcnt, rank, correrrthrshld);
                    MtSupportDebugWriteLine(gBuffer);

                    // Clear error count
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                        writemmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_CORRERRCNT_0(ch) + 4 * rank), 0x80008000);

                    // Record the current error count
                    correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_CORRERRCNT_0(ch) + 4 * rank));
                    if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                    {
                        int imcslots = ctrl->numch * ctrl->numsl;
                        int index = i * imcslots + ch * ctrl->numsl + slot;
                        if ((correrrcnt & 0x00007FFF) != 0)
                            ctrl->preverrcnt[index] += correrrcnt & 0x00007FFF;

                        if ((correrrcnt & 0x7FFF0000) != 0)
                            ctrl->preverrcnt[index] += (correrrcnt >> 16) & 0x00007FFF;
                    }
                }
            }
        }
    }

    for (CPUPkg = 0; CPUPkg < NumPkg; CPUPkg++)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Emerald Rapids-SP CPU Pkg %d MCA registers", CPUPkg);
        UINTN CurBSP = MPSupportGetBspId();

        if (MPSupportSwitchPkg(CPUPkg) != EFI_SUCCESS)
            continue;

        // ECC errors also reported in the MSR, read and clear any previous errors
        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
        numbanks = mcgcap & 0xff;

        AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP MCG_CAP=" I64HEXFMT " (banks=%d), MCG_STATUS=" I64HEXFMT, mcgcap, numbanks, mcgstatus);
        MtSupportDebugWriteLine(gBuffer);

        for (i = 0; i < NUM_IMC_BANKS; i++)
        {
            UINT64 mcctl = 0;
            UINT64 mcstatus = 0;

            // IMC registers are in MSR MC banks 13-20 (4 IMC * 2 Ch)
            int mcbank = 13 + i;
            int imc = i / ctrl->numch;
            ch = i % ctrl->numch;

            if (mcbank >= numbanks)
                break;

            _rdmsr64(MSR_IA32_MCi_CTL(mcbank), &mcctl);
            AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] MC%d_CTL=" I64HEXFMT, imc, ch, mcbank, mcctl);
            MtSupportDebugWriteLine(gBuffer);

            _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

            if (mcstatus)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "Emerald Rapids-SP [IMC%d, Ch%d] MC%d_STATUS=" I64HEXFMT, imc, ch, mcbank, mcstatus);
                MtSupportDebugWriteLine(gBuffer);
                _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
            }
        }

        if (CurBSP != MPSupportGetBspId())
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "Switching BSP back to %d", (int)CurBSP);
            MtSupportDebugWriteLine(gBuffer);

            MPSupportSwitchBSP(CurBSP);
        }
    }
}

static void poll_emeraldrapids_sp(struct ecc_info *ctrl)
{
    UINT64 mcgcap = 0;
    UINT64 mcgstatus = 0;
    int numbanks = 0;

    unsigned int correrrcnt = 0; // , correrrorstatus = 0;
    unsigned int dimmerrcnt[MAX_UMC * MAX_SLOTS_PER_UMC];

    const UINT8 NUM_IMC = 4;
    const UINT8 CH_PER_IMC = 2;
    const UINT8 NUM_IMC_BANKS = NUM_IMC * CH_PER_IMC;

    UINT8 ch, slot;

    UINTN NumPkg = MPSupportGetNumPackages();

    BOOLEAN reported = FALSE;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);
    for (UINT8 CPUPkg = 0; CPUPkg < NumPkg; CPUPkg++)
    {
        UINTN CurBSP = MPSupportGetBspId();

        if (MPSupportSwitchPkg(CPUPkg) != EFI_SUCCESS)
            continue;

        _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);
        _rdmsr64(MSR_IA32_MCG_STATUS, &mcgstatus);
        numbanks = mcgcap & 0xff;

        for (UINT8 i = 0; i < NUM_IMC_BANKS; i++)
        {
            UINT64 mcstatus = 0;
            UINT64 mcmisc = 0;
            UINT64 mcaddr = 0;

            // IMC registers are in MSR MC banks 13-20 (4 IMC * 2 Ch)
            int mcbank = 13 + i;
            UINT8 imc = i / ctrl->numch;
            ch = i % ctrl->numch;

            if (mcbank >= numbanks)
                break;

            _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

            if (mcstatus & MCI_STATUS_VAL)
            {
                BOOLEAN uncorrected_error;
                UINT32 mserr;
                UINT64 addrmask;
                CHAR8 *errstr = "";

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)", mcbank, mcstatus,
                            BitExtractULL(mcstatus, 62, 62) != 0 ? L"Yes" : L"No",
                            BitExtractULL(mcstatus, 61, 61) != 0 ? L"Yes" : L"No",
                            (UINT32)BitExtractULL(mcstatus, 51, 38),
                            (UINT32)BitExtractULL(mcstatus, 15, 0));
                MtSupportDebugWriteLine(gBuffer);

                // MCACOD:
                //  Specifies the machine check architecture defined error code for the machine check error condition
                //  detected
                //  Memory Controller error format : 0000 0000 1MMM CCCC
                //  Memory Controller error format : 0000 0010 1MMM CCCC
                if ((mcstatus & 0xef80) == 0x80)
                {
                    UINT32 xacttype = (UINT32)BitExtractULL(mcstatus, 6, 4);

                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d] Transaction error type : ", imc, ch);
                    switch (xacttype)
                    {
                    case 0:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                        break;
                    case 1:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                        break;
                    case 2:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                        break;
                    case 3:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                        break;
                    case 4:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                        break;
                    default:
                        AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                        break;
                    }
                    MtSupportDebugWriteLine(gBuffer);
                }
                else
                    MtSupportDebugWriteLine("**WARNING** Not memory controller error");

                // MSCOD:
                //  Specifies a model specific error code that uniquely identifies the machine check error condition
                //  that has been detected
                AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d] Model specific error: ", imc, ch);
                mserr = (UINT32)BitExtractULL(mcstatus, 31, 16);

                errstr = "";
                switch (mserr)
                {
                case 0x0001:
                    errstr = "Internal Error - End-End Address Parity Error (APPP)";
                    break;
                case 0x0002:
                    errstr = "Internal Error - Write Data Parity Error";
                    break;
                case 0x0003:
                    errstr = "Internal Error - End-End Uncorr/Corr Wr Data ECC Error";
                    break;
                case 0x0004:
                    errstr = "Internal Error - Write Byte Enable Parity Error";
                    break;
                case 0x0007:
                    errstr = "Internal Error - Transaction ID Parity Error";
                    break;
                case 0x0008:
                    errstr = "Corr Patrol Scrub Error (Non-Mirror or Mirror Primary)";
                    break;
                case 0x0010:
                    errstr = "UnCorr Patrol Scrub Error (Non-mirror or Mirror Primary)";
                    break;
                case 0x0020:
                    errstr = "Correctable Spare Error (Non-mirror or Mirror Primary)";
                    break;
                case 0x0040:
                    errstr = "Uncorrectable Spare Error (Non-mirror or Mirror Primary)";
                    break;
                case 0x0080:
                    errstr = "Transient or Correctable Error for Demand or Underfill Reads (Non Mirror or Mirror Primary) or Read 2LM MetaData Error";
                    break;
                case 0x00A0:
                    errstr = "Uncorrectable Error for Demand or Underfill Reads (Non Mirror or Mirror Primary)";
                    break;
                case 0x00C0:
                    errstr = "Read 2LM MetaData Error";
                    break;
                case 0x0100:
                    errstr = "Internal WDB read parity error";
                    break;
                case 0x0108:
                    errstr = "DDR/DDRT Link Fail";
                    break;
                case 0x0200:
                    errstr = "DDR5 CA Parity or WrCRC Error";
                    break;
                case 0x0400:
                    errstr = "Internal Parity Error - RPQ Scheduler Address Parity";
                    break;
                case 0x0800:
                    errstr = "DDRT2 Errors";
                    break;
                case 0x0801:
                    errstr = "Internal Error - 2LM read response to an invalid scoreboard entry";
                    break;
                case 0x0802:
                    errstr = "Internal Error - 2LM unexpected read response";
                    break;
                case 0x0803:
                    errstr = "Internal Error - 2LM DDR4 completion to an invalid scoreboard entry";
                    break;
                case 0x0804:
                    errstr = "Internal Error - 2LM DDRt completion to an invalid scoreboard entry";
                    break;
                case 0x0805:
                    errstr = "Internal Error - 2LM completion FIFO overflow";
                    break;
                case 0x0806:
                    errstr = "DDRT2 RID Correctable Parity error";
                    break;
                case 0x0807:
                    errstr = "DDRT2 RID Uncorrectable error";
                    break;
                case 0x0808:
                    errstr = "DDRT2 interrupt received while outstanding interrupt was not ACKed";
                    break;
                case 0x0809:
                    errstr = "Internal Error - DDRT2 RID FIFO overflow";
                    break;
                case 0x080A:
                    errstr = "Internal FW Error - DDRT2 Error on FNV Write credits";
                    break;
                case 0x080B:
                    errstr = "DDRT2 error";
                    break;
                case 0x080C:
                    errstr = "DDRT2 error";
                    break;
                case 0x080D:
                    errstr = "DDRT2 FNV Error (CAParity or WrECC Error)";
                    break;
                case 0x080E:
                    errstr = "DDRT2 FNV Thermal Error";
                    break;
                case 0x080F:
                case 0x0810:
                case 0x0811:
                case 0x0812:
                    errstr = "Internal DDRT2 Error";
                    break;
                case 0x0813:
                case 0x0814:
                case 0x0815:
                    errstr = "Internal iMC Error";
                    break;
                case 0x0816:
                    errstr = "DDRT2 Link Read ECC Error";
                    break;
                case 0x0817:
                case 0x0818:
                case 0x0819:
                case 0x081a:
                case 0x081b:
                case 0x081c:
                case 0x081d:
                case 0x081e:
                case 0x081f:
                case 0x0820:
                case 0x0821:
                case 0x0822:
                case 0x0823:
                case 0x0824:
                case 0x0825:
                    errstr = "Internal iMC Error";
                    break;
                case 0x0826:
                    errstr = "Security Fault";
                    break;
                case 0x0827:
                    errstr = "Internal iMC Error";
                    break;
                case 0x0829:
                    errstr = "MC Internal Errors";
                    break;
                case 0x082A:
                case 0x082B:
                case 0x082C:
                    errstr = "Security Fault";
                    break;
                case 0x082E:
                    errstr = "Internal Fault";
                    break;
                case 0x1008:
                    errstr = "Corr Patrol Scrub Error (Mirror Secondary)";
                    break;
                case 0x1010:
                    errstr = "UnCorr Patrol Scrub Error (Mirror Secondary)";
                    break;
                case 0x1020:
                    errstr = "Corr Spare Error (Mirror Secondary)";
                    break;
                case 0x1040:
                    errstr = "UnCorr Spare Error (Mirror Secondary)";
                    break;
                case 0x1080:
                    errstr = "Transient or Correctable Error for Demand or Underfill Reads (Mirror Secondary)";
                    break;
                case 0x10A0:
                    errstr = "Uncorrectable Error for Demand or Underfill Reads (Mirror Secondary)";
                    break;
                default:
                    errstr = "Unknown error";
                    break;
                }

                AsciiStrCatS(gBuffer, sizeof(gBuffer), errstr);
                MtSupportDebugWriteLine(gBuffer);

                if (mcstatus & MCI_STATUS_ADDRV)
                    _rdmsr64(MSR_IA32_MCi_ADDR(mcbank), &mcaddr);

                if (mcstatus & MCI_STATUS_MISCV)
                    _rdmsr64(MSR_IA32_MCi_MISC(mcbank), &mcmisc);

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcbank, mcaddr);
                MtSupportDebugWriteLine(gBuffer);

                const int EXTRA_ERR_INFO_LSB = 9;
                int transient = (int)BitExtractULL(mcmisc, 54 + EXTRA_ERR_INFO_LSB, 54 + EXTRA_ERR_INFO_LSB);
                int ecc_mode = (int)BitExtractULL(mcmisc, 53 + EXTRA_ERR_INFO_LSB, 50 + EXTRA_ERR_INFO_LSB);
                UINT8 cs = (UINT8)BitExtractULL(mcmisc, 49 + EXTRA_ERR_INFO_LSB, 47 + EXTRA_ERR_INFO_LSB);
                UINT8 sub_rank = (UINT8)BitExtractULL(mcmisc, 45 + EXTRA_ERR_INFO_LSB, 43 + EXTRA_ERR_INFO_LSB);
                int adddc = (int)BitExtractULL(mcmisc, 39 + EXTRA_ERR_INFO_LSB, 34 + EXTRA_ERR_INFO_LSB);
                UINT8 bank = (UINT8)BitExtractULL(mcmisc, 33 + EXTRA_ERR_INFO_LSB, 28 + EXTRA_ERR_INFO_LSB);
                UINT32 row = (UINT32)BitExtractULL(mcmisc, 27 + EXTRA_ERR_INFO_LSB, 10 + EXTRA_ERR_INFO_LSB);
                UINT32 col = (UINT32)BitExtractULL(mcmisc, 9 + EXTRA_ERR_INFO_LSB, 0 + EXTRA_ERR_INFO_LSB);
                UINT8 addr_mode = (UINT8)BitExtractULL(mcmisc, 8, 6);
                UINT8 rec_err_lsb = (UINT8)BitExtractULL(mcmisc, 5, 0);
                UINT8 rank = cs % 4;
                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT " (transient=%d, ecc_mode=%d, cs=%d (rank=%d), sub_rank=%d, adddc=%d, bank=0x%d, row=0x%x, col=0x%x, addr_mode=%d, rec_err_lsb=%d)", mcbank, mcmisc, transient, ecc_mode, cs, rank, sub_rank, adddc, bank, row, col, addr_mode, rec_err_lsb);
                MtSupportDebugWriteLine(gBuffer);

                uncorrected_error = BitExtractULL(mcstatus, 61, 61) != 0;

                // REC_ERR_LSB:
                //  Specifies the LSB of the recoverable address(this may differ from unit to unit).This tells the OS to
                //  ignore bits from LSB - 1 : 0
                addrmask = LShiftU64(1, rec_err_lsb);
                addrmask = ~(addrmask - 1);

                slot = cs / 4;

                MtSupportReportECCError((UINTN)(mcaddr & addrmask), !uncorrected_error, -1, CPUPkg, NUM_IMC_BANKS + imc * ctrl->numch + ch, slot);

                _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
                reported = TRUE;
            }
        }
        if (CurBSP != MPSupportGetBspId())
            MPSupportSwitchBSP(CurBSP);
    }

    for (UINT8 i = 0; i < NUM_IMC; i++)
    {
        if (!ctrl->membar[i])
            continue;

        UINTN baseaddr = (UINTN)(ctrl->membar[i]);

        for (ch = 0; ch < ctrl->numch; ch++)
        {
            int rank;
            for (rank = 0; rank < 4; rank++)
            {
                slot = rank < 2 ? 0 : 1;
                correrrcnt = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_CORRERRCNT_0(ch) + 4 * rank));

                if (correrrcnt != 0 && correrrcnt != 0xffffffff)
                {
                    int imcslots = ctrl->numch * ctrl->numsl;
                    int index = i * imcslots + ch * ctrl->numsl + slot;

                    if ((correrrcnt & 0x00007FFF) != 0)
                        dimmerrcnt[index] += correrrcnt & 0x00007FFF;

                    // MtSupportReportECCError_dimm(0,0,0,rank * 2, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);

                    if ((correrrcnt & 0x7FFF0000) != 0)
                        dimmerrcnt[index] += (correrrcnt >> 16) & 0x00007FFF;

                    // MtSupportReportECCError_dimm(0,0,0,rank * 2 + 1, TRUE, -1, dev <= 3 ? dev : dev-6, rank < 2 ? 0 : 1);
                }
            }
        }
    }

    // compare with previous dimm error count
    for (UINT8 i = 0; i < NUM_IMC; i++)
    {
        for (ch = 0; ch < ctrl->numch; ch++)
        {
            for (slot = 0; slot < ctrl->numsl; slot++)
            {
                int imcslots = ctrl->numch * ctrl->numsl;
                int index = i * imcslots + ch * ctrl->numsl + slot;

                if (dimmerrcnt[index] != ctrl->preverrcnt[index])
                {
                    AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d, Ch%d, Sl%d] DIMM err count=%d (prev=%d)", i, ch, slot, dimmerrcnt[index], ctrl->preverrcnt[index]);
                    MtSupportDebugWriteLine(gBuffer);
                    if (reported == FALSE)
                        MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, i * ctrl->numch + ch, slot);
                }
                ctrl->preverrcnt[index] = dimmerrcnt[index];
            }
        }
    }
}

// Reference: Intel Xeon Processor D-1500 Product Family External Design Specification(EDS), Volume Two : Core and Uncore Registers (Doc. No.: 544041, Rev.: 2.5)
void inject_emeraldrapids_sp(int index, int uncorrectable, int enable)
{
#if 0
    struct ecc_info* ctrl = NULL;

    UINT64 lt_lock_memory = 0;
    ulong capid0 = 0;

    if (index < 0 || index >= s_numctrls) return;

    ctrl = &s_ctrl[index];

    _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    //  The BIOS must unlock the memory by writing all 0s to this MSR if the following conditions exist: 
    // - CPUID.(EAX=01h):EAX[31:0] == 000306Fxh (where 'x' is any stepping number) 
    // - CPUID.(EAX=01h):ECX[6] == 1 (that is, Intel TXT capable) 
    // - PCH is TXT capable (Refer to the PCH BIOS Spec and EDS for the capability detection details) 
    // - The platform is selected to be Intel TXT disabled. 
    // For all NBSPs of each socket, before memory initialization and after QPI init is completed: MSR 2E6h == 0 
    // NOTE: Attempts to read this MSR will cause a #GP fault in any configuration. Writes to this MSR on a system with non TXT capable PCH will cause a #GP fault.
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - CPUID.(EAX=01h):EAX[31:0] = %08x", cpu_id.vers.flat);
    MtSupportDebugWriteLine(gBuffer);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - CPUID.(EAX=01h):ECX[31:0] = %08x", cpu_id.fid.uint32_array[1]);
    MtSupportDebugWriteLine(gBuffer);

    pci_conf_read(ctrl->bus, 30, 3, 0x84, 4, &capid0);
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - PCU CAPID0 = %08x (Intel TXT = %d)", capid0, (capid0 >> 19) & 0x1);
    MtSupportDebugWriteLine(gBuffer);

    if (((capid0 >> 19) & 0x1) == 0) // if Intel TXT is disabled
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - writing 0 to LT_UNLOCK_MEMORY");
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_LT_UNLOCK_MEMORY, 0); // Unlock

        _rdmsr64(MSR_IA32_LT_LOCK_MEMORY, &lt_lock_memory);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - LT_LOCK_MEMORY = " I64HEXFMT " (%s)", lt_lock_memory, (lt_lock_memory & 0x1) ? L"locked" : L"unlocked");
        MtSupportDebugWriteLine(gBuffer);

        if (lt_lock_memory & 0x1)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - writing " I64HEXFMT " to LT_LOCK_MEMORY", lt_lock_memory & ~0x1ULL);
            MtSupportDebugWriteLine(gBuffer);

            _wrmsr64(MSR_IA32_LT_LOCK_MEMORY, lt_lock_memory & ~0x1ULL); // Unlock
        }

    }
    // Collect the error counts for each dimm
    if (ctrl->mchbar != 0)
    {
        UINT64 addr_match = 0, new_addr_match = 0x100000;
        UINT64 addr_mask = 0, new_addr_mask = ~new_addr_match;

        unsigned long value, new_value;

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_LO));
        addr_match = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_match, 3);// addr_match_lower - Addr Match Lower: 32-bits (Match Addr[34:3])

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_LO), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_HI));
        addr_match |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x1FFF;
        new_value |= (unsigned long)RShiftU64(new_addr_match, 35) & 0x7FF; // Addr Match Higher : 11-Bits (Match Addr[45:35])
        new_value |= (1 << 11); //  rsp_func_addr_match_en - Enabling the Address Match Response Function when set. 
        new_value |= (1 << 12); //  rsp_func_addr_match_always - The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if this field is set. Continuous address matching.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MATCH_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MATCH_HI), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_LO));
        addr_mask = (UINT64)value << 3;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_LO, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = (unsigned long)RShiftU64(new_addr_mask, 3);// addr_mask_lower - Address Mask to deselect (when set) the corresponding Addr[34:3] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_LO=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_LO, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_LO), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_HI));
        addr_mask |= ((UINT64)value & 0x7FF) << 35;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_HI, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= ~0x7FF;
        new_value |= (unsigned long)RShiftU64(new_addr_mask, 35) & 0x7FF; // addr_mask_higher - Address Mask to deselect (when set) the corresponding Addr[45:35] for the address match.

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_ADDR_MASK_HI=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_HI, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_ADDR_MASK_HI), new_value);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_RANK_BANK_MATCH));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_RANK_BANK_MATCH=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_RANK_BANK_MATCH, value);
        MtSupportDebugWriteLine(gBuffer);

        if ((value & (1 << 31)) == 0) // en - Enable rank and bank matching
        {
            writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_RANK_BANK_MATCH), value | (1 << 31));
        }

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK), 1);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK, value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK), 1);

        value = readmmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA));

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, value);
        MtSupportDebugWriteLine(gBuffer);

        new_value = value;
        new_value &= 0xC3FFE0E0;
        new_value |= 0x3 << 28;
        new_value |= 0x3 << 26;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_emeraldrapids_sp - [Bus:%02X Dev:%02X Fun:%02X Reg:%X] new RSP_FUNC_CRC_ERR_INJ_EXTRA=%08x", ctrl->bus, ctrl->dev, ctrl->fn, INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA, new_value);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int*)((UINTN)ctrl->mchbar + (ctrl->bus * 0x100000) + (ctrl->dev * 0x8000) + (ctrl->fn * 0x1000) + INTEL_EMERALDRAPIDS_SP_RSP_FUNC_CRC_ERR_INJ_EXTRA), new_value);
    }
#endif
}

void poll_timings_emeraldrapids_sp(struct ecc_info *ctrl)
{
    const int NUM_IMC = 4;
    unsigned long cpubusno_cfg = 0;
    unsigned char cpubusno[2];

    for (int mc = 0; mc < NUM_IMC; mc++)
    {
        UINTN baseaddr = (UINTN)(ctrl->membar[mc]);

        for (int ch = 0; ch < ctrl->numch; ch++)
        {

            unsigned long tcl_twl = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TCL_TWL(ch)));
            unsigned long trcd = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRCD(ch)));
            unsigned long trp_trc_tras = readmmio32((unsigned int *)(baseaddr + INTEL_EMERALDRAPIDS_SP_MEMORY_TIMINGS_BANK_TRP_TRC_TRAS(ch)));

            if (tcl_twl == 0xffffffff || trcd == 0xffffffff || trp_trc_tras == 0xffffffff)
                continue;

            unsigned char tCL = BitExtract(tcl_twl, 5, 0);
            unsigned char tRCD = BitExtract(trcd, 6, 0);
            unsigned char tRAS = BitExtract(trp_trc_tras, 30, 24);
            unsigned char tRP = BitExtract(trp_trc_tras, 6, 0);

            AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_emeraldrapids_sp - [MC%d][Ch %d] TCL_TWL=%08x TRCD=%08x TRP_TRC_TRAS=%08x (%d-%d-%d-%d)", mc, ch, tcl_twl, trcd, trp_trc_tras, tCL, tRCD, tRP, tRAS);

            if (tCL == 0 || tRCD == 0 || tRAS == 0 || tRP == 0)
                continue;

            ctrl->tAA = tCL;
            ctrl->tRCD = tRCD;
            ctrl->tRAS = tRAS;
            ctrl->tRP = tRP;
        }
    }

    pci_conf_read(ctrl->bus, 0, 2, INTEL_EMERALDRAPIDS_SP_CPUBUSNO_CFG, 4, &cpubusno_cfg);

    cpubusno[0] = BitExtract(cpubusno_cfg, 7, 0);
    cpubusno[1] = BitExtract(cpubusno_cfg, 15, 8);

    unsigned long mc_bios_req = 0;
    pci_conf_read(cpubusno[1], 30, 1, INTEL_EMERALDRAPIDS_SP_MC_BIOS_REQ_CFG, 4, &mc_bios_req);

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_emeraldrapids_sp - MC_BIOS_REQ_CFG=%08x (REQ_DATA=%d, REQ_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 5, 0), BitExtract(mc_bios_req, 11, 8));

    unsigned int qclk_ratio = BitExtract(mc_bios_req, 5, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_req, 11, 8);

#if 0
    unsigned long mc_bios_data = 0;
    pci_conf_read(cpubusno[1], 30, 1, INTEL_EMERALDRAPIDS_SP_MC_BIOS_DATA_CFG, 4, &mc_bios_data);

    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_emeraldrapids_sp - MC_BIOS_DATA_CFG=%08x (MC_FREQ=%d, MC_FREQ_TYPE=%d)", mc_bios_data, BitExtract(mc_bios_data, 5, 0), BitExtract(mc_bios_data, 11, 8));

    unsigned int qclk_ratio = BitExtract(mc_bios_data, 5, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_data, 11, 8);
#endif
    if (qclk_ratio == 0)
    {
        unsigned long capid1;
        unsigned char DMFC = 0;

        pci_conf_read(cpubusno[1], 30, 3, INTEL_EMERALDRAPIDS_SP_CAPID1_CFG, 4, &capid1);
        DMFC = BitExtract(capid1, 29, 26);

        switch (DMFC)
        {
        case 0b110:
            ctrl->memclk = 1600;
            break;
        case 0b101:
            ctrl->memclk = 1867;
            break;
        case 0b100:
            ctrl->memclk = 2133;
            break;
        case 0b011:
            ctrl->memclk = 2400;
            break;
        case 0b010:
            ctrl->memclk = 2667;
            break;
        case 0b001:
            ctrl->memclk = 2933;
            break;
        case 0b000:
            ctrl->memclk = 3200;
            break;
        }
    }
    else
    {
        // MCLK = Reference Clock x QCLK Ratio
        if (qclk_ref == 0) // DDR QCLK REFERENCE. 0=133Mhz
            ctrl->memclk = (qclk_ratio * 400 / 3) / 2;
        else // 1: 100.00Mhz
            ctrl->memclk = qclk_ratio * 100 / 2;
    }
}

static void poll_i875(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long des;
    unsigned long syndrome;
    UINT8 channel;
    UINT8 bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    if (errsts & 0x81)
    {
        unsigned long eap;
        unsigned long derrsyn;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location, syndrome and channel */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x58, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x5C, 1, &derrsyn);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x5D, 1, &des);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRSYN=%02X", derrsyn);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DES=%02X", des);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF000) >> 12;
        syndrome = derrsyn;
        channel = des & 1;
        bits = (errsts & 0x80) ? 0 : 1;

        /* Report the error */
        MtSupportReportECCError((page << 12), bits, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 0x81);
    }
}

static void setup_i845(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_RESERVED};
    unsigned long drc;

    MtSupportDebugWriteLine("Intel 845 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x7C, 4, &drc);

    AsciiSPrint(gBuffer, BUF_SIZE, "DRC=%08X", drc);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(drc >> 20) & 3];
}

static void poll_i845(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page, offset;
    unsigned long syndrome;
    int bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    if (errsts & 3)
    {
        unsigned long eap;
        unsigned long derrsyn;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x8C, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x86, 1, &derrsyn);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRSYN=%02X", derrsyn);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        offset = (eap & 0xFE) << 4;
        page = (eap & 0x3FFFFFFE) >> 8;
        syndrome = derrsyn;
        bits = ((errsts & 3) == 1) ? 1 : 2;

        /* Report the error */
        MtSupportReportECCError((page << 12) | offset, bits == 1 ? 1 : 0, syndrome, -1, -1, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 3);
    }
}
static void setup_i820(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_CORRECT};
    unsigned long mchcfg;

    MtSupportDebugWriteLine("Intel 820 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xbe, 2, &mchcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHCFG=%04X", mchcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(mchcfg >> 7) & 3];
}

static void poll_i820(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long syndrome;
    int bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    if (errsts & 3)
    {
        unsigned long eap;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xc4, 4, &eap);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF000) >> 4;
        syndrome = eap & 0xFF;
        bits = ((errsts & 3) == 1) ? 1 : 2;

        /* Report the error */
        MtSupportReportECCError((page << 12), bits == 1 ? 1 : 0, syndrome, -1, -1, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, 3);
    }
}

static void setup_i850(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_RESERVED};
    unsigned long mchcfg;

    MtSupportDebugWriteLine("Intel 850 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x50, 2, &mchcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHCFG=%04X", mchcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(mchcfg >> 7) & 3];
}

static void poll_i850(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned long syndrome;
    UINT8 channel;
    int bits;
    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    if (errsts & 3)
    {
        unsigned long eap;
        unsigned long derrctl_sts;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xE4, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xE2, 2, &derrctl_sts);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRCTRL_STS=%04X", derrctl_sts);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFF800) >> 11;
        channel = eap & 1;
        syndrome = derrctl_sts & 0xFF;
        bits = ((errsts & 3) == 1) ? 1 : 2;

        /* Report the error */
        MtSupportReportECCError(page << 12, bits == 1 ? 1 : 0, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, errsts & 3);
    }
}

static void setup_i860(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_RESERVED, ECC_CORRECT, ECC_RESERVED};
    unsigned long mchcfg;
    unsigned long errsts;

    MtSupportDebugWriteLine("Intel 860 chipset init");

    /* Fill in the correct memory capabilites */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x50, 2, &mchcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHCFG=%04X", mchcfg);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ddim[(mchcfg >> 7) & 3];

    /* Clear any prexisting error reports */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);
    pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, errsts & 3);
}

#define INTEL860_ERRSTS 0xc8
#define INTEL860_EAP 0xe4
#define INTEL860_DERRCTL_STS 0xe2

static void poll_i860(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned char syndrome;
    unsigned long eap;
    unsigned long derrctl_sts;

    UINT8 channel;
    BOOLEAN corrected;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL860_ERRSTS, 2, &errsts);
    if (errsts & 3)
    {

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL860_EAP, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL860_DERRCTL_STS, 2, &derrctl_sts);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRCTL_STS=%04X", derrctl_sts);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        page = (eap & 0xFFFFFE00) >> 9;
        channel = eap & 1;
        syndrome = derrctl_sts & 0xFF;
        corrected = (errsts & 0x01) ? 1 : 0;

        /* Report the error */
        MtSupportReportECCError(page << 12, corrected, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL860_ERRSTS, 2, errsts & 3);
    }
}

static void poll_iE7221(struct ecc_info *ctrl)
{
    unsigned long errsts;
    unsigned long page;
    unsigned char syndrome;
    UINT8 channel;
    UINT8 bits;
    int errocc;

    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, &errsts);

    errocc = errsts & 3;

    if ((errocc == 1) || (errocc == 2))
    {
        unsigned long eap, offset;
        unsigned long derrctl_sts;

        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04X", errsts);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x58, 4, &eap);
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, 0x5C, 1, &derrctl_sts);

        AsciiSPrint(gBuffer, BUF_SIZE, "EAP=%08X", eap);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "DERRCTL_STS=%02X", derrctl_sts);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location and error type */
        channel = eap & 1;
        eap = eap & 0xFFFFFF80;
        page = eap >> 12;
        offset = eap & 0xFFF;
        syndrome = derrctl_sts & 0xFF;
        bits = errocc & 1;

        /* Report the error */
        MtSupportReportECCError((page << 12) | offset, bits, syndrome, -1, channel, -1);

        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, errsts & 3);
    }

    else if (errocc == 3)
    {

        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, 0xC8, 2, errsts & 3);
    }
}

static void poll_iE7520(struct ecc_info *ctrl)
{
    unsigned long ferr;
    unsigned long nerr;

    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 2, &ferr);
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 2, &nerr);

    if (ferr & 0x0101)
    {
        /* Find out about the first correctable error */
        unsigned long celog_add;
        unsigned long celog_syndrome;
        unsigned long page;

        AsciiSPrint(gBuffer, BUF_SIZE, "FERR=%04X", ferr);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "NERR=%04X", nerr);
        MtSupportDebugWriteLine(gBuffer);

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xA0, 4, &celog_add);
        /* Read the syndrome */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xC4, 2, &celog_syndrome);

        AsciiSPrint(gBuffer, BUF_SIZE, "CELOG_ADD=%08X", celog_add);
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "CELOG_SYNDROME=%04X", celog_syndrome);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location */
        page = (celog_add & 0x7FFFFFFC) >> 2;

        /* Report the error */
        MtSupportReportECCError(page << 12, 1, celog_syndrome, -1, -1, -1);

        /* Clear Bit */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 2, ferr & 0x0101);
    }

    if (ferr & 0x4646)
    {
        /* Found out about the first uncorrectable error */
        unsigned long uccelog_add;
        unsigned long page;

        /* Read the error location */
        pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0xA4, 4, &uccelog_add);

        AsciiSPrint(gBuffer, BUF_SIZE, "UCCELOG_ADD=%08X", uccelog_add);
        MtSupportDebugWriteLine(gBuffer);

        /* Parse the error location */
        page = (uccelog_add & 0x7FFFFFFC) >> 2;

        /* Report the error */
        MtSupportReportECCError(page << 12, FALSE, -1, -1, -1, -1);

        /* Clear Bit */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x80, 2, ferr & 0x4646);
    }

    /* Check if DRAM_NERR contains data */
    if (nerr & 0x4747)
    {
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn + 1, 0x82, 2, nerr & 0x4747);
    }
}

/*
 * Atom E3800 memory controller
 *
 * Reference: http://www.intel.com/content/www/us/en/embedded/products/bay-trail/atom-e3800-family-datasheet.html
 */
#define INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT 0x01
#define INTEL_ATOM_E3800_MBUS_DECCCTRL 0x60
#define INTEL_ATOM_E3800_MBUS_DECCCTRL_CLRSBECNT (1 << 7)

#define INTEL_ATOM_E3800_MBUS_DECCSBECNT 0x62

static void setup_e3800atom(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CORRECT, ECC_CHIPKILL, ECC_CHIPKILL};
    unsigned long deccctrl = 0;
    unsigned long deccsbecnt = 0;

    MtSupportDebugWriteLine("Intel Atom E3800 chipset init");

    /* Fill in the correct memory capabilites */
    mbus_read(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCCTRL, &deccctrl);
    mbus_read(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCSBECNT, &deccsbecnt);

    AsciiSPrint(gBuffer, BUF_SIZE, "DECCCTRL=%08X, DECCSBECNT=%08X", deccctrl, deccsbecnt);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CHIPKILL;
    ctrl->mode = ddim[deccctrl & 3];

    /* Clear any prexisting error reports */
    if (deccsbecnt != 0)
    {
        mbus_write(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCCTRL, deccctrl | INTEL_ATOM_E3800_MBUS_DECCCTRL_CLRSBECNT);

        mbus_read(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCSBECNT, &deccsbecnt);
        AsciiSPrint(gBuffer, BUF_SIZE, "New DECCSBECNT=%08X", deccsbecnt);
        MtSupportDebugWriteLine(gBuffer);

        mbus_write(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCCTRL, deccctrl & ~INTEL_ATOM_E3800_MBUS_DECCCTRL_CLRSBECNT);
    }

    /* Save the previous error count */
    ctrl->preverrcnt[0] = deccsbecnt;
}

static void poll_e3800atom(struct ecc_info *ctrl)
{
    unsigned long deccsbecnt = 0;

    /* Read the error status */
    mbus_read(INTEL_ATOM_E3800_MEMCTRL_MBUS_PORT, INTEL_ATOM_E3800_MBUS_DECCSBECNT, &deccsbecnt);

    if (deccsbecnt != ctrl->preverrcnt[0])
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "[Channel 0] Single bit error count=%08x", deccsbecnt);
        MtSupportDebugWriteLine(gBuffer);
        MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, 0, 0);
    }
    ctrl->preverrcnt[0] = deccsbecnt;
}

/*
 * Atom C2000 memory controller
 *
 * Reference: Intel Atom Processor C2000 Product Family for Microserver External Design Specification (EDS) (Doc No: 508084) [Confidential]
 */
#define INTEL_ATOM_C2000_BUNIT_IOSFSB_PORT 0x03
#define INTEL_ATOM_C2000_BUNIT_BECREG 0x27
#define INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW 0x54

#define INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW_DECCEN (1 << 0)

#define INTEL_ATOM_C2000_DUNIT0_IOSFSB_PORT 0x10
#define INTEL_ATOM_C2000_DUNIT1_IOSFSB_PORT 0x13
#define INTEL_ATOM_C2000_DUNIT_DECCCTRL 0x60
#define INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT0CLR (1 << 24)
#define INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT1CLR (1 << 25)
#define INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT2CLR (1 << 26)
#define INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT3CLR (1 << 27)

#define INTEL_ATOM_C2000_DUNIT_FERRNERR 0x61
#define INTEL_ATOM_C2000_DUNIT_SBELOG 0x62
#define INTEL_ATOM_C2000_DUNIT_SBELOG_SBERNK(x) ((x >> 20) & 0x3)
#define INTEL_ATOM_C2000_DUNIT_SBELOG_SBEBNK(x) ((x >> 16) & 0x7)
#define INTEL_ATOM_C2000_DUNIT_SBELOG_SBESYND(x) (x & 0xFF)
#define INTEL_ATOM_C2000_DUNIT_UCELOG 0x63
#define INTEL_ATOM_C2000_DUNIT_UCELOG_UCERNK(x) ((x >> 20) & 0x3)
#define INTEL_ATOM_C2000_DUNIT_UCELOG_UCEBNK(x) ((x >> 16) & 0x7)
#define INTEL_ATOM_C2000_DUNIT_UCELOG_UCESYND(x) (x & 0xFF)
#define INTEL_ATOM_C2000_DUNIT_SBECNT0 0x64
#define INTEL_ATOM_C2000_DUNIT_SBECNT1 0x65
#define INTEL_ATOM_C2000_DUNIT_SBECNT2 0x66
#define INTEL_ATOM_C2000_DUNIT_SBECNT3 0x67
#define INTEL_ATOM_C2000_DUNIT_SBEACC0 0x68
#define INTEL_ATOM_C2000_DUNIT_SBEACC1 0x69

#define INTEL_ATOM_C2000_DUNIT_DERRSTS 0x6A
#define INTEL_ATOM_C2000_DUNIT_DERRMSKSEV 0x6B
#define INTEL_ATOM_C2000_DUNIT_DERRMSKSEV_MSK_SBE (1 << 16)
#define INTEL_ATOM_C2000_DUNIT_DERRCNT 0x6D
#define INTEL_ATOM_C2000_DUNIT_SBEADDR 0x6E
#define INTEL_ATOM_C2000_DUNIT_UCEADDR 0x6F

#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL 0x70
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJEN (1 << 0)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJONCE (1 << 1)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJADREN (1 << 2)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJSRCEN (1 << 3)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJECC (1 << 4)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJWRITE (1 << 5)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJREAD (1 << 6)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJSRC(x) ((x & 0xF) << 8)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJTRIGSEL(x) ((x & 0x3) << 14)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJADDR3 (1 << 16)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJAMSK3 (1 << 17)
#define INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJECCPAR(x) ((x & 0xFF) << 24)

#define INTEL_ATOM_C2000_DUNIT_ERRINJADDR 0x71
#define INTEL_ATOM_C2000_DUNIT_ERRINJMASK 0x72
#define INTEL_ATOM_C2000_DUNIT_ERRINJDATA0 0x73
#define INTEL_ATOM_C2000_DUNIT_ERRINJDATA1 0x74
#define INTEL_ATOM_C2000_DUNIT_DCO 0xF

#define INTEL_ATOM_C2000_GCORERRSTS 0x200
#define INTEL_ATOM_C2000_GNERRSTS 0x204
#define INTEL_ATOM_C2000_GFERRSTS 0x208

static void setup_c2000atom(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CHIPKILL, ECC_NONE, ECC_CHIPKILL | ECC_SCRUB};
    const int mcportlist[] = {INTEL_ATOM_C2000_DUNIT0_IOSFSB_PORT, INTEL_ATOM_C2000_DUNIT1_IOSFSB_PORT};
    unsigned long deccctrl = 0;
    unsigned long sbecnt[4] = {0};
    unsigned long derrsts = 0;
    unsigned long derrmsksev = 0;
    unsigned long mci_ctl_low = 0;
    unsigned long mmcfg = 0;
    unsigned long gcorerrsts, gnerrsts, gferrsts;

    UINT64 mcgcap = 0;
    UINT64 mcctrl = 0;
    UINT64 mcstatus = 0;

    int i, j;

    MtSupportDebugWriteLine("Intel Atom C2000 chipset init");

    ctrl->cap = ECC_CHIPKILL | ECC_SCRUB;
    ctrl->numch = 2;
    ctrl->numsl = 1;
    ctrl->mchbar = 0;

    for (i = 0; i < sizeof(mcportlist) / sizeof(mcportlist[0]); i++)
    {
        /* Fill in the correct memory capabilites */
        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DECCCTRL, &deccctrl);
        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRSTS, &derrsts);
        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRMSKSEV, &derrmsksev);

        AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] DECCCTRL=%08X, DERRSTS=%08X, DERRMSKSEV=%08X", i, deccctrl, derrsts, derrmsksev);
        MtSupportDebugWriteLine(gBuffer);

        // Clear status register
        if (derrsts != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] Clearing DERRSTS bits", i);
            MtSupportDebugWriteLine(gBuffer);
            iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRSTS, derrsts & ~0x7);
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRSTS, &derrsts);
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New DERRSTS=%08X", i, derrsts);
            MtSupportDebugWriteLine(gBuffer);
        }

        // Clear masking of SBE errors
        if (derrmsksev & INTEL_ATOM_C2000_DUNIT_DERRMSKSEV_MSK_SBE)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] Clearing MSK_SBE bit in DERRMSKSEV", i);
            MtSupportDebugWriteLine(gBuffer);
            iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRMSKSEV, derrmsksev & ~INTEL_ATOM_C2000_DUNIT_DERRMSKSEV_MSK_SBE);
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRMSKSEV, &derrmsksev);
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New DERRMSKSEV=%08X", i, derrmsksev);
            MtSupportDebugWriteLine(gBuffer);
        }

        for (j = 0; j < 4; j++)
        {
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBECNT0 + j, &sbecnt[j]);

            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBECNT%d=%08X", i, j, sbecnt[j]);
            MtSupportDebugWriteLine(gBuffer);

            /* Clear any prexisting error reports */
            if (sbecnt[j] != 0 && sbecnt[j] != 0xffffffff)
            {
                iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DECCCTRL, deccctrl | (INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT0CLR << j));

                iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBECNT0 + j, &sbecnt[j]);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New SBECNT%d=%08X", i, j, sbecnt[j]);
                MtSupportDebugWriteLine(gBuffer);

                iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DECCCTRL, deccctrl & ~(INTEL_ATOM_C2000_DUNIT_DECCCTRL_SBECNT0CLR << j));
            }

            /* Save the previous error count */
            if (sbecnt[j] != 0 && sbecnt[j] != 0xffffffff)
                ctrl->preverrcnt[i] += sbecnt[j];
        }

        if (ctrl->mode == ECC_NONE)
            ctrl->mode = ddim[deccctrl & 3];
    }

    // Enable MC error reporting
    iosfsb_read(INTEL_ATOM_C2000_BUNIT_IOSFSB_PORT, INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW, &mci_ctl_low);
    AsciiSPrint(gBuffer, BUF_SIZE, "MCi_CTL_LOW=%08X", mci_ctl_low);
    MtSupportDebugWriteLine(gBuffer);

    if ((mci_ctl_low & INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW_DECCEN) == 0)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "Setting MCi_CTL_LOW=%08X", mci_ctl_low | INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW_DECCEN);
        MtSupportDebugWriteLine(gBuffer);

        iosfsb_write(INTEL_ATOM_C2000_BUNIT_IOSFSB_PORT, INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW, mci_ctl_low | INTEL_ATOM_C2000_BUNIT_MCi_CTL_LOW_DECCEN);
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    iosfsb_read(INTEL_ATOM_C2000_BUNIT_IOSFSB_PORT, INTEL_ATOM_C2000_BUNIT_BECREG, &mmcfg);

    AsciiSPrint(gBuffer, BUF_SIZE, "BECREG=%08X", mmcfg);
    MtSupportDebugWriteLine(gBuffer);

    mmcfg &= 0xF0000000;

    if (mmcfg > 0)
    {
        ctrl->mchbar = mmcfg;

        /* Read the error status */
        gcorerrsts = readmmio32((unsigned int *)((UINTN)mmcfg + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GCORERRSTS));
        gnerrsts = readmmio32((unsigned int *)((UINTN)mmcfg + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GNERRSTS));
        gferrsts = readmmio32((unsigned int *)((UINTN)mmcfg + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GFERRSTS));

        AsciiSPrint(gBuffer, BUF_SIZE, "GCORERRSTS=%08X, GNERRSTS=%08X, GFERRSTS=%08X", gcorerrsts, gnerrsts, gferrsts);
        MtSupportDebugWriteLine(gBuffer);
    }

    _rdmsr64(MSR_IA32_MCG_CAP, &mcgcap);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCG_CAP=" I64HEXFMT " (Count=%d)", mcgcap, (UINT32)(mcgcap & 0xFF));
    MtSupportDebugWriteLine(gBuffer);

    _rdmsr64(MSR_IA32_MCi_CTL(5), &mcctrl);

    AsciiSPrint(gBuffer, BUF_SIZE, "MC5_CTRL=" I64HEXFMT, mcctrl);
    MtSupportDebugWriteLine(gBuffer);

    // Clear error status
    _rdmsr64(MSR_IA32_MCi_STATUS(5), &mcstatus);

    if (mcstatus)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "MC5_STATUS=" I64HEXFMT, mcstatus);
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_MCi_STATUS(5), 0);
    }
}

static void poll_c2000atom(struct ecc_info *ctrl)
{
    const int mcportlist[] = {INTEL_ATOM_C2000_DUNIT0_IOSFSB_PORT, INTEL_ATOM_C2000_DUNIT1_IOSFSB_PORT};
    unsigned int dimmerrcnt[2];
    unsigned long gcorerrsts, gnerrsts, gferrsts;
    unsigned long sbecnt[4] = {0};
    unsigned long derrsts = 0;
    unsigned long sbelog = 0;
    unsigned long ucelog = 0;
    unsigned long sbeaddr = 0;
    unsigned long uceaddr = 0;

    UINT64 mcstatus = 0;
    UINT64 mcaddr = 0;
    BOOLEAN reported = FALSE;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    // Read the MCE MSR registers and report any ECC errors

    /* Read the MC5 error status */
    _rdmsr64(MSR_IA32_MCi_STATUS(5), &mcstatus);

    if (mcstatus & MCI_STATUS_VAL)
    {
        UINT32 mserr;
        INT8 channel = -1;
        BOOLEAN uncorrected_error;

        AsciiSPrint(gBuffer, BUF_SIZE, "MC5_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)", mcstatus,
                    (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                    (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                    (UINT32)((mcstatus >> 38) & 0x7FFF),
                    (UINT32)(mcstatus & 0xFFFF));
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
        mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
        switch (mserr)
        {
        case 0x0090:
            channel = 0;
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Channel 0 Read Error");
            break;

        case 0x0091:
            channel = 1;
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Channel 1 Read Error");
            break;

        case 0x00A0:
            channel = 0;
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Channel 0 Write Error");
            break;

        case 0x00A1:
            channel = 1;
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DDR3 Channel 1 Write Error");
            break;

        case 0x009F:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "Internal Buffer RAM Read Error");
            break;

        case 0x00AF:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "Internal Buffer RAM Write Error");
            break;

        default:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
            break;
        }
        MtSupportDebugWriteLine(gBuffer);
        if (mcstatus & MCI_STATUS_ADDRV)
            _rdmsr64(MSR_IA32_MCi_ADDR(5), &mcaddr);

        AsciiSPrint(gBuffer, BUF_SIZE, "MC5_ADDR=" I64HEXFMT, mcaddr);
        MtSupportDebugWriteLine(gBuffer);

        _wrmsr64(MSR_IA32_MCi_STATUS(5), 0);

        uncorrected_error = (mcstatus & (1ll << 61)) != 0;

        if (channel >= 0)
        {
            MtSupportReportECCError((UINTN)mcaddr, !uncorrected_error, -1, -1, channel, 0);
            reported = TRUE;
        }
    }

    // Read the error status/count iosf-sb registers for debug but don't report errors if already reported via MCE registers
    for (UINT8 i = 0; i < sizeof(mcportlist) / sizeof(mcportlist[0]); i++)
    {
        for (int j = 0; j < 4; j++)
        {
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBECNT0 + j, &sbecnt[j]);

            if (sbecnt[j] != 0 && sbecnt[j] != 0xffffffff)
                dimmerrcnt[i] += sbecnt[j];
        }

        if (dimmerrcnt[i] != ctrl->preverrcnt[i])
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] Single bit error count=%08x", i, dimmerrcnt[i]);
            MtSupportDebugWriteLine(gBuffer);

            for (int j = 0; j < 4; j++)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBECNT%d=%08x", i, j, sbecnt[j]);
                MtSupportDebugWriteLine(gBuffer);
            }

            for (int j = 0; j < 2; j++)
            {
                unsigned long sbeacc = 0;
                iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBEACC0 + j, &sbeacc);

                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBEACC%d=%08x", i, j, sbeacc);
                MtSupportDebugWriteLine(gBuffer);
            }

            if (reported == FALSE)
                MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, -1, i, -1);
        }
        ctrl->preverrcnt[i] = dimmerrcnt[i];

        /* Read the local error status */
        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRSTS, &derrsts);

        if (derrsts != 0 && derrsts != 0xffffffff)
        {
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBELOG, &sbelog);
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_SBEADDR, &sbeaddr);
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_UCELOG, &ucelog);
            iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_UCEADDR, &uceaddr);

            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] DERRSTS=%08X", i, derrsts);
            MtSupportDebugWriteLine(gBuffer);

            if (sbelog != 0 || sbeaddr != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBELOG=%08X (Rank=%X Bank=%X Syndrome=%08X), SBEADDR=%08X", i, sbelog, INTEL_ATOM_C2000_DUNIT_SBELOG_SBERNK(sbelog), INTEL_ATOM_C2000_DUNIT_SBELOG_SBEBNK(sbelog), INTEL_ATOM_C2000_DUNIT_SBELOG_SBESYND(sbelog), sbeaddr);
                MtSupportDebugWriteLine(gBuffer);
            }

            if (ucelog != 0 || uceaddr != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] UCELOG=%08X (Rank=%X Bank=%X Syndrome=%08X), UCEADDR=%08X", i, ucelog, INTEL_ATOM_C2000_DUNIT_UCELOG_UCERNK(ucelog), INTEL_ATOM_C2000_DUNIT_UCELOG_UCEBNK(ucelog), INTEL_ATOM_C2000_DUNIT_UCELOG_UCESYND(ucelog), uceaddr);
                MtSupportDebugWriteLine(gBuffer);
            }

            // Clear status register
            iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DERRSTS, derrsts & ~0x7);
        }
    }

    /* Read the global error status */
    if (ctrl->mchbar > 0)
    {
        gcorerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GCORERRSTS));
        gnerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GNERRSTS));
        gferrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + (0 * 0x100000) + (14 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C2000_GFERRSTS));

        if (gcorerrsts != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "GCORERRSTS=%08X, GNERRSTS=%08X, GFERRSTS=%08X", gcorerrsts, gnerrsts, gferrsts);
            MtSupportDebugWriteLine(gBuffer);
        }
    }
}

// From Intel Atom Processor C2000 Product Family BIOS Writer's Guide (BWG), Vol. 2 of 2 (Doc No: 516816)
// In order to enable error injection, BIOS should relax the security configuration: Disable ERRINJLOCK (clear the bit) and disable DRPLOCK (clear the bit).
void inject_c2000atom(int index, int uncorrectable)
{
    const int mcportlist[] = {INTEL_ATOM_C2000_DUNIT0_IOSFSB_PORT, INTEL_ATOM_C2000_DUNIT1_IOSFSB_PORT};
    struct ecc_info *ctrl = NULL;

    int i;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    for (i = 0; i < sizeof(mcportlist) / sizeof(mcportlist[0]); i++)
    {
        unsigned long errinjdata0, errinjdata1;
        unsigned long dco;
        int drplock;
        unsigned long errinjctl;

        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA0, &errinjdata0);
        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA1, &errinjdata1);

        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DCO, &dco);

        drplock = dco & 0x1;

        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJCTL, &errinjctl);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] DCO=%08X (DRPLOCK=%d), ERRINJDATA0=%08X ERRINJDATA1=%08X ERRINJCTL=%08x", i, dco, drplock, errinjdata0, errinjdata1, errinjctl);
        MtSupportDebugWriteLine(gBuffer);

        if (drplock)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] **Warning** DRPLOCK is set to 1. DRPLOCK must be cleared by the BIOS to enable error injection", i);
            MtSupportDebugWriteLine(gBuffer);
        }

        if (uncorrectable)
        {
            // Flip bits 0-3
            errinjdata0 = 0xF;
            errinjdata1 = 0;
        }
        else
        {
            // Flip bit 0
            errinjdata0 = 0x0;
            errinjdata1 = 0x1;
        }

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] setting new ERRINJDATA0=%08X ERRINJDATA1=%08X", i, errinjdata0, errinjdata1);
        MtSupportDebugWriteLine(gBuffer);

        iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA0, errinjdata0);
        iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA1, errinjdata1);

        errinjctl = INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJEN | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJONCE | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJECC | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJREAD | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJWRITE;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] setting new ERRINJCTL= %08x", i, errinjctl);
        MtSupportDebugWriteLine(gBuffer);

        iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJCTL, errinjctl);
    }
}

#define INTEL_ATOM_C3000_SBREG_BAR 0x10
#define INTEL_ATOM_C3000_SBREG_BARH 0x14
#define INTEL_ATOM_C3000_P2SBC 0xE0
#define INTEL_ATOM_C3000_P2SBC_HIDE 0xE1
#define INTEL_ATOM_C3000_PCIEXBAR_LO_0_0_0_PCI 0x60
#define INTEL_ATOM_C3000_PCIEXBAR_HI_0_0_0_PCI 0x64
#define INTEL_ATOM_C3000_GLREG_GCOERRSTS 0x200
#define INTEL_ATOM_C3000_GLREG_GNFERRSTS 0x204
#define INTEL_ATOM_C3000_GLREG_GFAERRSTS 0x208

#define INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) (ch == 0 ? 0x100000 : 0x120000)
#define INTEL_ATOM_C3000_DECCCTRL(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x180)
#define INTEL_ATOM_C3000_DERRSTS(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x124)
#define INTEL_ATOM_C3000_DERRSTS_SBE (1 << 0)
#define INTEL_ATOM_C3000_DERRSTS_UCE (1 << 1)

#define INTEL_ATOM_C3000_DERRMSKSEV(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x128)
#define INTEL_ATOM_C3000_DERRMSKSEV_MSK_SBE (1 << 16)
#define INTEL_ATOM_C3000_SBECNT0(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x74)
#define INTEL_ATOM_C3000_SBECNT1(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x78)
#define INTEL_ATOM_C3000_SBECNT2(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x7c)
#define INTEL_ATOM_C3000_SBECNT3(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x80)
#define INTEL_ATOM_C3000_SBELOG(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x6c)
#define INTEL_ATOM_C3000_SBEADDR(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x70)
#define INTEL_ATOM_C3000_UCELOG(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x64)
#define INTEL_ATOM_C3000_UCEADDR(ch) (INTEL_ATOM_C3000_MMIO_SBREG_BASE(ch) + 0x68)

#define INTEL_ATOM_C3000_SBELOG_SBERNK(x) ((x >> 20) & 0x3)
#define INTEL_ATOM_C3000_SBELOG_SBEBNK(x) ((x >> 16) & 0xF)
#define INTEL_ATOM_C3000_SBELOG_SBESYND(x) (x & 0xFF)
#define INTEL_ATOM_C3000_UCELOG_UCERNK(x) ((x >> 20) & 0x3)
#define INTEL_ATOM_C3000_UCELOG_UCEBNK(x) ((x >> 16) & 0xF)
#define INTEL_ATOM_C3000_UCELOG_UCESYND(x) (x & 0xFF)

static void setup_c3000atom(struct ecc_info *ctrl)
{
    static const int ddim[] = {ECC_NONE, ECC_CHIPKILL, ECC_NONE, ECC_CHIPKILL | ECC_SCRUB};
    unsigned long deccctrl = 0;
    unsigned long sbecnt[4] = {0};
    unsigned long derrsts = 0;
    unsigned long derrmsksev = 0;

    unsigned long p2sbc = 0;
    unsigned long sbreg_barl = 0, sbreg_barh = 0;
    unsigned long long sbreg_bar = 0;
    unsigned long pciexbar_lo = 0, pciexbar_hi = 0;
    unsigned long long pciexbar = 0;
    unsigned long gcoerrsts = 0, gnferrsts, gfaerrsts;

    int mcbank;
    UINT64 mcctrl = 0;
    UINT64 mcstatus = 0;

    int i, j;

    MtSupportDebugWriteLine("Intel Atom C3000 chipset init");

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access

    // Check if P2SB is hidden
    pci_conf_read(0, 31, 1, INTEL_ATOM_C3000_P2SBC_HIDE, 1, &p2sbc);
    if (p2sbc)
        pci_conf_write(0, 31, 1, INTEL_ATOM_C3000_P2SBC_HIDE, 1, 0);

    pci_conf_read(0, 31, 1, INTEL_ATOM_C3000_SBREG_BAR, 4, &sbreg_barl);
    pci_conf_read(0, 31, 1, INTEL_ATOM_C3000_SBREG_BARH, 4, &sbreg_barh);
    sbreg_bar = LShiftU64(sbreg_barh, 32) | (sbreg_barl & 0xFF000000);

    AsciiSPrint(gBuffer, BUF_SIZE, "SBREG_BAR=" I64HEXFMT " (SBREG_BAR = % 08x, SBREG_BARH = % 08x)", sbreg_bar, sbreg_barl, sbreg_barh);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CHIPKILL | ECC_SCRUB;
    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->mchbar = 0;

    if (sbreg_bar > 0 && sbreg_barh != 0xffffffff && sbreg_barl != 0xffffffff) // Sanity check
    {
        ctrl->mchbar = sbreg_bar;
        for (i = 0; i < ctrl->numch; i++)
        {
            /* Fill in the correct memory capabilites */
            deccctrl = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DECCCTRL(i)));
            derrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)));
            derrmsksev = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRMSKSEV(i)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] DECCCTRL=%08X, DERRSTS=%08X, DERRMSKSEV=%08X", i, deccctrl, derrsts, derrmsksev);
            MtSupportDebugWriteLine(gBuffer);

            // Clear status register
            if (derrsts != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] Clearing DERRSTS bits", i);
                MtSupportDebugWriteLine(gBuffer);
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)), derrsts | 0x7F);
                derrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)));
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New DERRSTS=%08X", i, derrsts);
                MtSupportDebugWriteLine(gBuffer);
            }

            // Clear masking of SBE errors
            if (derrmsksev & INTEL_ATOM_C3000_DERRMSKSEV_MSK_SBE)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] Clearing MSK_SBE bit in DERRMSKSEV", i);
                MtSupportDebugWriteLine(gBuffer);
                writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRMSKSEV(i)), derrmsksev & ~INTEL_ATOM_C3000_DERRMSKSEV_MSK_SBE);
                derrmsksev = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRMSKSEV(i)));
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New DERRMSKSEV=%08X", i, derrmsksev);
                MtSupportDebugWriteLine(gBuffer);
            }

            for (j = 0; j < 4; j++)
            {
                int ch = i;
                int slot = j < 2 ? 0 : 1;

                sbecnt[j] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBECNT0(i) + j * 4));

                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBECNT%d=%08X", i, j, sbecnt[j]);
                MtSupportDebugWriteLine(gBuffer);

                /* Clear any prexisting error reports */
                if (sbecnt[j] != 0)
                {
                    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBECNT0(i) + j * 4), 0);

                    sbecnt[j] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBECNT0(i) + j * 4));
                    AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] New SBECNT%d=%08X", i, j, sbecnt[j]);
                    MtSupportDebugWriteLine(gBuffer);
                }

                /* Save the previous error count */
                ctrl->preverrcnt[ch * ctrl->numsl + slot] += sbecnt[j];
            }

            if (ctrl->mode == ECC_NONE)
                ctrl->mode = ddim[deccctrl & 3];
        }
    }

    // Get MMCFG register. This is the PCIe configuration space base address for memory mapped access
    pci_conf_read(0, 0, 0, INTEL_ATOM_C3000_PCIEXBAR_LO_0_0_0_PCI, 4, &pciexbar_lo);
    pci_conf_read(0, 0, 0, INTEL_ATOM_C3000_PCIEXBAR_HI_0_0_0_PCI, 4, &pciexbar_hi);
    pciexbar = LShiftU64(pciexbar_hi & 0x7f, 32) | (pciexbar_lo & 0xF0000000);

    AsciiSPrint(gBuffer, BUF_SIZE, "PCIEXBAR=" I64HEXFMT, pciexbar);
    MtSupportDebugWriteLine(gBuffer);

    if (pciexbar > 0 && pciexbar_hi != 0xffffffff && pciexbar_lo != 0xffffffff)
    {
        ctrl->mchbar2 = pciexbar;

        /* Read the error status */
        gcoerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GCOERRSTS));
        gnferrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GNFERRSTS));
        gfaerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GFAERRSTS));

        AsciiSPrint(gBuffer, BUF_SIZE, "GLREG_GCOERRSTS=%08X, GLREG_GNFERRSTS=%08X, GLREG_GFAERRSTS=%08X", gcoerrsts, gnferrsts, gfaerrsts);
        MtSupportDebugWriteLine(gBuffer);
    }

    // Clear error status
    // There is inconsistency between the info in the Intel docs
    // According to Intel Atom Processor C3000 Product Family External Design Specification(EDS), Volumes 1, 2, 3 and 4 (Doc ID: 558579),
    //  MC bank 7 and 8 refer to memory channels 0 and 1
    // However, according to Intel 64 and IA-32 Architectures Software Developer's Manual (Order number: 325462-081US),
    //  MC bank 6 and 7 refer to memory channels 0 and 1
    // For the time being, we shall use MC banks 7 and 8

    for (mcbank = 7; mcbank <= 8; mcbank++)
    {
        _rdmsr64(MSR_IA32_MCi_CTL(mcbank), &mcctrl);

        AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_CTRL=" I64HEXFMT, mcbank, mcctrl);
        MtSupportDebugWriteLine(gBuffer);

        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

        if (mcstatus)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT, mcbank, mcstatus);
            MtSupportDebugWriteLine(gBuffer);
            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);
        }
    }
}

static void poll_c3000atom(struct ecc_info *ctrl)
{
    unsigned int dimmerrcnt[4];
    unsigned long gcoerrsts, gnferrsts, gfaerrsts;
    unsigned long sbecnt[4] = {0};
    unsigned long derrsts = 0;
    unsigned long sbelog = 0;
    unsigned long ucelog = 0;
    unsigned long sbeaddr = 0;
    unsigned long uceaddr = 0;

    UINT8 ch, slot;
    UINT8 mcbank;
    UINT64 mcstatus = 0;
    UINT64 mcaddr = 0;
    UINT64 mcmisc = 0;

    SetMem(dimmerrcnt, sizeof(dimmerrcnt), 0);

    // Read the error status/count iosf-sb registers for debug but don't report errors
    for (UINT8 i = 0; i < ctrl->numch; i++)
    {
        ch = i;

        for (UINT8 j = 0; j < 4; j++)
        {
            slot = j < 2 ? 0 : 1;

            sbecnt[j] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBECNT0(i) + j * 4));
            dimmerrcnt[ch * ctrl->numsl + slot] += sbecnt[j];
        }

        /* Read the local error status */
        derrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)));

        if (derrsts != 0)
        {
            BOOLEAN uncorrected_error = (derrsts & INTEL_ATOM_C3000_DERRSTS_UCE) != 0;
            UINTN addr = 0;
            unsigned long syn;

            sbelog = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBELOG(i)));
            sbeaddr = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_SBEADDR(i)));
            ucelog = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_UCELOG(i)));
            uceaddr = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_UCEADDR(i)));

            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] DERRSTS=%08X", i, derrsts);
            MtSupportDebugWriteLine(gBuffer);

            if (derrsts & INTEL_ATOM_C3000_DERRSTS_SBE)
            {
                addr = (UINTN)LShiftU64(sbeaddr, 6);
                syn = INTEL_ATOM_C3000_SBELOG_SBESYND(sbelog);
                slot = INTEL_ATOM_C3000_SBELOG_SBERNK(sbelog) < 2 ? 0 : 1;
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] SBELOG=%08X (Rank=%X Bank=%X Syndrome=%08X), SBEADDR=%08X", i, sbelog, INTEL_ATOM_C3000_SBELOG_SBERNK(sbelog), INTEL_ATOM_C3000_SBELOG_SBEBNK(sbelog), INTEL_ATOM_C3000_SBELOG_SBESYND(sbelog), sbeaddr);
                MtSupportDebugWriteLine(gBuffer);
            }

            if (derrsts & INTEL_ATOM_C3000_DERRSTS_UCE)
            {
                addr = (UINTN)LShiftU64(uceaddr, 6);
                syn = INTEL_ATOM_C3000_UCELOG_UCESYND(ucelog);
                slot = INTEL_ATOM_C3000_UCELOG_UCERNK(ucelog) < 2 ? 0 : 1;
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] UCELOG=%08X (Rank=%X Bank=%X Syndrome=%08X), UCEADDR=%08X", i, ucelog, INTEL_ATOM_C3000_UCELOG_UCERNK(ucelog), INTEL_ATOM_C3000_UCELOG_UCEBNK(ucelog), INTEL_ATOM_C3000_UCELOG_UCESYND(ucelog), uceaddr);
                MtSupportDebugWriteLine(gBuffer);
            }

            MtSupportReportECCError((UINTN)addr, !uncorrected_error, syn, -1, ch, slot);

            // Clear status register
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)), derrsts);

            derrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_C3000_DERRSTS(i)));
            if (derrsts != 0)
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] **Warning** DERRSTS=%08X even after clearing", i, derrsts);
                MtSupportDebugWriteLine(gBuffer);
            }
        }
    }

    // compare with previous dimm error count
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        for (slot = 0; slot < ctrl->numsl; slot++)
        {
            if (dimmerrcnt[ch * ctrl->numsl + slot] != ctrl->preverrcnt[ch * ctrl->numsl + slot])
            {
                UINT8 channel = (UINT8)(ctrl->ctrlno * ctrl->numch + ch);
                AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d, Slot %d] DIMM err count=%d (prev=%d)", channel, slot, dimmerrcnt[ch * ctrl->numsl + slot], ctrl->preverrcnt[ch * ctrl->numsl + slot]);
                MtSupportDebugWriteLine(gBuffer);
                // MtSupportReportECCError_dimm(-1, -1, -1, -1, TRUE, -1, channel, slot);
            }
            ctrl->preverrcnt[ch * ctrl->numsl + slot] = dimmerrcnt[ch * ctrl->numsl + slot];
        }
    }

    /* Read the global error status */
    if (ctrl->mchbar2 > 0)
    {
        /* Read the error status */
        gcoerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GCOERRSTS));
        gnferrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GNFERRSTS));
        gfaerrsts = readmmio32((unsigned int *)((UINTN)ctrl->mchbar2 + (0 * 0x100000) + (4 * 0x8000) + (0 * 0x1000) + INTEL_ATOM_C3000_GLREG_GFAERRSTS));

        if (gcoerrsts != 0)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "GLREG_GCOERRSTS=%08X, GLREG_GNFERRSTS=%08X, GLREG_GFAERRSTS=%08X", gcoerrsts, gnferrsts, gfaerrsts);
            MtSupportDebugWriteLine(gBuffer);
        }
    }

    // Read the MCE MSR registers and report any ECC errors
    // There is inconsistency between the info in the Intel docs
    // According to Intel Atom Processor C3000 Product Family External Design Specification(EDS), Volumes 1, 2, 3 and 4 (Doc ID: 558579),
    //  MC bank 7 and 8 refer to memory channels 0 and 1
    // However, according to Intel 64 and IA-32 Architectures Software Developer's Manual (Order number: 325462-081US),
    //  MC bank 6 and 7 refer to memory channels 0 and 1
    // For the time being, we shall use MC banks 7 and 8
    for (mcbank = 7; mcbank <= 8; mcbank++)
    {
        ch = mcbank - 7;
        _rdmsr64(MSR_IA32_MCi_STATUS(mcbank), &mcstatus);

        if (mcstatus & MCI_STATUS_VAL)
        {
            UINT32 mserr;
            BOOLEAN uncorrected_error;
            BOOLEAN scrub = FALSE;

            AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)",
                        mcbank,
                        mcstatus,
                        (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                        (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                        (UINT32)((mcstatus >> 38) & 0x7FFF),
                        (UINT32)(mcstatus & 0xFFFF));
            MtSupportDebugWriteLine(gBuffer);

            // See 16.9.2.6 Memory Controller and Extended Memory Errors of Intel 64 and IA-32 Architectures Software Developer's Manual (Order number: 325462-081US),
            if ((mcstatus & 0xef80) == 0x80)
            {
                UINT32 xacttype = (UINT32)((mcstatus >> 4) & 0x7);

                AsciiSPrint(gBuffer, BUF_SIZE, "[IMC%d] Transaction error type : ", ch);
                switch (xacttype)
                {
                case 0:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Generic undefined request error");
                    break;
                case 1:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory read error");
                    break;
                case 2:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory write error");
                    break;
                case 3:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Address/Command error");
                    break;
                case 4:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Memory scrubbing error");
                    scrub = TRUE;
                    break;
                default:
                    AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                    break;
                }
                MtSupportDebugWriteLine(gBuffer);
            }
            else
                MtSupportDebugWriteLine("**WARNING** Not memory controller error");

            AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
            mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
            switch (mserr)
            {
            case 0x01:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Cmd/Addr parity");
                break;
            case 0x02:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Corrected Demand/Patrol Scrub Error");
                break;
            case 0x04:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected patrol scrub error");
                break;
            case 0x08:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Uncorrected demand read error");
                break;
            case 0x10:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "WDB read ECC");
                break;
            default:
                AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
                break;
            }
            MtSupportDebugWriteLine(gBuffer);
            if (mcstatus & MCI_STATUS_ADDRV)
            {
                _rdmsr64(MSR_IA32_MCi_ADDR(mcbank), &mcaddr);

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_ADDR=" I64HEXFMT, mcbank, mcaddr);
                MtSupportDebugWriteLine(gBuffer);
            }

            if (mcstatus & MCI_STATUS_MISCV)
            {
                _rdmsr64(MSR_IA32_MCi_MISC(mcbank), &mcmisc);

                AsciiSPrint(gBuffer, BUF_SIZE, "MC%d_MISC=" I64HEXFMT, mcbank, mcmisc);
                MtSupportDebugWriteLine(gBuffer);
            }

            _wrmsr64(MSR_IA32_MCi_STATUS(mcbank), 0);

            uncorrected_error = (mcstatus & (1ll << 61)) != 0;
            if (scrub)
                MtSupportReportECCErrorType_dimm(-1, -1, -1, -1, !uncorrected_error, ECC_TYPE_SCRUB, -1, -1, ch, -1);
        }
    }
}

void inject_c3000atom(int index, int uncorrectable)
{
#if 0
    const int mcportlist[] = { INTEL_ATOM_C2000_DUNIT0_IOSFSB_PORT, INTEL_ATOM_C2000_DUNIT1_IOSFSB_PORT };
    struct ecc_info* ctrl = NULL;

    int i;

    if (index < 0 || index >= s_numctrls) return;

    ctrl = &s_ctrl[index];

    for (i = 0; i < sizeof(mcportlist) / sizeof(mcportlist[0]); i++)
    {
        unsigned long dco;
        int drplock;
        unsigned long errinjctl;

        if (uncorrectable)
        {
            // Flip bits 0-3
            iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA0, 0x0000000F);
        }
        else
        {
            // Flip bit 0
            iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJDATA0, 0x00000001);
        }

        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_DCO, &dco);

        drplock = dco & 0x1;

        iosfsb_read(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJCTL, &errinjctl);
        AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] DCO=%08X (DRPLOCK=%d), ERRINJCTL=%08x", i, dco, drplock, errinjctl);
        MtSupportDebugWriteLine(gBuffer);

        if (drplock)
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] **Warning** DRPLOCK is set to 1. DRPLOCK must be cleared by the BIOS to enable error injection", i);
            MtSupportDebugWriteLine(gBuffer);
        }

        errinjctl = INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJEN | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJONCE | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJECC | INTEL_ATOM_C2000_DUNIT_ERRINJCTL_INJREAD;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_c2000atom - [Channel %d] setting new ERRINJCTL= %08x", i, errinjctl);
        MtSupportDebugWriteLine(gBuffer);

        iosfsb_write(mcportlist[i], INTEL_ATOM_C2000_DUNIT_ERRINJCTL, errinjctl);
    }
#endif
}

/*
 * Apollo Lake SoC (Atom E3900 Series) memory controller
 *
 * Reference: Apollo Lake SoC External Design Specification (EDS) Volume 2 of 3 (Doc No: 568531) [Confidential]
 */
#define INTEL_ATOM_E3900_MCHBAR_LO 0x48
#define INTEL_ATOM_E3900_MCHBAR_HI 0x4C

const UINT32 INTEL_ATOM_E3900_MCHBAR_D_CR_DRP0_CH_MAP[] = {0x1400, 0x1200, 0x1000, 0x1600};
#define INTEL_ATOM_E3900_MCHBAR_D_CR_DRP0(ch) (INTEL_ATOM_E3900_MCHBAR_D_CR_DRP0_CH_MAP[ch]) // (0x1000 + 0x200 * ch)
const UINT32 INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG_CH_MAP[] = {0x14B4, 0x12B4, 0x10B4, 0x16B4};
#define INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG(ch) (INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG_CH_MAP[ch]) // (0x10B4 + 0x200 * ch)
const UINT32 INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CH_MAP[] = {0x14AC, 0x12AC, 0x10AC, 0x16AC};
#define INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ(ch) (INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CH_MAP[ch]) // (0x10AC + 0x200 * ch)
const UINT32 INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CTL_CH_MAP[] = {0x14B0, 0x12B0, 0x10B0, 0x16B0};
#define INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CTL(ch) (INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CTL_CH_MAP[ch]) // (0x10B0 + 0x200 * ch)

#define INTEL_ATOM_E3900_MCHBAR_P_CR_MC_BIOS_REQ 0x7114
#define INTEL_ATOM_E3900_ERR_INJ_CTL_EN_LO (1 << 0)
#define INTEL_ATOM_E3900_ERR_INJ_CTL_SEL_LO (1 << 1)
#define INTEL_ATOM_E3900_ERR_INJ_CTL_EN_HI (1 << 2)
#define INTEL_ATOM_E3900_ERR_INJ_CTL_SEL_HI (1 << 3)
#define INTEL_ATOM_E3900_ERR_ECC_LOG_SYN(reg) ((reg >> 16) & 0x00ff)

#define INTEL_ATOM_E3900_MAX_CHANNELS 4
static void setup_apollolake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    UINT64 mcctrl = 0;
    UINT64 mcstatus = 0;

    MtSupportDebugWriteLine("Intel Apollo Lake (Atom E3900) SoC chipset init");

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_ATOM_E3900_MCHBAR_LO, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_ATOM_E3900_MCHBAR_LO, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_ATOM_E3900_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = (((UINT64)mchbar_high << 32) | mchbar_low) & 0x7FFFFF8000ULL;

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = ECC_CORRECT;
    ctrl->mode = ECC_NONE;

    // Get the memory controller capabiities
    if (ctrl->mchbar != 0)
    {
        unsigned long mc_bios_req;
        unsigned long drp0[INTEL_ATOM_E3900_MAX_CHANNELS];
        unsigned long err_ecc_log[INTEL_ATOM_E3900_MAX_CHANNELS];
        int ch = 0;

        mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_P_CR_MC_BIOS_REQ));

        AsciiSPrint(gBuffer, BUF_SIZE, "P_CR_MC_BIOS_REQ=%08x", mc_bios_req);
        MtSupportDebugWriteLine(gBuffer);

        for (ch = 0; ch < INTEL_ATOM_E3900_MAX_CHANNELS; ch++)
        {
            drp0[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_DRP0(ch)));

            AsciiSPrint(gBuffer, BUF_SIZE, "D_CR_DRP0[%d]=%08x", ch, drp0[ch]);
            MtSupportDebugWriteLine(gBuffer);

            if (drp0[ch] == 0xffffffff)
                continue;

            if ((drp0[ch] >> 21) & 1)
                ctrl->mode = ECC_CORRECT;

            err_ecc_log[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG(ch)));

            AsciiSPrint(gBuffer, BUF_SIZE, "D_CR_ERR_ECC_LOG[%d]=%08x", ch, err_ecc_log[ch]);
            MtSupportDebugWriteLine(gBuffer);

            /* Clear the error status */
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG(ch)), err_ecc_log[ch] | 0x80000000);
        }
    }

    _rdmsr64(MSR_IA32_MCi_CTL(4), &mcctrl);

    AsciiSPrint(gBuffer, BUF_SIZE, "MC4_CTRL=" I64HEXFMT, mcctrl);
    MtSupportDebugWriteLine(gBuffer);

    // Clear error status
    _rdmsr64(MSR_IA32_MCi_STATUS(4), &mcstatus);

    if (mcstatus)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "MC4_STATUS=" I64HEXFMT, mcstatus);
        MtSupportDebugWriteLine(gBuffer);
        _wrmsr64(MSR_IA32_MCi_STATUS(5), 0);
    }
}

static void poll_apollolake(struct ecc_info *ctrl)
{
    unsigned long syndrome;
    BOOLEAN corrected;

    UINT64 mcstatus = 0;
    UINT64 mcaddr = 0;

    unsigned long err_ecc_log[INTEL_ATOM_E3900_MAX_CHANNELS];

    /* Read the error status */
    for (UINT8 ch = 0; ch < INTEL_ATOM_E3900_MAX_CHANNELS; ch++)
    {
        err_ecc_log[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG(ch)));

        if (err_ecc_log[ch] == 0xffffffff)
            continue;

        if (err_ecc_log[ch] & (0x03 << 27))
        {
            AsciiSPrint(gBuffer, BUF_SIZE, "[Channel %d] D_CR_ERR_ECC_LOG=%08x", ch, err_ecc_log[ch]);
            MtSupportDebugWriteLine(gBuffer);

            syndrome = INTEL_ATOM_E3900_ERR_ECC_LOG_SYN(err_ecc_log[ch]);

            /* Parse the error location and error type */
            corrected = (err_ecc_log[ch] & (0x01 << 27)) ? 0 : 1;

            /* Report the error */
            MtSupportReportECCError_dimm(-1, -1, -1, -1, corrected, syndrome, -1, ch, 0);

            /* Clear the error status */
            writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_ECC_LOG(ch)), err_ecc_log[ch] | 0x80000000);
        }
    }

    // Read the MCE MSR registers and report any ECC errors

    /* Read the MC5 error status */
    _rdmsr64(MSR_IA32_MCi_STATUS(4), &mcstatus);

    if (mcstatus & MCI_STATUS_VAL)
    {
        UINT32 mserr;
        INT8 channel = -1;
        BOOLEAN uncorrected_error;

        AsciiSPrint(gBuffer, BUF_SIZE, "MC4_STATUS=" I64HEXFMT " (Overflow=%s, Uncorrected=%s, Corrected error count=%d, Error code=%04X)", mcstatus,
                    (mcstatus & (1ll << 62)) != 0 ? L"Yes" : L"No",
                    (mcstatus & (1ll << 61)) != 0 ? L"Yes" : L"No",
                    (UINT32)((mcstatus >> 38) & 0x7FFF),
                    (UINT32)(mcstatus & 0xFFFF));
        MtSupportDebugWriteLine(gBuffer);

        AsciiSPrint(gBuffer, BUF_SIZE, "Model specific error: ");
        mserr = (UINT32)((mcstatus >> 16) & 0xFFFF);
        switch (mserr)
        {
        case 0x0003:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "WBMTo* access to MMIO");
            break;

        case 0x0004:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "ClFlush to MMIO");
            break;

        case 0x0005:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "IA hit to graphics stolen memory");
            break;

        case 0x0006:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "XUCode Software initiated error");
            break;

        case 0x0007:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "BRAM write parity error");
            break;

        case 0x0008:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "BRAM read parity error");
            break;

        case 0x0009:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DRAM uncorrectable ecrc error");
            break;

        case 0x000A:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "DRAM correctable ecrc error");
            break;

        case 0x0002:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "MMIO Access HITM");
            break;

        case 0x0001:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "NonIDI access to MMIO");
            break;

        case 0x0000:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "Unsupported IDI opcode");
            break;

        default:
            AsciiStrCatS(gBuffer, sizeof(gBuffer), "Reserved");
            break;
        }
        MtSupportDebugWriteLine(gBuffer);
        if (mcstatus & MCI_STATUS_ADDRV)
            _rdmsr64(MSR_IA32_MCi_ADDR(4), &mcaddr);

        AsciiSPrint(gBuffer, BUF_SIZE, "MC4_ADDR=" I64HEXFMT, mcaddr);
        MtSupportDebugWriteLine(gBuffer);

        _wrmsr64(MSR_IA32_MCi_STATUS(4), 0);

        uncorrected_error = (mcstatus & (1ll << 61)) != 0;

        if (channel >= 0)
            MtSupportReportECCError((UINTN)mcaddr, !uncorrected_error, -1, -1, channel, 0);
    }
}

void inject_apollolake(int index, int uncorrectable, int enable)
{
    struct ecc_info *ctrl = NULL;
    int ch = 0;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    for (ch = 0; ch < INTEL_ATOM_E3900_MAX_CHANNELS; ch++)
    {
        unsigned long err_inj;
        unsigned long err_inj_ctl;

        err_inj = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ(ch)));
        err_inj_ctl = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CTL(ch)));

        if (err_inj_ctl == 0xffffffff)
            continue;

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_apollolake - [Channel %d] ERR_INJ=%08x, ERR_INJ_CTL=%08x", ch, err_inj, err_inj_ctl);
        MtSupportDebugWriteLine(gBuffer);

        err_inj_ctl &= 0xfffffff0;
        err_inj &= 0x80000001;

        if (enable)
        {
            if (uncorrectable)
            {
                err_inj_ctl |= INTEL_ATOM_E3900_ERR_INJ_CTL_EN_LO;
            }
            else
            {
                err_inj_ctl |= INTEL_ATOM_E3900_ERR_INJ_CTL_SEL_LO | INTEL_ATOM_E3900_ERR_INJ_CTL_EN_LO;
            }
            err_inj |= 0x10000;
        }

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_apollolake - [Channel %d] setting new ERR_INJ=%08x", ch, err_inj);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ(ch)), err_inj);

        AsciiSPrint(gBuffer, BUF_SIZE, "inject_apollolake - [Channel %d] setting new ERR_INJ_CTL=%08x", ch, err_inj_ctl);
        MtSupportDebugWriteLine(gBuffer);

        writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ATOM_E3900_MCHBAR_D_CR_ERR_INJ_CTL(ch)), err_inj_ctl);
    }
}

/*
 * Elkhart Lake memory controller
 *
 * Reference: Intel Atom x6000E Series Processor, and Intel Pentium and Celeron N and J Series Processors for IoT Applications External Design Specification (EDS), Volume 2 (Book 1 of 4) (Document Number: 602633)
 */
#define INTEL_ELKHARTLAKE_MCHBAR 0x48
#define INTEL_ELKHARTLAKE_MCHBAR_HI 0x4C

#define INTEL_ELKHARTLAKE_TOM 0xA0
#define INTEL_ELKHARTLAKE_TOM_HI 0xA4
#define INTEL_ELKHARTLAKE_TOUUD 0xA8
#define INTEL_ELKHARTLAKE_TOUUD_HI 0xAC
#define INTEL_ELKHARTLAKE_TOLUD 0xBC

#define INTEL_ELKHARTLAKE_CAPID0_A 0xE4
#define INTEL_ELKHARTLAKE_CAPID0_C 0xEC

#define INTEL_ELKHARTLAKE_CAPID0_A_PDCD(reg) ((reg >> 12) & 1)

#define INTEL_ELKHARTLAKE_CAPID0_C_IBECC_EN(reg) ((reg >> 15) & 1)

#define INTEL_ELKHARTLAKE_ERRSTS 0xC8

#define INTEL_ELKHARTLAKE_MCHBAR_MC_BIOS_REQ 0x5E00
#define INTEL_ELKHARTLAKE_MCHBAR_BCLK_FREQ 0x5F68
#define INTEL_ELKHARTLAKE_MCHBAR_MAD_INTER_CH 0x5000
#define INTEL_ELKHARTLAKE_MCHBAR_MAD_INTRA_CH0 0x5004
#define INTEL_ELKHARTLAKE_MCHBAR_MAD_INTRA_CH1 0x5008
#define INTEL_ELKHARTLAKE_MCHBAR_MAD_DIMM_CH0 0x500C
#define INTEL_ELKHARTLAKE_MCHBAR_MAD_DIMM_CH1 0x5010
#define INTEL_ELKHARTLAKE_MCHBAR_CHANNEL_HASH 0x5024
#define INTEL_ELKHARTLAKE_MCHBAR_CHANNEL_EHASH 0x5028
#define INTEL_ELKHARTLAKE_MCHBAR_REMAPBASE 0x5090
#define INTEL_ELKHARTLAKE_MCHBAR_REMAPLIMIT 0x5098

#define INTEL_ELKHARTLAKE_MCHBAR_TC_PRE(ch) (0x4000 + (ch * 0x400))
#define INTEL_ELKHARTLAKE_MCHBAR_TC_ODT(ch) (0x4070 + (ch * 0x400))
#define INTEL_ELKHARTLAKE_MCHBAR_SC_GS_CFG(ch) (0x4088 + (ch * 0x400))

#define INTEL_ELKHARTLAKE_MCHBAR_MC_INIT_STATE(ch) (0x4254 + (ch * 0x400))

#define INTEL_ELKHARTLAKE_MCHBAR_MC_LOCK (0x50FC)

#define INTEL_ELKHARTLAKE_MCHBAR_IBECC_ACTIVATE 0xDC00
#define INTEL_ELKHARTLAKE_IBECC_ACTIVATE_IBECC_EN(reg) (reg & 1)

#define INTEL_ELKHARTLAKE_MCHBAR_ECC_ERROR_LOG 0xDD70

#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERRSTS (1ULL << 63)
#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERRSTS (1ULL << 62)
#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_ERRSYND(reg) (BitExtractULL(reg, 61, 46))
#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_ERRADD(reg) (BitExtractULL(reg, 38, 5))

#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERR_OVERFLOW (1 << 4)
#define INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERR_OVERFLOW (1 << 3)

#define INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_ADDR_MASK 0xDD80
#define INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_ADDR_BASE 0xDD88
#define INTEL_ELKHARTLAKE_MCHBAR_PARITY_ERR_INJ 0xDD90
#define INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_CONTROL 0xDD98

#define INTEL_ELKHARTLAKE_DDR4 0
#define INTEL_ELKHARTLAKE_LPDDR4 3

typedef struct
{
    unsigned long capid0_c;
    unsigned long tolud;
    unsigned long long tom;
    unsigned long long ms_total_size;
    unsigned long mad_inter_ch;
    unsigned long ch_hash;
    unsigned long ch_ehash;
    unsigned long mad_intra[2], mad_dimm[2];
} ehl_data;

static void setup_elkhartlake(struct ecc_info *ctrl)
{
    // Activate MMR I/O
    unsigned long mchbar_low;
    unsigned long mchbar_high;

    ulong capid0;
    ulong ibecc_act;

    unsigned long tolud, tom_lo, tom_hi, touud_lo, touud_hi;
    unsigned long long tom, touud, remapbase, remaplimit;

    MtSupportDebugWriteLine("Intel Elkhart Lake chipset init");

    ctrl->userdata = AllocateZeroPool(sizeof(ehl_data));
    if (ctrl->userdata == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "Failed to allocate memory for controller specific data");
        return;
    }

    ehl_data *ehldata = (ehl_data *)ctrl->userdata;

    // Read the MCHBAR MMIO base address
    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_MCHBAR, 4, &mchbar_low);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_LO=%08x", mchbar_low);
    MtSupportDebugWriteLine(gBuffer);

    // Enable MCHBAR
    if (!(mchbar_low & 0x1))
    {
        pci_conf_write(0, 0, 0, INTEL_ELKHARTLAKE_MCHBAR, 1, (mchbar_low & 0xFF) | 1);
    }

    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_MCHBAR_HI, 4, &mchbar_high);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR_HI=%08x", mchbar_high);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->mchbar = LShiftU64(BitExtractULL(LShiftU64(mchbar_high, 32) | mchbar_low, 38, 16), 16);

    AsciiSPrint(gBuffer, BUF_SIZE, "MCHBAR=" I64HEXFMT, ctrl->mchbar);
    MtSupportDebugWriteLine(gBuffer);

    // Get the memory controller capabilities
    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_CAPID0_A, 4, &capid0);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_A=%08x", capid0);
    MtSupportDebugWriteLine(gBuffer);

    ctrl->cap = __ECC_INBAND;
    ctrl->mode = ECC_NONE;

    ctrl->numch = 2;
    ctrl->numsl = 2;
    ctrl->chmode = 0;

    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_CAPID0_C, 4, &ehldata->capid0_c);

    AsciiSPrint(gBuffer, BUF_SIZE, "CAPID0_C=%08x", ehldata->capid0_c);
    MtSupportDebugWriteLine(gBuffer);

    if (INTEL_ELKHARTLAKE_CAPID0_C_IBECC_EN(ehldata->capid0_c))
    {
        ibecc_act = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_IBECC_ACTIVATE));

        AsciiSPrint(gBuffer, BUF_SIZE, "IBECC_ACTIVATE=%08x", ibecc_act);
        MtSupportDebugWriteLine(gBuffer);

        if (ibecc_act == 0xffffffff)
            AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC_ACTIVATE is invalid");
        if (INTEL_ELKHARTLAKE_IBECC_ACTIVATE_IBECC_EN(ibecc_act))
        {
            unsigned long long errlog;

            errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_ERROR_LOG));

            AsciiSPrint(gBuffer, BUF_SIZE, "ECC_ERROR_LOG=" I64HEXFMT, errlog);
            MtSupportDebugWriteLine(gBuffer);

            if (errlog != (unsigned long long)-1)
            {
                ctrl->mode |= __ECC_INBAND;
                AsciiFPrint(DEBUG_FILE_HANDLE, "IBECC is enabled");

                /* Clear the error status */
                errlog |= INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERRSTS | INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERRSTS | INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERR_OVERFLOW | INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERR_OVERFLOW;
                writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_ERROR_LOG), errlog);
            }
            else
                AsciiFPrint(DEBUG_FILE_HANDLE, "ECC_ERROR_LOG is invalid");
        }
    }

    /* Read registers related to address decoding*/

    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_TOLUD, 4, &tolud);
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOLUD=%08x", tolud);

    ehldata->tolud = BitExtract(tolud, 31, 20) << 20;

    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_TOM, 4, &tom_lo);
    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_TOM_HI, 4, &tom_hi);

    tom = LShiftU64(tom_hi, 32) | tom_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOM=" I64HEXFMT, tom);

    tom = LShiftU64(BitExtractULL(tom, 38, 20), 20);

    if (tom < SIZE_4GB)
        tom = SIZE_4GB;

    ehldata->tom = tom;
    AsciiFPrint(DEBUG_FILE_HANDLE, "tolud=%p tom=%p", ehldata->tolud, ehldata->tom);

    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_TOUUD, 4, &touud_lo);
    pci_conf_read(0, 0, 0, INTEL_ELKHARTLAKE_TOUUD_HI, 4, &touud_hi);

    touud = LShiftU64(touud_hi, 32) | touud_lo;
    AsciiFPrint(DEBUG_FILE_HANDLE, "TOUUD=" I64HEXFMT, touud);

    remapbase = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_REMAPBASE));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPBASE=" I64HEXFMT, remapbase);

    remaplimit = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_REMAPLIMIT));
    AsciiFPrint(DEBUG_FILE_HANDLE, "REMAPLIMIT=" I64HEXFMT, remaplimit);

    ehldata->ms_total_size = 0;

    unsigned long long ch_s_size = 0, dimm_l_size = 0, dimm_s_size = 0;
    int ch_l_map = 0, dimm_l_map = 0;
    unsigned long mc_init_state;
    int ch;

    ehldata->mad_inter_ch = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MAD_INTER_CH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTER_CH=%08x", ehldata->mad_inter_ch);

    ch_s_size = LShiftU64(BitExtract(ehldata->mad_inter_ch, 19, 12), 29);
    ch_l_map = BitExtract(ehldata->mad_inter_ch, 4, 4);

    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch S size=%ld", ch_s_size);
    AsciiFPrint(DEBUG_FILE_HANDLE, "Ch L map=%d", ch_l_map);

    unsigned char ddr_type = BitExtract(ehldata->mad_inter_ch, 2, 0);
    if (ddr_type < 2)
    {
        static const CHAR16 *DDR_TYPE[] = {L"DDR4", L"DDR5"};
        AsciiFPrint(DEBUG_FILE_HANDLE, "DDR type=%s", DDR_TYPE[ddr_type]);
    }

    ehldata->ch_hash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_CHANNEL_HASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_HASH=%08x", ehldata->ch_hash);

    ehldata->ch_ehash = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_CHANNEL_EHASH));
    AsciiFPrint(DEBUG_FILE_HANDLE, "CHANNEL_EHASH=%08x", ehldata->ch_ehash);

    ehldata->ms_total_size = 0;
    for (ch = 0; ch < ctrl->numch; ch++)
    {
        mc_init_state = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MC_INIT_STATE(ch)));
        AsciiFPrint(DEBUG_FILE_HANDLE, "[MC%d] MC_INIT_STATE=%08x", ch, mc_init_state);

        ehldata->mad_intra[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MAD_INTRA_CH0 + 4 * ch));
        ehldata->mad_dimm[ch] = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MAD_DIMM_CH0 + 4 * ch));

        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_INTRA_CH%d=%08x", ch, ehldata->mad_intra[ch]);
        AsciiFPrint(DEBUG_FILE_HANDLE, "MAD_DIMM_CH%d=%08x", ch, ehldata->mad_dimm[ch]);

        dimm_l_size = LShiftU64(BitExtract(ehldata->mad_dimm[ch], 6, 0), 29);
        dimm_s_size = LShiftU64(BitExtract(ehldata->mad_dimm[ch], 22, 16), 29);
        dimm_l_map = BitExtract(ehldata->mad_intra[ch], 0, 0);

        ehldata->ms_total_size += dimm_s_size;
        ehldata->ms_total_size += dimm_l_size;

        unsigned int dimm_l_ranks = BitExtract(ehldata->mad_dimm[ch], 10, 9) + 1;
        unsigned int dimm_s_ranks = BitExtract(ehldata->mad_dimm[ch], 27, 26) + 1;
        unsigned int dimm_l_chipwidth = 1 << (BitExtract(ehldata->mad_dimm[ch], 8, 7) + 3);
        unsigned int dimm_s_chipwidth = 1 << (BitExtract(ehldata->mad_dimm[ch], 25, 24) + 3);

        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L size=%ld", ch, dimm_l_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L ranks=%d", ch, dimm_l_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L width=x%d", ch, dimm_l_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S size=%ld", ch, dimm_s_size);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S ranks=%d", ch, dimm_s_ranks);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM S width=x%d", ch, dimm_s_chipwidth);
        AsciiFPrint(DEBUG_FILE_HANDLE, "Ch%d DIMM L map=%d", ch, dimm_l_map);

        ctrl->numranks[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2] = (unsigned char)(dimm_l_map == 0 ? dimm_l_chipwidth : dimm_s_chipwidth);
        ctrl->numranks[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_ranks : dimm_s_ranks);
        ctrl->chipwidth[ch * 2 + 1] = (unsigned char)(dimm_l_map == 1 ? dimm_l_chipwidth : dimm_s_chipwidth);

        if (dimm_l_size > 0 || dimm_s_size > 0)
            ctrl->chmode++;
    }

    AsciiFPrint(DEBUG_FILE_HANDLE, "total size=%ld", ehldata->ms_total_size);
}

static void poll_elkhartlake(struct ecc_info *ctrl)
{
    unsigned long errsts;

    /* Read the error status */
    pci_conf_read(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ELKHARTLAKE_ERRSTS, 2, &errsts);
    if (errsts)
    {
        AsciiSPrint(gBuffer, BUF_SIZE, "ERRSTS=%04x", errsts);
        MtSupportDebugWriteLine(gBuffer);
    }

    // IBECC errors
    if (ctrl->mode & __ECC_INBAND)
    {
        unsigned long long errlog = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_ERROR_LOG));
        if ((errlog != (unsigned long long)-1) && // check register is valid
            (errlog & (INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERRSTS | INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERRSTS)))
        {
            unsigned long long addr;
            addr = INTEL_ELKHARTLAKE_ECC_ERROR_LOG_ERRADD(errlog);
            UINT32 syndrome = (UINT32)INTEL_ELKHARTLAKE_ECC_ERROR_LOG_ERRSYND(errlog);
            UINT8 corrected = (errlog & INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERRSTS) == 0;

            AsciiSPrint(gBuffer, BUF_SIZE, "IBECC_ERROR_LOG=" I64HEXFMT " (addr=%p, synd=%04x, corrected=%d)", errlog, (PVOID)addr, syndrome, corrected);
            MtSupportDebugWriteLine(gBuffer);

            /* Report the error */
            MtSupportReportIBECCError((UINTN)addr, corrected, syndrome, -1, -1, -1);

            /* Clear the error status */
            errlog |= INTEL_ELKHARTLAKE_ECC_ERROR_LOG_MERRSTS | INTEL_ELKHARTLAKE_ECC_ERROR_LOG_CERRSTS;
            writemmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_ERROR_LOG), errlog);
        }
    }

    if (errsts & 0xC0)
    {
        /* Clear the error status */
        pci_conf_write(ctrl->bus, ctrl->dev, ctrl->fn, INTEL_ELKHARTLAKE_ERRSTS, 2, errsts);
    }
}

void inject_elkhartlake(int index, int uncorrectable, int enable)
{
    unsigned long ecc_inj_control = 0;
    unsigned long parity_err_inj = 0;
    unsigned int val;
    unsigned long long val64;
    struct ecc_info *ctrl = NULL;

    if (index < 0 || index >= s_numctrls)
        return;

    ctrl = &s_ctrl[index];

    // Locked by: MC_LOCK_0_0_0_MCHBAR.LOCK_MC_DFT
    val = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MC_LOCK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - MC Lock = %08x (%s)", val, (val & (1 << 7)) ? L"locked" : L"unlocked");
    MtSupportDebugWriteLine(gBuffer);

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_ADDR_BASE));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - ECC Error Injection Address Base = " I64HEXFMT, val64);
    MtSupportDebugWriteLine(gBuffer);

    val64 = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_ADDR_MASK));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - ECC Injection Address Mask = " I64HEXFMT, val64);
    MtSupportDebugWriteLine(gBuffer);

    parity_err_inj = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_PARITY_ERR_INJ));
    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - Parity Error Injection = %08x", parity_err_inj);
    MtSupportDebugWriteLine(gBuffer);

    // Parity Error Injection (PARITY_ERR_INJ)
    // 17:16 Data Parity Injection Mask (ERR_INJ_MASK):
    //  Specifies the checker that the data errors are injected on. 0x0: data parity injection
    //  is disabled (DATA_ERR_EN is ignored), 0x1: partial write data checker injection
    //  enable, 0x2: read data checker injection enable, 0x3: enable injection on both partial
    //  write data checker and read data checker
    // 10:9 Byte Enable Parity Flip Enable (BE_ERR_EN):
    //  1 control bit per wbe parity bit received. Bit 0 is for lower 32B and bit 1 is for upper
    //  32B. If set to 1, the byte enable parity bit received for the next partial write
    //  transaction will be inverted; This bit will be cleared to 1'b0 by HW after a transaction
    //  has been received with a parity error injected.
    // 7:0 Data Parity Flip Enables (DATA_ERR_EN):
    //  1 control bit per data parity bit being generated; If set to 1, the corresponding data
    //  parity bit received for the next transaction will be inverted; This bit will be cleared to
    //  1'b0 by HW after a transaction has been received with a parity error
    parity_err_inj |= 0x3 << 16;
    parity_err_inj |= 0x1;

    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - new Parity Error Injection = %08x", parity_err_inj);
    MtSupportDebugWriteLine(gBuffer);

    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_PARITY_ERR_INJ), parity_err_inj);

    ecc_inj_control = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_CONTROL));

    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - ECC_INJ_CONTROL = %08x", ecc_inj_control);
    MtSupportDebugWriteLine(gBuffer);

    ecc_inj_control &= 0xFFFF00F8;

    // Error Injection Mode (ECC_INJECT):
    // ECC error inject options :
    // 000b : No ECC error injection.
    // 001b : Inject correctable ECC error on ECC_INJ_ADDR_COMPARE register match.
    // 010b : Inject a correctable ECC error on Injection Count
    // 011b : Inject correctable ECC error on ECC error insertion counter.
    // 100b : Inject a non-recoverable ECC error on Injection Count
    // 101b : Inject non - recoverable ECC error on ECC_INJ_ADDR_COMPARE register match(same as on poison)
    // 111b : Inject non - recoverable ECC error on ECC error insertion counter(same as on poison)
    if (enable == 0)
        ecc_inj_control &= ~0x7;
    else if (uncorrectable == 1)
        ecc_inj_control |= 0x104;
    else if (uncorrectable == 0)
        ecc_inj_control |= 0x102;

    AsciiSPrint(gBuffer, BUF_SIZE, "inject_elkhartlake - new ECC_INJ_CONTROL = %08x", ecc_inj_control);
    MtSupportDebugWriteLine(gBuffer);

    writemmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_ECC_INJ_CONTROL), ecc_inj_control);
}

void poll_timings_elkhartlake(struct ecc_info *ctrl)
{
    ehl_data *ehldata = (ehl_data *)ctrl->userdata;

    unsigned int freq_mult = 1;
    unsigned int gear_mode = 1;

    unsigned char ddr_type = BitExtract(ehldata->mad_inter_ch, 2, 0);
    switch (ddr_type)
    {
    case INTEL_ELKHARTLAKE_DDR4:
        freq_mult = BitExtract(ehldata->capid0_c, 27, 23);
        break;
    case INTEL_ELKHARTLAKE_LPDDR4:
        freq_mult = BitExtract(ehldata->capid0_c, 21, 17);
        break;
    default:
        break;
    }
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_elkhartlake - freq_mult=%d", freq_mult);

    for (int ch = 0; ch < ctrl->numch; ch++)
    {
        unsigned long long dimm_l_size = LShiftU64(BitExtract(ehldata->mad_dimm[ch], 6, 0), 29);
        unsigned long long dimm_s_size = LShiftU64(BitExtract(ehldata->mad_dimm[ch], 22, 16), 29);
        unsigned long long ch_size = dimm_l_size + dimm_s_size;

        if (ch_size == 0)
            continue;

        unsigned long tc_pre = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_TC_PRE(ch)));
        unsigned long long tc_odt = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_TC_ODT(ch)));
        unsigned long long sc_gs_cfg = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_SC_GS_CFG(ch)));

        unsigned char tCL = (unsigned char)BitExtractULL(tc_odt, 21, 16);
        unsigned char tRCD = (unsigned char)BitExtractULL(tc_pre, 5, 0);
        unsigned char tRAS = (unsigned char)BitExtractULL(tc_pre, 15, 9);
        unsigned char tRP = (unsigned char)BitExtractULL(tc_pre, 5, 0);

        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_elkhartlake - [Ch %d] TC_PRE=%08x TC_ODT=" I64HEXFMT " (%d-%d-%d-%d)", ch, tc_pre, tc_odt, tCL, tRCD, tRP, tRAS);

        if (tCL < 4 ||  /* tCL > 36 || */
            tRCD < 8 || /* tRCD > 59 || */
            tRP < 8 ||  /* tRP > 59 || */
            tRAS < 28 /* || tRAS > 90 */)
            continue;

        ctrl->tAA = tCL;
        ctrl->tRCD = tRCD;
        ctrl->tRAS = tRAS;
        ctrl->tRP = tRP;

        gear_mode = 1 << BitExtractULL(sc_gs_cfg, 31, 31);
    }

    unsigned long mc_bios_req = readmmio32((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_MC_BIOS_REQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_elkhartlake - MC_BIOS_REQ=%08x (REQ_DATA=%d, REQ_TYPE=%d, GEAR_TYPE=%d)", mc_bios_req, BitExtract(mc_bios_req, 7, 0), BitExtract(mc_bios_req, 11, 8), BitExtract(mc_bios_req, 13, 12));
    unsigned int qclk_ratio = BitExtract(mc_bios_req, 7, 0);
    unsigned int qclk_ref = BitExtract(mc_bios_req, 11, 8);

    unsigned long long bclk_freq = readmmio64((unsigned int *)((UINTN)ctrl->mchbar + INTEL_ELKHARTLAKE_MCHBAR_BCLK_FREQ));
    AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_elkhartlake - BCLK_FREQ=" I64HEXFMT, bclk_freq);

    unsigned int bclk_khz = 100000; // 100.0Mhz default
    if (bclk_freq != 0 && bclk_freq != (unsigned long long)-1)
        bclk_khz = (unsigned int)BitExtractULL(bclk_freq, 31, 0);
    else
        AsciiFPrint(DEBUG_FILE_HANDLE, "poll_timings_elkhartlake - invalid BCLK_FREQ, using default BCLK 100.0MHz");

    if (qclk_ratio == 0)
    {
        ctrl->memclk = (266 * freq_mult) + ((334 * freq_mult) / 501);
    }
    else
    {
        if (qclk_ref == 0) // 0: 133.34Mhz. In frequency calculations use 400.0MHz/3.0
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode * 4 / 3) / (2 * 1000);
        else // 1: 100.00Mhz
            ctrl->memclk = (qclk_ratio * bclk_khz * gear_mode) / (2 * 1000);
    }
}

#if 0 // for detecting FSB. Not used
/* ------------------ Here the code for FSB detection ------------------ */
/* --------------------------------------------------------------------- */

static float athloncoef[] = { 11, 11.5, 12.0, 12.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 10.0, 10.5 };
static float athloncoef2[] = { 12, 19.0, 12.0, 20.0, 13.0, 13.5, 14.0, 21.0, 15.0, 22, 16.0, 16.5, 17.0, 18.0, 23.0, 24.0 };
static float p4model1ratios[] = { 16, 17, 18, 19, 20, 21, 22, 23, 8, 9, 10, 11, 12, 13, 14, 15 };

static float getP4PMmultiplier(void)
{
    unsigned int msr_lo, msr_hi;
    float coef;
    /* Find multiplier (by MSR) */

    if (cpu_id.vers.bits.family /* cpu_id.type */ == 6) {
        if ((cpu_id.fid.uint32_array[0] /* cpu_id.feature_flag */ >> 7) & 1) {
            rdmsr(0x198, msr_lo, msr_hi);
            coef = ((msr_lo >> 8) & 0x1F);
            if ((msr_lo >> 14) & 0x1) { coef = coef + 0.5f; }
        }
        else {
            rdmsr(0x2A, msr_lo, msr_hi);
            coef = (msr_lo >> 22) & 0x1F;
        }
    }
    else
    {
        if (cpu_id.vers.bits.model /* cpu_id.model */ < 2)
        {
            rdmsr(0x2A, msr_lo, msr_hi);
            coef = (msr_lo >> 8) & 0xF;
            coef = p4model1ratios[(int)coef];
        }
        else
        {
            rdmsr(0x2C, msr_lo, msr_hi);
            coef = (msr_lo >> 24) & 0x1F;
        }
    }
    return coef;
}

static float getNHMmultiplier(void)
{
    unsigned int msr_lo, msr_hi;
    float coef;

    /* Find multiplier (by MSR) */
    /* First, check if Flexible Ratio is Enabled */
    rdmsr(0x194, msr_lo, msr_hi);
    if ((msr_lo >> 16) & 1) {
        coef = (msr_lo >> 8) & 0xFF;
    }
    else {
        rdmsr(0xCE, msr_lo, msr_hi);
        coef = (msr_lo >> 8) & 0xFF;
    }

    return coef;
}

static void poll_fsb_amd64(void) {

    unsigned int mcgsrl;
    unsigned int mcgsth;
    unsigned long fid, temp2;
    unsigned long dramchr;
    float clockratio;
    double dramclock;

    float coef = 10;

    unsigned int dummy[3], pwrcap;

    /* First, got the FID by MSR */
    /* First look if Cool 'n Quiet is supported to choose the best msr */
    AsmCpuid(0x80000007, &dummy[0], &dummy[1],
        &dummy[2], &pwrcap);
    if (((pwrcap /* cpu_id.pwrcap */ >> 1) & 1) == 1) {
        rdmsr(0xc0010042, mcgsrl, mcgsth);
        fid = (mcgsrl & 0x3F);
    }
    else {
        rdmsr(0xc0010015, mcgsrl, mcgsth);
        fid = ((mcgsrl >> 24) & 0x3F);
    }

    /* Extreme simplification. */
    coef = (fid / 2) + 4.0;

    /* Support for .5 coef */
    if (fid & 1) { coef = coef + 0.5; }

    /* Next, we need the clock ratio */

    if (((cpu_id.max_xcpuid /*cpu_id.ext */ >> 16) & 0xF) >= 4) {
        /* K8 0FH */
        pci_conf_read(0, 24, 2, 0x94, 4, &dramchr);
        temp2 = (dramchr & 0x7);
        clockratio = coef;

        switch (temp2) {
        case 0x0:
            clockratio = (int)(coef);
            break;
        case 0x1:
            clockratio = (int)(coef * 3.0f / 4.0f);
            break;
        case 0x2:
            clockratio = (int)(coef * 3.0f / 5.0f);
            break;
        case 0x3:
            clockratio = (int)(coef * 3.0f / 6.0f);
            break;
        }

    }
    else {
        /* OLD K8 */
        pci_conf_read(0, 24, 2, 0x94, 4, &dramchr);
        temp2 = (dramchr >> 20) & 0x7;
        clockratio = coef;

        switch (temp2) {
        case 0x0:
            clockratio = (int)(coef * 2.0f);
            break;
        case 0x2:
            clockratio = (int)((coef * 3.0f / 2.0f) + 0.81f);
            break;
        case 0x4:
            clockratio = (int)((coef * 4.0f / 3.0f) + 0.81f);
            break;
        case 0x5:
            clockratio = (int)((coef * 6.0f / 5.0f) + 0.81f);
            break;
        case 0x6:
            clockratio = (int)((coef * 10.0f / 9.0f) + 0.81f);
            break;
        case 0x7:
            clockratio = (int)(coef + 0.81f);
            break;
        }
    }

    /* Compute the final DRAM Clock */
    dramclock = (extclock / 1000) / clockratio;

    /* ...and print */
    print_fsb_info(dramclock, "RAM : ", "DDR");

}

static void poll_fsb_k10(void) {

    unsigned int mcgsrl;
    unsigned int mcgsth;
    unsigned long temp2;
    unsigned long dramchr;
    unsigned long mainPllId;
    double dramclock;

    /* First, we need the clock ratio */
    pci_conf_read(0, 24, 2, 0x94, 4, &dramchr);
    temp2 = (dramchr & 0x7);

    switch (temp2) {
    case 0x7: temp2++;
    case 0x6: temp2++;
    case 0x5: temp2++;
    case 0x4: temp2++;
    default:  temp2 += 3;
    }


    /* Compute the final DRAM Clock */
    if (((cpu_id.max_xcpuid /*cpu_id.ext */ >> 20) & 0xFF) == 1)
        dramclock = ((temp2 * 200) / 3.0) + 0.25;
    else {
        unsigned long target;
        unsigned long dx;
        unsigned      divisor;


        target = temp2 * 400;

        /* Get the FID by MSR */
        rdmsr(0xc0010071, mcgsrl, mcgsth);

        pci_conf_read(0, 24, 3, 0xD4, 4, &mainPllId);

        if (mainPllId & 0x40)
            mainPllId &= 0x3F;
        else
            mainPllId = 8;  /* FID for 1600 */

        mcgsth = (mcgsth >> 17) & 0x3F;
        if (mcgsth) {
            if (mainPllId > mcgsth)
                mainPllId = mcgsth;
        }

        dx = (mainPllId + 8) * 1200;
        for (divisor = 3; divisor < 100; divisor++)
            if ((dx / divisor) <= target)
                break;

        dramclock = ((dx / divisor) / 6.0) + 0.25;
        /*
         *      dramclock = ((((dx * extclock) / divisor) / (mainPllId+8)) / 600000.0) + 0.25;
         */
    }

    /* ...and print */
    print_fsb_info(dramclock, "RAM : ", "DDR");

}

static void poll_fsb_i925(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, mchcfg2, dev0, drc, idetect;
    float coef = getP4PMmultiplier();
    long *ptr;

    pci_conf_read(0, 0, 0, 0x02, 2, &idetect);

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0x44, 4, &dev0);
    dev0 = dev0 & 0xFFFFC000;
    ptr = (long*)(dev0 + 0xC00);
    mchcfg = *ptr & 0xFFFF;
    ptr = (long*)(dev0 + 0x120);
    drc = *ptr & 0xFFFF;
    dramratio = 1;

    mchcfg2 = (mchcfg >> 4) & 3;

    if ((drc & 3) != 2) {
        // We are in DDR1 Mode
        if (mchcfg2 == 1) { dramratio = 0.8; }
        else { dramratio = 1; }
    }
    else {
        // We are in DDR2 Mode
        if ((mchcfg >> 2) & 1) {
            // We are in FSB1066 Mode
            if (mchcfg2 == 2) { dramratio = 0.75; }
            else { dramratio = 1; }
        }
        else {
            switch (mchcfg2) {
            case 1:
                dramratio = 0.66667;
                break;
            case 2:
                if (idetect != 0x2590) { dramratio = 1; }
                else { dramratio = 1.5; }
                break;
            case 3:
                // Checking for FSB533 Mode & Alviso
                if ((mchcfg & 1) == 0) { dramratio = 1.33334; }
                else if (idetect == 0x2590) { dramratio = 2; }
                else { dramratio = 1.5; }
            }
        }
    }
    // Compute RAM Frequency 
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq 
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_i945(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, dev0;
    float coef = getP4PMmultiplier();
    long *ptr;

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0x44, 4, &dev0);
    dev0 &= 0xFFFFC000;
    ptr = (long*)(dev0 + 0xC00);
    mchcfg = *ptr & 0xFFFF;
    dramratio = 1;

    switch ((mchcfg >> 4) & 7) {
    case 1: dramratio = 1.0; break;
    case 2: dramratio = 1.33334; break;
    case 3: dramratio = 1.66667; break;
    case 4: dramratio = 2.0; break;
    }

    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_i975(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, dev0, fsb_mch;
    float coef = getP4PMmultiplier();
    long *ptr;

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0x44, 4, &dev0);
    dev0 &= 0xFFFFC000;
    ptr = (long*)(dev0 + 0xC00);
    mchcfg = *ptr & 0xFFFF;
    dramratio = 1;

    switch (mchcfg & 7) {
    case 1: fsb_mch = 533; break;
    case 2: fsb_mch = 800; break;
    case 3: fsb_mch = 667; break;
    default: fsb_mch = 1066; break;
    }


    switch (fsb_mch) {
    case 533:
        switch ((mchcfg >> 4) & 7) {
        case 0: dramratio = 1.25; break;
        case 1: dramratio = 1.5; break;
        case 2: dramratio = 2.0; break;
        }
        break;

    default:
    case 800:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 1.0; break;
        case 2: dramratio = 1.33334; break;
        case 3: dramratio = 1.66667; break;
        case 4: dramratio = 2.0; break;
        }
        break;

    case 1066:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 0.75; break;
        case 2: dramratio = 1.0; break;
        case 3: dramratio = 1.25; break;
        case 4: dramratio = 1.5; break;
        }
        break;
    }


    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_i965(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, dev0, fsb_mch;
    float coef = getP4PMmultiplier();
    long *ptr;

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0x48, 4, &dev0);
    dev0 &= 0xFFFFC000;
    ptr = (long*)(dev0 + 0xC00);
    mchcfg = *ptr & 0xFFFF;
    dramratio = 1;

    switch (mchcfg & 7) {
    case 0: fsb_mch = 1066; break;
    case 1: fsb_mch = 533; break;
    default: case 2:    fsb_mch = 800; break;
    case 3: fsb_mch = 667; break;
    case 4: fsb_mch = 1333; break;
    case 6: fsb_mch = 1600; break;
    }


    switch (fsb_mch) {
    case 533:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 2.0; break;
        case 2: dramratio = 2.5; break;
        case 3: dramratio = 3.0; break;
        }
        break;

    default:
    case 800:
        switch ((mchcfg >> 4) & 7) {
        case 0: dramratio = 1.0; break;
        case 1: dramratio = 5.0f / 4.0f; break;
        case 2: dramratio = 5.0f / 3.0f; break;
        case 3: dramratio = 2.0; break;
        case 4: dramratio = 8.0f / 3.0f; break;
        case 5: dramratio = 10.0f / 3.0f; break;
        }
        break;

    case 1066:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 1.0f; break;
        case 2: dramratio = 5.0f / 4.0f; break;
        case 3: dramratio = 3.0f / 2.0f; break;
        case 4: dramratio = 2.0f; break;
        case 5: dramratio = 5.0f / 2.0f; break;
        }
        break;

    case 1333:
        switch ((mchcfg >> 4) & 7) {
        case 2: dramratio = 1.0f; break;
        case 3: dramratio = 6.0f / 5.0f; break;
        case 4: dramratio = 8.0f / 5.0f; break;
        case 5: dramratio = 2.0f; break;
        }
        break;

    case 1600:
        switch ((mchcfg >> 4) & 7) {
        case 3: dramratio = 1.0f; break;
        case 4: dramratio = 4.0f / 3.0f; break;
        case 5: dramratio = 3.0f / 2.0f; break;
        case 6: dramratio = 2.0f; break;
        }
        break;

    }

    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_im965(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, dev0, fsb_mch;
    float coef = getP4PMmultiplier();
    long *ptr;

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0x48, 4, &dev0);
    dev0 &= 0xFFFFC000;
    ptr = (long*)(dev0 + 0xC00);
    mchcfg = *ptr & 0xFFFF;
    dramratio = 1;

    switch (mchcfg & 7) {
    case 1: fsb_mch = 533; break;
    default: case 2:    fsb_mch = 800; break;
    case 3: fsb_mch = 667; break;
    case 6: fsb_mch = 1066; break;
    }


    switch (fsb_mch) {
    case 533:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 5.0f / 4.0f; break;
        case 2: dramratio = 3.0f / 2.0f; break;
        case 3: dramratio = 2.0f; break;
        }
        break;

    case 667:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 1.0f; break;
        case 2: dramratio = 6.0f / 5.0f; break;
        case 3: dramratio = 8.0f / 5.0f; break;
        case 4: dramratio = 2.0f; break;
        case 5: dramratio = 12.0f / 5.0f; break;
        }
        break;
    default:
    case 800:
        switch ((mchcfg >> 4) & 7) {
        case 1: dramratio = 5.0f / 6.0f; break;
        case 2: dramratio = 1.0f; break;
        case 3: dramratio = 4.0f / 3.0f; break;
        case 4: dramratio = 5.0f / 3.0f; break;
        case 5: dramratio = 2.0f; break;
        }
        break;
    case 1066:
        switch ((mchcfg >> 4) & 7) {
        case 5: dramratio = 3.0f / 2.0f; break;
        case 6: dramratio = 2.0f; break;
        }
        break;
    }

    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}


static void poll_fsb_5400(void) {

    double dramclock, dramratio, fsb;
    unsigned long ambase_low, ambase_high, ddrfrq;
    float coef = getP4PMmultiplier();

    /* Find dramratio */
    pci_conf_read(0, 16, 0, 0x48, 4, &ambase_low);
    ambase_low &= 0xFFFE0000;
    pci_conf_read(0, 16, 0, 0x4C, 4, &ambase_high);
    ambase_high &= 0xFF;
    pci_conf_read(0, 16, 1, 0x56, 1, &ddrfrq);
    ddrfrq &= 7;
    dramratio = 1;

    switch (ddrfrq) {
    case 0:
    case 1:
    case 4:
        dramratio = 1.0;
        break;
    case 2:
        dramratio = 5.0f / 4.0f;
        break;
    case 3:
    case 7:
        dramratio = 4.0f / 5.0f;
        break;
    }


    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 5, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}


static void poll_fsb_nf4ie(void) {

    double dramclock, dramratio, fsb;
    float mratio, nratio;
    unsigned long reg74, reg60;
    float coef = getP4PMmultiplier();

    /* Find dramratio */
    pci_conf_read(0, 0, 2, 0x74, 2, &reg74);
    pci_conf_read(0, 0, 2, 0x60, 4, &reg60);
    mratio = reg74 & 0xF;
    nratio = (reg74 >> 4) & 0xF;

    // If M or N = 0, then M or N = 16
    if (mratio == 0) { mratio = 16; }
    if (nratio == 0) { nratio = 16; }

    // Check if synchro or pseudo-synchro mode
    if ((reg60 >> 22) & 1) {
        dramratio = 1;
    }
    else {
        dramratio = nratio / mratio;
    }

    /* Compute RAM Frequency */
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio;

    /* Print DRAM Freq */
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB  */
    cprint(LINE_CPU + 5, col, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_i875(void) {

    double dramclock, dramratio, fsb;
    unsigned long mchcfg, smfs;
    float coef = getP4PMmultiplier();

    /* Find dramratio */
    pci_conf_read(0, 0, 0, 0xC6, 2, &mchcfg);
    smfs = (mchcfg >> 10) & 3;
    dramratio = 1;

    if ((mchcfg & 3) == 3) { dramratio = 1; }
    if ((mchcfg & 3) == 2) {
        if (smfs == 2) { dramratio = 1; }
        if (smfs == 1) { dramratio = 1.25; }
        if (smfs == 0) { dramratio = 1.5; }
    }
    if ((mchcfg & 3) == 1) {
        if (smfs == 2) { dramratio = 0.6666666666; }
        if (smfs == 1) { dramratio = 0.8; }
        if (smfs == 0) { dramratio = 1; }
    }
    if ((mchcfg & 3) == 0) { dramratio = 0.75; }


    /* Compute RAM Frequency */
    dramclock = ((extclock / 1000) / coef) / dramratio;
    fsb = ((extclock / 1000) / coef);

    /* Print DRAM Freq */
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    if (ctrl.mode == ECC_NONE) {
        cprint(LINE_CPU + 5, col + 1, "- FSB : ");
        col += 9;
        dprint(LINE_CPU + 5, col, fsb, 3, 0);
        col += 3;
        cprint(LINE_CPU + 5, col + 1, "MHz");
        col += 4;
    }
}

static void poll_fsb_p4(void) {

    ulong fsb, idetect;
    float coef = getP4PMmultiplier();

    fsb = ((extclock / 1000) / coef);

    /* Print FSB */
    cprint(LINE_CPU + 5, col + 1, "/ FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

    /* For synchro only chipsets */
    pci_conf_read(0, 0, 0, 0x02, 2, &idetect);
    if (idetect == 0x2540 || idetect == 0x254C) {
        print_fsb_info(fsb, "RAM : ", "DDR");
    }
}

static void poll_fsb_i855(void) {


    double dramclock, dramratio, fsb;
    unsigned int msr_lo, msr_hi;
    ulong mchcfg, centri, idetect;
    int coef;

    pci_conf_read(0, 0, 0, 0x02, 2, &idetect);

    /* Find multiplier (by MSR) */

    /* Is it a Pentium M ? */
    if (cpu_id.vers.bits.family /*cpu_id.type*/ == 6) {
        rdmsr(0x2A, msr_lo, msr_hi);
        coef = (msr_lo >> 22) & 0x1F;

        /* Is it an i855GM or PM ? */
        if (idetect == 0x3580) {
            cprint(LINE_CPU + 5, col - 1, "i855GM/GME ");
            col += 10;
        }
    }
    else {
        rdmsr(0x2C, msr_lo, msr_hi);
        coef = (msr_lo >> 24) & 0x1F;
        cprint(LINE_CPU + 5, col - 1, "i852PM/GM ");
        col += 9;
    }

    fsb = ((extclock / 1000) / coef);

    /* Print FSB */
    cprint(LINE_CPU + 5, col, "/ FSB : ");    col += 8;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);  col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");  col += 4;

    /* Is it a Centrino platform or only an i855 platform ? */
    pci_conf_read(2, 2, 0, 0x02, 2, &centri);
    if (centri == 0x1043) { cprint(LINE_CPU + 5, col + 1, "/ Centrino Mobile Platform"); }
    else { cprint(LINE_CPU + 5, col + 1, "/ Mobile Platform"); }

    /* Compute DRAM Clock */

    dramratio = 1;
    if (idetect == 0x3580) {
        pci_conf_read(0, 0, 3, 0xC0, 2, &mchcfg);
        mchcfg = mchcfg & 0x7;

        if (mchcfg == 1 || mchcfg == 2 || mchcfg == 4 || mchcfg == 5) { dramratio = 1; }
        if (mchcfg == 0 || mchcfg == 3) { dramratio = 1.333333333; }
        if (mchcfg == 6) { dramratio = 1.25; }
        if (mchcfg == 7) { dramratio = 1.666666667; }

    }
    else {
        pci_conf_read(0, 0, 0, 0xC6, 2, &mchcfg);
        if (((mchcfg >> 10) & 3) == 0) { dramratio = 1; }
        else if (((mchcfg >> 10) & 3) == 1) { dramratio = 1.666667; }
        else { dramratio = 1.333333333; }
    }


    dramclock = fsb * dramratio;

    /* ...and print */
    print_fsb_info(dramclock, "RAM : ", "DDR");

}

static void poll_fsb_amd32(void) {

    unsigned int mcgsrl;
    unsigned int mcgsth;
    unsigned long temp;
    double dramclock;
    double coef2;

    /* First, got the FID */
    rdmsr(0x0c0010015, mcgsrl, mcgsth);
    temp = (mcgsrl >> 24) & 0x0F;

    if ((mcgsrl >> 19) & 1) { coef2 = athloncoef2[temp]; }
    else { coef2 = athloncoef[temp]; }

    if (coef2 == 0) { coef2 = 1; };

    /* Compute the final FSB Clock */
    dramclock = (extclock / 1000) / coef2;

    /* ...and print */
    print_fsb_info(dramclock, "FSB : ", "DDR");

}

static void poll_fsb_nf2(void) {

    unsigned int mcgsrl;
    unsigned int mcgsth;
    unsigned long temp, mempll;
    double dramclock, fsb;
    double mem_m, mem_n;
    float coef;
    coef = 10;

    /* First, got the FID */
    rdmsr(0x0c0010015, mcgsrl, mcgsth);
    temp = (mcgsrl >> 24) & 0x0F;

    if ((mcgsrl >> 19) & 1) { coef = athloncoef2[temp]; }
    else { coef = athloncoef[temp]; }

    /* Get the coef (COEF = N/M) - Here is for Crush17 */
    pci_conf_read(0, 0, 3, 0x70, 4, &mempll);
    mem_m = (mempll & 0x0F);
    mem_n = ((mempll >> 4) & 0x0F);

    /* If something goes wrong, the chipset is probably a Crush18 */
    if (mem_m == 0 || mem_n == 0) {
        pci_conf_read(0, 0, 3, 0x7C, 4, &mempll);
        mem_m = (mempll & 0x0F);
        mem_n = ((mempll >> 4) & 0x0F);
    }

    /* Compute the final FSB Clock */
    dramclock = ((extclock / 1000) / coef) * (mem_n / mem_m);
    fsb = ((extclock / 1000) / coef);

    /* ...and print */

    cprint(LINE_CPU + 5, col, "/ FSB : ");
    col += 8;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");

    print_fsb_info(dramclock, "RAM : ", "DDR");

}

static void poll_fsb_us15w(void) {

    double dramclock, dramratio, fsb, gfx;
    unsigned long msr;

    /* Find dramratio */
    /* D0 MsgRd, 05 Zunit, 03 MSR */
    pci_conf_write(0, 0, 0, 0xD0, 4, 0xD0050300);
    pci_conf_read(0, 0, 0, 0xD4, 4, &msr);
    fsb = (msr >> 3) & 1;

    dramratio = 0.5;

    // Compute RAM Frequency
    if ((msr >> 3) & 1) {
        fsb = 533;
    }
    else {
        fsb = 400;
    }

    switch ((msr >> 0) & 7) {
    case 0:
        gfx = 100;
        break;
    case 1:
        gfx = 133;
        break;
    case 2:
        gfx = 150;
        break;
    case 3:
        gfx = 178;
        break;
    case 4:
        gfx = 200;
        break;
    case 5:
        gfx = 266;
        break;
    default:
        gfx = 0;
        break;
    }

    dramclock = fsb * dramratio;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR");

    /* Print FSB (only if ECC is not enabled) */
    cprint(LINE_CPU + 4, col + 1, "- FSB : ");
    col += 9;
    dprint(LINE_CPU + 4, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 4, col + 1, "MHz");
    col += 4;

    cprint(LINE_CPU + 4, col + 1, "- GFX : ");
    col += 9;
    dprint(LINE_CPU + 4, col, gfx, 3, 0);
    col += 3;
    cprint(LINE_CPU + 4, col + 1, "MHz");
    col += 4;

}

static void poll_fsb_nhm(void) {

    double dramclock, dramratio, fsb;
    unsigned long mc_dimm_clk_ratio, qpi_pll_status;
    float coef = getNHMmultiplier();
    float qpi_speed;

    fsb = ((extclock / 1000) / coef);

    /* Print FSB */
    cprint(LINE_CPU + 5, col + 1, "/ FSB : ");
    col += 9;
    dprint(LINE_CPU + 5, col, fsb, 3, 0);
    col += 3;
    cprint(LINE_CPU + 5, col + 1, "MHz");
    col += 4;

    /* Print QPI Speed (if ECC not supported) */
    if (ctrl.mode == ECC_NONE) {
        pci_conf_read(nhm_bus, 2, 1, 0x50, 2, &qpi_pll_status);
        qpi_speed = (qpi_pll_status & 0x7F) * ((extclock / 1000) / coef) * 2;
        cprint(LINE_CPU + 5, col + 1, "/ QPI : ");
        col += 9;
        dprint(LINE_CPU + 5, col, qpi_speed / 1000, 1, 0);
        col += 1;
        cprint(LINE_CPU + 5, col, ".");
        col += 1;
        qpi_speed = ((qpi_speed / 1000) - (int)(qpi_speed / 1000)) * 10;
        dprint(LINE_CPU + 5, col, qpi_speed, 1, 0);
        col += 1;
        cprint(LINE_CPU + 5, col + 1, "GT/s");
        col += 5;
    }

    /* Get the clock ratio */

    pci_conf_read(nhm_bus, 3, 4, 0x54, 2, &mc_dimm_clk_ratio);
    dramratio = (mc_dimm_clk_ratio & 0x1F);

    // Compute RAM Frequency
    fsb = ((extclock / 1000) / coef);
    dramclock = fsb * dramratio / 2;

    // Print DRAM Freq
    print_fsb_info(dramclock, "RAM : ", "DDR3-");

}
#endif

/* ------------------ Here the code for Timings detection ------------------ */
/* ------------------------------------------------------------------------- */
#if 0 // for detecting RAM timings. Not used
static void poll_timings_nf4ie(void) {


    ulong regd0, reg8c, reg9c, reg80;
    int cas, rcd, rp, ras;

    cprint(LINE_CPU + 5, col + 1, "- Type : DDR-II");

    //Now, read Registers
    pci_conf_read(0, 1, 1, 0xD0, 4, &regd0);
    pci_conf_read(0, 1, 1, 0x80, 1, &reg80);
    pci_conf_read(0, 1, 0, 0x8C, 4, &reg8c);
    pci_conf_read(0, 1, 0, 0x9C, 4, &reg9c);

    // Then, detect timings
    cas = (regd0 >> 4) & 0x7;
    rcd = (reg8c >> 24) & 0xF;
    rp = (reg9c >> 8) & 0xF;
    ras = (reg8c >> 16) & 0x3F;

    print_timings_info(cas, rcd, rp, ras);

    if (reg80 & 0x3) {
        cprint(LINE_CPU + 6, col2, "/ Dual Channel (128 bits)");
    }
    else {
        cprint(LINE_CPU + 6, col2, "/ Single Channel (64 bits)");
    }

}

static void poll_timings_i875(void) {

    ulong dev6, dev62;
    ulong temp;
    float cas;
    int rcd, rp, ras;
    long *ptr, *ptr2;

    /* Read the MMR Base Address & Define the pointer */
    pci_conf_read(0, 6, 0, 0x10, 4, &dev6);

    /* Now, the PAT ritual ! (Kant and Luciano will love this) */
    pci_conf_read(0, 6, 0, 0x40, 4, &dev62);
    ptr2 = (long*)(dev6 + 0x68);

    if ((dev62 & 0x3) == 0 && ((*ptr2 >> 14) & 1) == 1) {
        cprint(LINE_CPU + 5, col + 1, "- PAT : Enabled");
    }
    else {
        cprint(LINE_CPU + 5, col + 1, "- PAT : Disabled");
    }

    /* Now, we could check some additionnals timings infos) */

    ptr = (long*)(dev6 + 0x60);
    // CAS Latency (tCAS)
    temp = ((*ptr >> 5) & 0x3);
    if (temp == 0x0) { cas = 2.5; }
    else if (temp == 0x1) { cas = 2; }
    else { cas = 3; }

    // RAS-To-CAS (tRCD)
    temp = ((*ptr >> 2) & 0x3);
    if (temp == 0x0) { rcd = 4; }
    else if (temp == 0x1) { rcd = 3; }
    else { rcd = 2; }

    // RAS Precharge (tRP)
    temp = (*ptr & 0x3);
    if (temp == 0x0) { rp = 4; }
    else if (temp == 0x1) { rp = 3; }
    else { rp = 2; }

    // RAS Active to precharge (tRAS)
    temp = ((*ptr >> 7) & 0x7);
    ras = 10 - temp;

    // Print timings
    print_timings_info(cas, rcd, rp, ras);

    // Print 64 or 128 bits mode
    if (((*ptr2 >> 21) & 3) > 0) {
        cprint(LINE_CPU + 6, col2, "/ Dual Channel (128 bits)");
    }
    else {
        cprint(LINE_CPU + 6, col2, "/ Single Channel (64 bits)");
    }
}

static void poll_timings_i925(void) {

    // Thanks for CDH optis
    ulong dev0, drt, drc, dcc, idetect, temp;
    long *ptr;

    //Now, read MMR Base Address
    pci_conf_read(0, 0, 0, 0x44, 4, &dev0);
    pci_conf_read(0, 0, 0, 0x02, 2, &idetect);
    dev0 &= 0xFFFFC000;

    //Set pointer for DRT
    ptr = (long*)(dev0 + 0x114);
    drt = *ptr & 0xFFFFFFFF;

    //Set pointer for DRC
    ptr = (long*)(dev0 + 0x120);
    drc = *ptr & 0xFFFFFFFF;

    //Set pointer for DCC
    ptr = (long*)(dev0 + 0x200);
    dcc = *ptr & 0xFFFFFFFF;

    //Determine DDR or DDR-II
    if ((drc & 3) == 2) {
        cprint(LINE_CPU + 5, col + 1, "- Type : DDR-II");
    }
    else {
        cprint(LINE_CPU + 5, col + 1, "- Type : DDR-I");
    }

    // Now, detect timings
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((drt >> 8) & 0x3);

    if ((drc & 3) == 2) {
        // Timings DDR-II
        if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "5-"); }
        else if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "4-"); }
        else if (temp == 0x2) { cprint(LINE_CPU + 6, col2, "3-"); }
        else { cprint(LINE_CPU + 6, col2, "6-"); }
    }
    else {
        // Timings DDR-I
        if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "3-"); }
        else if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "2.5-"); col2 += 2; }
        else { cprint(LINE_CPU + 6, col2, "2-"); }
    }
    col2 += 2;

    // RAS-To-CAS (tRCD)
    dprint(LINE_CPU + 6, col2, ((drt >> 4) & 0x3) + 2, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    col2 += 2;

    // RAS Precharge (tRP)
    dprint(LINE_CPU + 6, col2, (drt & 0x3) + 2, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    col2 += 2;

    // RAS Active to precharge (tRAS)
    // If Lakeport, than change tRAS computation (Thanks to CDH, again)
    if (idetect > 0x2700)
        temp = ((drt >> 19) & 0x1F);
    else
        temp = ((drt >> 20) & 0x0F);

    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    (temp < 10) ? (col2 += 1) : (col2 += 2);

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    temp = (dcc & 0x3);
    if (temp == 1) { cprint(LINE_CPU + 6, col2, " Dual Channel (Asymmetric)"); }
    else if (temp == 2) { cprint(LINE_CPU + 6, col2, " Dual Channel (Interleaved)"); }
    else { cprint(LINE_CPU + 6, col2, " Single Channel (64 bits)"); }

}

static void poll_timings_i965(void) {

    // Thanks for CDH optis
    ulong dev0, temp, c0ckectrl, c1ckectrl, offset;
    ulong ODT_Control_Register, Precharge_Register, ACT_Register, Read_Register, Misc_Register;
    long *ptr;

    //Now, read MMR Base Address
    pci_conf_read(0, 0, 0, 0x48, 4, &dev0);
    dev0 &= 0xFFFFC000;

    ptr = (long*)(dev0 + 0x260);
    c0ckectrl = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + 0x660);
    c1ckectrl = *ptr & 0xFFFFFFFF;

    // If DIMM 0 not populated, check DIMM 1
    ((c0ckectrl) >> 20 & 0xF) ? (offset = 0) : (offset = 0x400);

    ptr = (long*)(dev0 + offset + 0x29C);
    ODT_Control_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x250);
    Precharge_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x252);
    ACT_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x258);
    Read_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x244);
    Misc_Register = *ptr & 0xFFFFFFFF;

    //Intel 965 Series only support DDR2
    cprint(LINE_CPU + 5, col + 1, "- Type : DDR-II");

    // Now, detect timings
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((ODT_Control_Register >> 17) & 7) + 3.0f;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS-To-CAS (tRCD)
    temp = (Read_Register >> 16) & 0xF;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS Precharge (tRP)
    temp = (ACT_Register >> 13) & 0xF;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS Active to precharge (tRAS)
    temp = (Precharge_Register >> 11) & 0x1F;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    (temp < 10) ? (col2 += 1) : (col2 += 2);

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    if ((c0ckectrl >> 20 & 0xF) && (c1ckectrl >> 20 & 0xF)) {
        cprint(LINE_CPU + 6, col2 + 1, "Dual Channel");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "Single Channel");
    }

}

static void poll_timings_im965(void) {

    // Thanks for CDH optis
    ulong dev0, temp, c0ckectrl, c1ckectrl, offset;
    ulong ODT_Control_Register, Precharge_Register;
    long *ptr;

    //Now, read MMR Base Address
    pci_conf_read(0, 0, 0, 0x48, 4, &dev0);
    dev0 &= 0xFFFFC000;

    ptr = (long*)(dev0 + 0x1200);
    c0ckectrl = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + 0x1300);
    c1ckectrl = *ptr & 0xFFFFFFFF;

    // If DIMM 0 not populated, check DIMM 1
    ((c0ckectrl) >> 20 & 0xF) ? (offset = 0) : (offset = 0x100);

    ptr = (long*)(dev0 + offset + 0x121C);
    ODT_Control_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x1214);
    Precharge_Register = *ptr & 0xFFFFFFFF;

    //Intel 965 Series only support DDR2
    cprint(LINE_CPU + 5, col + 1, "- Type : DDR-II");

    // Now, detect timings
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((ODT_Control_Register >> 23) & 7) + 3.0f;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS-To-CAS (tRCD)
    temp = ((Precharge_Register >> 5) & 7) + 2.0f;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS Precharge (tRP)
    temp = (Precharge_Register & 7) + 2.0f;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    (temp < 10) ? (col2 += 2) : (col2 += 3);

    // RAS Active to precharge (tRAS)
    temp = (Precharge_Register >> 21) & 0x1F;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    (temp < 10) ? (col2 += 1) : (col2 += 2);

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    if ((c0ckectrl >> 20 & 0xF) && (c1ckectrl >> 20 & 0xF)) {
        cprint(LINE_CPU + 6, col2 + 1, "Dual Channel");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "Single Channel");
    }

}

static void poll_timings_p35(void) {

    // Thanks for CDH optis
    float cas;
    int rcd, rp, ras;
    ulong dev0, Device_ID, Memory_Check, c0ckectrl, c1ckectrl, offset;
    ulong ODT_Control_Register, Precharge_Register, ACT_Register, Read_Register, Misc_Register;
    long *ptr;

    pci_conf_read(0, 0, 0, 0x02, 2, &Device_ID);
    Device_ID &= 0xFFFF;

    //Now, read MMR Base Address
    pci_conf_read(0, 0, 0, 0x48, 4, &dev0);
    dev0 &= 0xFFFFC000;

    ptr = (long*)(dev0 + 0x260);
    c0ckectrl = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + 0x660);
    c1ckectrl = *ptr & 0xFFFFFFFF;

    // If DIMM 0 not populated, check DIMM 1
    ((c0ckectrl) >> 20 & 0xF) ? (offset = 0) : (offset = 0x400);

    ptr = (long*)(dev0 + offset + 0x265);
    ODT_Control_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x25D);
    Precharge_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x252);
    ACT_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x258);
    Read_Register = *ptr & 0xFFFFFFFF;

    ptr = (long*)(dev0 + offset + 0x244);
    Misc_Register = *ptr & 0xFFFFFFFF;

    // On P45, check 1A8
    if (Device_ID > 0x2E00) {
        ptr = (long*)(dev0 + offset + 0x1A8);
        Memory_Check = *ptr & 0xFFFFFFFF;
        Memory_Check >>= 2;
        Memory_Check &= 1;
        Memory_Check = !Memory_Check;
    }
    else {
        ptr = (long*)(dev0 + offset + 0x1E8);
        Memory_Check = *ptr & 0xFFFFFFFF;
    }

    //Determine DDR-II or DDR-III
    if (Memory_Check & 1) {
        cprint(LINE_CPU + 5, col + 1, "- Type : DDR2");
    }
    else {
        cprint(LINE_CPU + 5, col + 1, "- Type : DDR3");
    }

    // CAS Latency (tCAS)
    if (Device_ID > 0x2E00) {
        cas = ((ODT_Control_Register >> 8) & 0x3F) - 6.0f;
    }
    else {
        cas = ((ODT_Control_Register >> 8) & 0x3F) - 9.0f;
    }

    // RAS-To-CAS (tRCD)
    rcd = (Read_Register >> 17) & 0xF;

    // RAS Precharge (tRP)
    rp = (ACT_Register >> 13) & 0xF;

    // RAS Active to precharge (tRAS)
    ras = Precharge_Register & 0x3F;

    print_timings_info(cas, rcd, rp, ras);

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    if ((c0ckectrl >> 20 & 0xF) && (c1ckectrl >> 20 & 0xF)) {
        cprint(LINE_CPU + 6, col2 + 1, "Dual Channel");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "Single Channel");
    }

}

static void poll_timings_5400(void) {

    // Thanks for CDH optis
    ulong ambase, mtr1, mtr2, offset, mca, temp;
    long *ptr;

    //Hard-coded Ambase value (should not be realocated by software when using Memtest86+
    ambase = 0xFE000000;
    offset = mtr1 = mtr2 = 0;

    // Will loop until a valid populated channel is found
    // Bug  : DIMM 0 must be populated or it will fall in an endless loop  
    while (((mtr2 & 0xF) < 3) || ((mtr2 & 0xF) > 6)) {
        ptr = (long*)(ambase + 0x378 + offset);
        mtr1 = *ptr & 0xFFFFFFFF;

        ptr = (long*)(ambase + 0x37C + offset);
        mtr2 = *ptr & 0xFFFFFFFF;
        offset += 0x8000;
    }

    pci_conf_read(0, 16, 1, 0x58, 4, &mca);

    //This chipset only supports FB-DIMM (Removed => too long)
    //cprint(LINE_CPU+5, col +1, "- Type : FBD");

    // Now, detect timings
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = mtr2 & 0xF;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    col2 += 2;

    // RAS-To-CAS (tRCD)
    temp = 6 - ((mtr1 >> 10) & 3);
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    col2 += 2;

    // RAS Precharge (tRP)
    temp = 6 - ((mtr1 >> 8) & 3);
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-");
    col2 += 2;

    // RAS Active to precharge (tRAS)
    temp = 16 - (3 * ((mtr1 >> 29) & 3)) + ((mtr1 >> 12) & 3);
    if (((mtr1 >> 12) & 3) == 3 && ((mtr1 >> 29) & 3) == 2) { temp = 9; }

    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    (temp < 10) ? (col2 += 1) : (col2 += 2);

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    if ((mca >> 14) & 1) {
        cprint(LINE_CPU + 6, col2 + 1, "Single Channel");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "Dual Channel");
    }

}

static void poll_timings_E7520(void) {

    ulong drt, ddrcsr;
    float cas;
    int rcd, rp, ras;

    pci_conf_read(0, 0, 0, 0x78, 4, &drt);
    pci_conf_read(0, 0, 0, 0x9A, 2, &ddrcsr);

    cas = ((drt >> 2) & 3) + 2;
    rcd = ((drt >> 10) & 1) + 3;
    rp = ((drt >> 9) & 1) + 3;
    ras = ((drt >> 14) & 3) + 11;

    print_timings_info(cas, rcd, rp, ras);

    if ((ddrcsr & 0xF) >= 0xC) {
        cprint(LINE_CPU + 6, col2, "/ Dual Channel (128 bits)");
    }
    else {
        cprint(LINE_CPU + 6, col2, "/ Single Channel (64 bits)");
    }
}


static void poll_timings_i855(void) {

    ulong drt, temp;

    pci_conf_read(0, 0, 0, 0x78, 4, &drt);

    /* Now, we could print some additionnals timings infos) */
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((drt >> 4) & 0x1);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "2.5-"); col2 += 4; }
    else { cprint(LINE_CPU + 6, col2, "2-"); col2 += 2; }

    // RAS-To-CAS (tRCD)
    temp = ((drt >> 2) & 0x1);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "3-"); }
    else { cprint(LINE_CPU + 6, col2, "2-"); }
    col2 += 2;

    // RAS Precharge (tRP)
    temp = (drt & 0x1);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "3-"); }
    else { cprint(LINE_CPU + 6, col2, "2-"); }
    col2 += 2;

    // RAS Active to precharge (tRAS)
    temp = 7 - ((drt >> 9) & 0x3);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "7"); }
    if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "6"); }
    if (temp == 0x2) { cprint(LINE_CPU + 6, col2, "5"); }
    col2 += 1;

}

static void poll_timings_E750x(void) {

    ulong drt, drc, temp;
    float cas;
    int rcd, rp, ras;

    pci_conf_read(0, 0, 0, 0x78, 4, &drt);
    pci_conf_read(0, 0, 0, 0x7C, 4, &drc);

    if ((drt >> 4) & 1) { cas = 2; }
    else { cas = 2.5; };
    if ((drt >> 1) & 1) { rcd = 2; }
    else { rcd = 3; };
    if (drt & 1) { rp = 2; }
    else { rp = 3; };

    temp = ((drt >> 9) & 3);
    if (temp == 2) { ras = 5; }
    else if (temp == 1) { ras = 6; }
    else { ras = 7; }

    print_timings_info(cas, rcd, rp, ras);

    if (((drc >> 22) & 1) == 1) {
        cprint(LINE_CPU + 6, col2, "/ Dual Channel (128 bits)");
    }
    else {
        cprint(LINE_CPU + 6, col2, "/ Single Channel (64 bits)");
    }

}

static void poll_timings_i852(void) {

    ulong drt, temp;

    pci_conf_read(0, 0, 1, 0x60, 4, &drt);

    /* Now, we could print some additionnals timings infos) */
    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((drt >> 5) & 0x1);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "2.5-"); col2 += 4; }
    else { cprint(LINE_CPU + 6, col2, "2-"); col2 += 2; }

    // RAS-To-CAS (tRCD)
    temp = ((drt >> 2) & 0x3);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "4-"); }
    if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "3-"); }
    else { cprint(LINE_CPU + 6, col2, "2-"); }
    col2 += 2;

    // RAS Precharge (tRP)
    temp = (drt & 0x3);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "4-"); }
    if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "3-"); }
    else { cprint(LINE_CPU + 6, col2, "2-"); }
    col2 += 2;

    // RAS Active to precharge (tRAS)
    temp = ((drt >> 9) & 0x3);
    if (temp == 0x0) { cprint(LINE_CPU + 6, col2, "8"); col2 += 7; }
    if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "7"); col2 += 6; }
    if (temp == 0x2) { cprint(LINE_CPU + 6, col2, "6"); col2 += 5; }
    if (temp == 0x3) { cprint(LINE_CPU + 6, col2, "5"); col2 += 5; }
    col2 += 1;

}

static void poll_timings_amd64(void) {

    ulong dramtlr, dramclr;
    int temp;
    int trcd, trp, tras;

    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    pci_conf_read(0, 24, 2, 0x88, 4, &dramtlr);
    pci_conf_read(0, 24, 2, 0x90, 4, &dramclr);

    if (((cpu_id.max_xcpuid /*cpu_id.ext */ >> 16) & 0xF) >= 4) {
        /* NEW K8 0Fh Family 90 nm (DDR2) */

            // CAS Latency (tCAS)
        temp = (dramtlr & 0x7) + 1;
        dprint(LINE_CPU + 6, col2, temp, 1, 0);
        cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

        // RAS-To-CAS (tRCD)
        trcd = ((dramtlr >> 4) & 0x3) + 3;
        dprint(LINE_CPU + 6, col2, trcd, 1, 0);
        cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

        // RAS Precharge (tRP)
        trp = ((dramtlr >> 8) & 0x3) + 3;
        dprint(LINE_CPU + 6, col2, trp, 1, 0);
        cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

        // RAS Active to precharge (tRAS)
        tras = ((dramtlr >> 12) & 0xF) + 3;
        if (tras < 10) {
            dprint(LINE_CPU + 6, col2, tras, 1, 0); col2 += 1;
        }
        else {
            dprint(LINE_CPU + 6, col2, tras, 2, 0); col2 += 2;
        }
        cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

        // Print 64 or 128 bits mode

        if ((dramclr >> 11) & 1) {
            cprint(LINE_CPU + 6, col2, " DDR-2 (128 bits)");
            col2 += 17;
        }
        else {
            cprint(LINE_CPU + 6, col2, " DDR-2 (64 bits)");
            col2 += 16;
        }

    }
    else {
        /* OLD K8 (DDR1) */

            // CAS Latency (tCAS)
        temp = (dramtlr & 0x7);
        if (temp == 0x1) { cprint(LINE_CPU + 6, col2, "2-"); col2 += 2; }
        if (temp == 0x2) { cprint(LINE_CPU + 6, col2, "3-"); col2 += 2; }
        if (temp == 0x5) { cprint(LINE_CPU + 6, col2, "2.5-"); col2 += 4; }

        // RAS-To-CAS (tRCD)
        trcd = ((dramtlr >> 12) & 0x7);
        dprint(LINE_CPU + 6, col2, trcd, 1, 0);
        cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

        // RAS Precharge (tRP)
        trp = ((dramtlr >> 24) & 0x7);
        dprint(LINE_CPU + 6, col2, trp, 1, 0);
        cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

        // RAS Active to precharge (tRAS)
        tras = ((dramtlr >> 20) & 0xF);
        if (tras < 10) {
            dprint(LINE_CPU + 6, col2, tras, 1, 0); col2 += 1;
        }
        else {
            dprint(LINE_CPU + 6, col2, tras, 2, 0); col2 += 2;
        }
        cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

        // Print 64 or 128 bits mode

        if (((dramclr >> 16) & 1) == 1) {
            cprint(LINE_CPU + 6, col2, " DDR-1 (128 bits)");
            col2 += 17;
        }
        else {
            cprint(LINE_CPU + 6, col2, " DDR-1 (64 bits)");
            col2 += 16;
        }
    }
}

static void poll_timings_k10(void) {

    ulong dramtlr, dramclr, dramchr;
    int temp;
    int trcd, trp, tras;

    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    pci_conf_read(0, 24, 2, 0x88, 4, &dramtlr);
    pci_conf_read(0, 24, 2, 0x110, 4, &dramclr);
    pci_conf_read(0, 24, 2, 0x94, 4, &dramchr);

    // CAS Latency (tCAS)
    temp = (dramtlr & 0x7) + 1;
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

    // RAS-To-CAS (tRCD)
    trcd = ((dramtlr >> 4) & 0x3) + 3;
    dprint(LINE_CPU + 6, col2, trcd, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

    // RAS Precharge (tRP)
    trp = ((dramtlr >> 8) & 0x3) + 3;
    dprint(LINE_CPU + 6, col2, trp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

    // RAS Active to precharge (tRAS)
    tras = ((dramtlr >> 12) & 0xF) + 3;
    dprint(LINE_CPU + 6, col2, tras, 1, 0);
    (tras < 10) ? (col2 += 1) : (col2 += 2);
    cprint(LINE_CPU + 6, col2, "-");
    col2 += 1;

    // Row Cycle Time (tRC)
    trp = ((dramtlr >> 16) & 0x1F) + 11;
    dprint(LINE_CPU + 6, col2, trp, 1, 0);
    col2 += 2;

    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    //Print DDR2 or DDR3
    if ((dramchr >> 8) & 1) {
        cprint(LINE_CPU + 6, col2 + 1, "DDR-3");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "DDR-2");
    }
    col2 += 6;

    // Print 64 or 128 bits mode
    if ((dramclr >> 4) & 1) {
        cprint(LINE_CPU + 6, col2 + 1, "(Dual)");
    }
    else {
        cprint(LINE_CPU + 6, col2 + 1, "(Single)");
    }

}

static void poll_timings_EP80579(void) {

    ulong drt1, drt2;
    float cas;
    int rcd, rp, ras;

    pci_conf_read(0, 0, 0, 0x78, 4, &drt1);
    pci_conf_read(0, 0, 0, 0x64, 4, &drt2);

    cas = ((drt1 >> 3) & 0x7) + 3;
    rcd = ((drt1 >> 9) & 0x7) + 3;
    rp = ((drt1 >> 6) & 0x7) + 3;
    ras = ((drt2 >> 28) & 0xF) + 8;

    print_timings_info(cas, rcd, rp, ras);
}

static void poll_timings_nf2(void) {

    ulong dramtlr, dramtlr2, dramtlr3, temp;
    ulong dimm1p, dimm2p, dimm3p;

    pci_conf_read(0, 0, 1, 0x90, 4, &dramtlr);
    pci_conf_read(0, 0, 1, 0xA0, 4, &dramtlr2);
    pci_conf_read(0, 0, 1, 0x84, 4, &dramtlr3);
    pci_conf_read(0, 0, 2, 0x40, 4, &dimm1p);
    pci_conf_read(0, 0, 2, 0x44, 4, &dimm2p);
    pci_conf_read(0, 0, 2, 0x48, 4, &dimm3p);

    cprint(LINE_CPU + 6, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((dramtlr2 >> 4) & 0x7);
    if (temp == 0x2) { cprint(LINE_CPU + 6, col2, "2-"); col2 += 2; }
    if (temp == 0x3) { cprint(LINE_CPU + 6, col2, "3-"); col2 += 2; }
    if (temp == 0x6) { cprint(LINE_CPU + 6, col2, "2.5-"); col2 += 4; }

    // RAS-To-CAS (tRCD)
    temp = ((dramtlr >> 20) & 0xF);
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

    // RAS Precharge (tRP)
    temp = ((dramtlr >> 28) & 0xF);
    dprint(LINE_CPU + 6, col2, temp, 1, 0);
    cprint(LINE_CPU + 6, col2 + 1, "-"); col2 += 2;

    // RAS Active to precharge (tRAS)
    temp = ((dramtlr >> 15) & 0xF);
    if (temp < 10) {
        dprint(LINE_CPU + 6, col2, temp, 1, 0); col2 += 1;
    }
    else {
        dprint(LINE_CPU + 6, col2, temp, 2, 0); col2 += 2;
    }
    cprint(LINE_CPU + 6, col2 + 1, "/"); col2 += 2;

    // Print 64 or 128 bits mode
    // If DIMM1 & DIMM3 or DIMM1 & DIMM2 populated, than Dual Channel.

    if ((dimm3p & 1) + (dimm2p & 1) == 2 || (dimm3p & 1) + (dimm1p & 1) == 2) {
        cprint(LINE_CPU + 6, col2, " Dual Channel (128 bits)");
        col2 += 24;
    }
    else {
        cprint(LINE_CPU + 6, col2, " Single Channel (64 bits)");
        col2 += 15;
    }

}

static void poll_timings_us15w(void) {

    // Thanks for CDH optis
    ulong dtr, temp;

    /* Find dramratio */
    /* D0 MsgRd, 01 Dunit, 01 DTR */
    pci_conf_write(0, 0, 0, 0xD0, 4, 0xD0010100);
    pci_conf_read(0, 0, 0, 0xD4, 4, &dtr);

    // Now, detect timings
    cprint(LINE_CPU + 5, col2 + 1, "/ CAS : ");
    col2 += 9;

    // CAS Latency (tCAS)
    temp = ((dtr >> 4) & 0x3) + 3;
    dprint(LINE_CPU + 5, col2, temp, 1, 0);
    cprint(LINE_CPU + 5, col2 + 1, "-");
    col2 += 2;

    // RAS-To-CAS (tRCD)
    temp = ((dtr >> 2) & 0x3) + 3;
    dprint(LINE_CPU + 5, col2, temp, 1, 0);
    cprint(LINE_CPU + 5, col2 + 1, "-");
    col2 += 2;

    // RAS Precharge (tRP)
    temp = ((dtr >> 0) & 0x3) + 3;
    dprint(LINE_CPU + 5, col2, temp, 1, 0);
    col2 += 1;

}

static void poll_timings_nhm(void) {

    ulong mc_channel_bank_timing, mc_control, mc_channel_mrs_value;
    float cas;
    int rcd, rp, ras;
    int fvc_bn = 4;

    /* Find which channels are populated */
    pci_conf_read(nhm_bus, 3, 0, 0x48, 2, &mc_control);
    mc_control = (mc_control >> 8) & 0x7;

    /* Get the first valid channel */
    if (mc_control & 1) {
        fvc_bn = 4;
    }
    else if (mc_control & 2) {
        fvc_bn = 5;
    }
    else if (mc_control & 7) {
        fvc_bn = 6;
    }

    // Now, detect timings
    // CAS Latency (tCAS) / RAS-To-CAS (tRCD) / RAS Precharge (tRP) / RAS Active to precharge (tRAS)
    pci_conf_read(nhm_bus, fvc_bn, 0, 0x88, 4, &mc_channel_bank_timing);
    pci_conf_read(nhm_bus, fvc_bn, 0, 0x70, 4, &mc_channel_mrs_value);
    cas = ((mc_channel_mrs_value >> 4) & 0xF) + 4.0f;
    rcd = (mc_channel_bank_timing >> 9) & 0xF;
    ras = (mc_channel_bank_timing >> 4) & 0x1F;
    rp = mc_channel_bank_timing & 0xF;

    print_timings_info(cas, rcd, rp, ras);

    // Print 1, 2 or 3 Channels
    if (mc_control == 1 || mc_control == 2 || mc_control == 4) {
        cprint(LINE_CPU + 6, col2, "/ Single Channel");
        col2 += 16;
    }
    else if (mc_control == 7) {
        cprint(LINE_CPU + 6, col2, "/ Triple Channel");
        col2 += 16;
    }
    else {
        cprint(LINE_CPU + 6, col2, "/ Dual Channel");
        col2 += 14;
    }

}

#endif

/* ------------------ Let's continue ------------------ */
/* ---------------------------------------------------- */

// Database of supported controller
struct pci_memory_controller controllers[] = {
    /* Default unknown chipset */
    {0, 0, 0, 0, 0, "(Unknown)", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},

    /* AMD */
    {0, 0, 0, 0x1022, 0x7006, "AMD 751", 0, poll_fsb_nothing, NULL, setup_amd751, poll_amd751},
    {0, 0, 0, 0x1022, 0x700c, "AMD 762", 0, poll_fsb_nothing, NULL, setup_amd76x, poll_amd76x},
    {0, 0, 0, 0x1022, 0x700e, "AMD 761", 0, poll_fsb_nothing, NULL, setup_amd76x, poll_amd76x},

    /* SiS */
    {0, 0, 0, 0x1039, 0x0600, "SiS 600", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0620, "SiS 620", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x5600, "SiS 5600", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0645, "SiS 645", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0646, "SiS 645DX", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0630, "SiS 630", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0650, "SiS 650", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0651, "SiS 651", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0730, "SiS 730", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0735, "SiS 735", 0, poll_fsb_nothing /* poll_fsb_amd32 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0740, "SiS 740", 0, poll_fsb_nothing /* poll_fsb_amd32 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0745, "SiS 745", 0, poll_fsb_nothing /* poll_fsb_amd32 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0748, "SiS 748", 0, poll_fsb_nothing /* poll_fsb_amd32 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0655, "SiS 655", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0656, "SiS 656", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0648, "SiS 648", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0649, "SiS 649", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0661, "SiS 661", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0671, "SiS 671", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1039, 0x0672, "SiS 672", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},

    /* ALi */
    {0, 0, 0, 0x10b9, 0x1531, "ALi Aladdin 4", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x10b9, 0x1541, "ALi Aladdin 5", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x10b9, 0x1644, "ALi Aladdin M1644", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},

    /* ATi */
    {0, 0, 0, 0x1002, 0x5830, "ATi Radeon 9100 IGP", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1002, 0x5831, "ATi Radeon 9100 IGP", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1002, 0x5832, "ATi Radeon 9100 IGP", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1002, 0x5833, "ATi Radeon 9100 IGP", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1002, 0x5954, "ATi Radeon Xpress 200", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1002, 0x5A41, "ATi Radeon Xpress 200", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},

    /* nVidia */
    {0, 0, 0, 0x10de, 0x01A4, "nVidia nForce", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x10de, 0x01E0, "nVidia nForce2 SPP", 0, poll_fsb_nothing /* poll_fsb_nf2 */, NULL /* poll_timings_nf2 */, setup_nothing, poll_nothing},
    {0, 0, 0, 0x10de, 0x0071, "nForce4 SLI Intel Edition", 0, poll_fsb_nothing /* poll_fsb_nf4ie */, NULL /* poll_timings_nf4ie */, setup_nothing, poll_nothing},

    /* VIA */
    {0, 0, 0, 0x1106, 0x0305, "VIA KT133/KT133A", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0391, "VIA KX133", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0501, "VIA MVP4", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0585, "VIA VP/VPX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0595, "VIA VP2", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0597, "VIA VP3", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0598, "VIA MVP3", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0691, "VIA Apollo Pro/133/133A", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0693, "VIA Apollo Pro+", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0601, "VIA PLE133", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3099, "VIA KT266(A)/KT333", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3189, "VIA KT400(A)/600", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0269, "VIA KT880", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3205, "VIA KM400", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3116, "VIA KM266", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3156, "VIA KN266", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3123, "VIA CLE266", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x0198, "VIA PT800", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x1106, 0x3258, "VIA PT880", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},

    /* Serverworks */
    {0, 0, 0, 0x1166, 0x0008, "CNB20HE", 0, poll_fsb_nothing, NULL, setup_cnb20, poll_nothing},
    {0, 0, 0, 0x1166, 0x0009, "CNB20LE", 0, poll_fsb_nothing, NULL, setup_cnb20, poll_nothing},

    /* Intel */
    {0, 0, 0, 0x8086, 0x1130, "Intel i815", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x122d, "Intel i430FX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x1235, "Intel i430MX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x1237, "Intel i440FX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x1250, "Intel i430HX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x1A21, "Intel i840", 0, poll_fsb_nothing, NULL, setup_i840, poll_i840},
    {0, 0, 0, 0x8086, 0x1A30, "Intel i845", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_i845, poll_i845},
    {0, 0, 0, 0x8086, 0x2560, "Intel i845E/G/PE/GE", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_i845, poll_i845},
    {0, 0, 0, 0x8086, 0x2500, "Intel i820", 0, poll_fsb_nothing, NULL, setup_i820, poll_i820},
    {0, 0, 0, 0x8086, 0x2530, "Intel i850", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_i850, poll_i850},
    {0, 0, 0, 0x8086, 0x2531, "Intel i860", 1, poll_fsb_nothing, NULL, setup_i860, poll_i860},
    {0, 0, 0, 0x8086, 0x7030, "Intel i430VX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7100, "Intel i430TX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7120, "Intel i810", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7122, "Intel i810", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7124, "Intel i810E", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7180, "Intel i440[LE]X", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x7190, "Intel i440BX", 0, poll_fsb_nothing, NULL, setup_i440gx, poll_i440gx},
    {0, 0, 0, 0x8086, 0x7192, "Intel i440BX", 0, poll_fsb_nothing, NULL, setup_i440gx, poll_i440gx},
    {0, 0, 0, 0x8086, 0x71A0, "Intel i440GX", 0, poll_fsb_nothing, NULL, setup_i440gx, poll_i440gx},
    {0, 0, 0, 0x8086, 0x71A2, "Intel i440GX", 0, poll_fsb_nothing, NULL, setup_i440gx, poll_i440gx},
    {0, 0, 0, 0x8086, 0x84C5, "Intel i450GX", 0, poll_fsb_nothing, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x2540, "Intel E7500", 1, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E750x */, setup_iE7xxx, poll_iE7xxx},
    {0, 0, 0, 0x8086, 0x254C, "Intel E7501", 1, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E750x */, setup_iE7xxx, poll_iE7xxx},
    {0, 0, 0, 0x8086, 0x255d, "Intel E7205", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_iE7xxx, poll_iE7xxx},
    {0, 0, 0, 0x8086, 0x3592, "Intel E7320", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E7520 */, setup_iE7520, poll_iE7520},
    {0, 0, 0, 0x8086, 0x2588, "Intel E7221", 1, poll_fsb_nothing /* poll_fsb_i925 */, NULL /* poll_timings_i925 */, setup_i925, poll_iE7221},
    {0, 0, 0, 0x8086, 0x3590, "Intel E7520", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E7520 */, setup_iE7520, poll_iE7520},
    {0, 0, 0, 0x8086, 0x359E, "Intel E7525", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E7520 */, setup_iE7520, poll_iE7520},
    {0, 0, 0, 0x8086, 0x35B0, "Intel 3100", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_E7520 */, setup_iE7520, poll_iE7520},
    {0, 0, 0, 0x8086, 0x2600, "Intel E8500", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x2570, "Intel i848/i865", 0, poll_fsb_nothing /* poll_fsb_i875*/, NULL /* poll_timings_i875 */, setup_i875, poll_nothing},
    {0, 0, 0, 0x8086, 0x2578, "Intel i875P", 0, poll_fsb_nothing /* poll_fsb_i875*/, NULL /* poll_timings_i875 */, setup_i875, poll_i875},
    {0, 0, 0, 0x8086, 0x2550, "Intel E7505", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL, setup_iE7xxx, poll_iE7xxx},
    {0, 0, 0, 0x8086, 0x3580, "Intel ", 0, poll_fsb_nothing /* poll_fsb_i855 */, NULL /* poll_timings_i852 */, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x3340, "Intel i855PM", 0, poll_fsb_nothing /* poll_fsb_i855 */, NULL /* poll_timings_i855 */, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x2580, "Intel i915P/G", 0, poll_fsb_nothing /* poll_fsb_i925 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x2590, "Intel i915PM/GM", 0, poll_fsb_nothing /* poll_fsb_i925 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x2584, "Intel i925X/XE", 0, poll_fsb_nothing /* poll_fsb_i925 */, NULL /* poll_timings_i925 */, setup_i925, poll_iE7221},
    {0, 0, 0, 0x8086, 0x2770, "Intel i945P/G", 0, poll_fsb_nothing /* poll_fsb_i945 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x27A0, "Intel i945GM/PM", 0, poll_fsb_nothing /* poll_fsb_i945 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x27AC, "Intel i945GME", 0, poll_fsb_nothing /* poll_fsb_i945 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x2774, "Intel i955X", 0, poll_fsb_nothing /* poll_fsb_i945 */, NULL /* poll_timings_i925 */, setup_i925, poll_nothing},
    {0, 0, 0, 0x8086, 0x2778, "Intel i3000", 0, poll_fsb_nothing /* poll_fsb_i945 */, NULL /* poll_timings_i925 */, setup_i3000, poll_i3000},
    {0, 0, 0, 0x8086, 0x277C, "Intel i975X", 0, poll_fsb_nothing /* poll_fsb_i975 */, NULL /* poll_timings_i925 */, setup_i925, poll_i925},
    {0, 0, 0, 0x8086, 0x2970, "Intel i946PL/GZ", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_i965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2990, "Intel Q963/Q965", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_i965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x29A0, "Intel P965/G965", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_i965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2A00, "Intel GM965/GL960", 0, poll_fsb_nothing /* poll_fsb_im965 */, NULL /* poll_timings_im965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2A10, "Intel GME965/GLE960", 0, poll_fsb_nothing /* poll_fsb_im965 */, NULL /* poll_timings_im965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2A40, "Intel PM/GM45/47", 0, poll_fsb_nothing /* poll_fsb_im965 */, NULL /* poll_timings_im965 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x29B0, "Intel Q35", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x29C0, "Intel P35/G33", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x29D0, "Intel Q33", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x29E0, "Intel X38/X48", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_x38, poll_x38},
    {0, 0, 0, 0x8086, 0x29F0, "Intel 3200/3210", 0, poll_fsb_nothing /* poll_fsb_i965 */, poll_fsb_nothing /* poll_timings_p35 */, setup_i3200, poll_i3200},

    {0, 0, 0, 0x8086, 0x2E10, "Intel Q45/Q43", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2E20, "Intel P45/G45", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x2E30, "Intel G41", 0, poll_fsb_nothing /* poll_fsb_i965 */, NULL /* poll_timings_p35 */, setup_p35, poll_nothing},
    {0, 0, 0, 0x8086, 0x4000, "Intel 5400", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_E5400},
    {0, 0, 0, 0x8086, 0x4001, "Intel 5400A", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_E5400},
    {0, 0, 0, 0x8086, 0x4003, "Intel 5400B", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_E5400},
    {0, 0, 0, 0x8086, 0x25C0, "Intel 5000X", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5000},
    {0, 0, 0, 0x8086, 0x25C8, "Intel 5000P", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5000},
    {0, 0, 0, 0x8086, 0x25D0, "Intel 5000Z", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5000},
    {0, 0, 0, 0x8086, 0x25D4, "Intel 5000V", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5000},
    {0, 0, 0, 0x8086, 0x25D8, "Intel 5000P", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5000},

    {0, 0, 0, 0x8086, 0x65C0, "Intel 5100", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i5100},

    {0, 0, 0, 0x8086, 0x3600, "Intel 7300", 0, poll_fsb_nothing /* poll_fsb_5400 */, NULL /* poll_timings_5400 */, setup_E5400, poll_i7300},

    {0, 0, 0, 0x8086, 0x5020, "Intel EP80579", 0, poll_fsb_nothing /* poll_fsb_p4 */, NULL /* poll_timings_EP80579 */, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x8100, "Intel US15W", 0, poll_fsb_nothing /* poll_fsb_us15w */, NULL /* poll_timings_us15w */, setup_nothing, poll_nothing},
    {0, 0, 0, 0x8086, 0x8101, "Intel UL11L/US15L", 0, poll_fsb_nothing /* poll_fsb_us15w */, NULL /* poll_timings_us15w */, setup_nothing, poll_nothing},

    {0, 0, 0, 0x8086, 0x0100, "Intel Sandy Bridge", 0, poll_fsb_nothing, poll_timings_e3sb, setup_e3sb, poll_e3sb, poll_temp_e3sb},
    {0, 0, 0, 0x8086, 0x0104, "Intel Sandy Bridge", 0, poll_fsb_nothing, poll_timings_e3sb, setup_e3sb, poll_e3sb, poll_temp_e3sb},
    {0, 0, 0, 0x8086, 0x0108, "Intel Sandy Bridge", 0, poll_fsb_nothing, poll_timings_e3sb, setup_e3sb, poll_e3sb, poll_temp_e3sb},

    {0, 0, 0, 0x8086, 0x0150, "Intel Ivy Bridge", 0, poll_fsb_nothing, poll_timings_e3ib, setup_e3sb, poll_e3sb, poll_temp_e3sb},
    {0, 0, 0, 0x8086, 0x0154, "Intel Ivy Bridge", 0, poll_fsb_nothing, poll_timings_e3ib, setup_e3sb, poll_e3sb, poll_temp_e3sb},
    {0, 0, 0, 0x8086, 0x0158, "Intel Ivy Bridge", 0, poll_fsb_nothing, poll_timings_e3ib, setup_e3sb, poll_e3sb, poll_temp_e3sb},

    {0, 0, 0, 0x8086, 0x0C00, "Intel Haswell", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_e3haswell, poll_e3haswell, poll_temp_e3haswell},
    {0, 0, 0, 0x8086, 0x0C04, "Intel Haswell", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_e3haswell, poll_e3haswell, poll_temp_e3haswell},
    {0, 0, 0, 0x8086, 0x0C08, "Intel Haswell", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_e3haswell, poll_e3haswell, poll_temp_e3haswell},
    {0, 0, 0, 0x8086, 0x0D04, "Intel Haswell", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_e3haswell, poll_e3haswell, poll_temp_e3haswell},

    {0, 0, 0, 0x8086, 0x1604, "Intel Broadwell-U", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_broadwell_h, poll_broadwell_h, poll_temp_broadwell_h},

    {0, 0, 0, 0x8086, 0x1610, "Intel Broadwell-H", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_broadwell_h, poll_broadwell_h, poll_temp_broadwell_h},
    {0, 0, 0, 0x8086, 0x1614, "Intel Broadwell-H", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_broadwell_h, poll_broadwell_h, poll_temp_broadwell_h},
    {0, 0, 0, 0x8086, 0x1618, "Intel Broadwell-H", 0, poll_fsb_nothing, poll_timings_e3haswell, setup_broadwell_h, poll_broadwell_h, poll_temp_broadwell_h},

    {0, 0, 0, 0x8086, 0x1900, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x1904, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x1908, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x190c, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x190f, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x1910, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x1918, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},
    {0, 0, 0, 0x8086, 0x191f, "Intel Skylake", 0, poll_fsb_nothing, poll_timings_skylake, setup_skylake, poll_skylake, poll_temp_skylake},

    {0, 0, 0, 0x8086, 0x5900, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x5904, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x590C, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x590F, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x5910, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x5918, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},
    {0, 0, 0, 0x8086, 0x591F, "Intel Kaby Lake", 0, poll_fsb_nothing, poll_timings_skylake, setup_kabylake, poll_kabylake, poll_temp_kabylake},

    {0, 0, 0, 0x8086, 0x3e0f, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e10, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e12, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e18, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e1f, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e20, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e30, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e31, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e32, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3e33, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3ec2, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3ec4, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3ec6, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3eca, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3ecc, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x3ed0, "Intel Coffee Lake", 0, poll_fsb_nothing, poll_timings_coffeelake, setup_coffeelake, poll_coffeelake, NULL, decode_coffeelake},

    {0, 0, 0, 0x8086, 0x9b33, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake}, // TODO: Add inter/intra channel, dimm and hash MMIO registers to cometlake setup
    {0, 0, 0, 0x8086, 0x9b43, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b44, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b51, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b53, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b54, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b61, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b63, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b64, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b71, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},
    {0, 0, 0, 0x8086, 0x9b73, "Intel Comet Lake", 0, poll_fsb_nothing, poll_timings_cometlake, setup_cometlake, poll_cometlake, NULL, decode_coffeelake},

    {0, 0, 0, 0x8086, 0x8A00, "Intel Ice Lake", 0, poll_fsb_nothing, poll_timings_icelake, setup_icelake, poll_icelake, NULL, decode_icelake},
    {0, 0, 0, 0x8086, 0x8A02, "Intel Ice Lake", 0, poll_fsb_nothing, poll_timings_icelake, setup_icelake, poll_icelake, NULL, decode_icelake},
    {0, 0, 0, 0x8086, 0x8A10, "Intel Ice Lake", 0, poll_fsb_nothing, poll_timings_icelake, setup_icelake, poll_icelake, NULL, decode_icelake},
    {0, 0, 0, 0x8086, 0x8A12, "Intel Ice Lake", 0, poll_fsb_nothing, poll_timings_icelake, setup_icelake, poll_icelake, NULL, decode_icelake},

    {0, 0, 0, 0x8086, 0x9a02, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a04, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a12, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a14, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a16, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a1a, "Intel Tiger Lake", 0, poll_fsb_nothing, poll_timings_tigerlake, setup_tigerlake, poll_tigerlake},
    {0, 0, 0, 0x8086, 0x9a26, "Intel Tiger Lake H", 0, poll_fsb_nothing, poll_timings_tigerlake_h, setup_tigerlake_h, poll_tigerlake_h},
    {0, 0, 0, 0x8086, 0x9a36, "Intel Tiger Lake H", 0, poll_fsb_nothing, poll_timings_tigerlake_h, setup_tigerlake_h, poll_tigerlake_h},

    {0, 0, 0, 0x8086, 0x4c43, "Intel Rocket Lake", 0, poll_fsb_nothing, poll_timings_rocketlake, setup_rocketlake, poll_rocketlake, NULL, decode_rocketlake},
    {0, 0, 0, 0x8086, 0x4c53, "Intel Rocket Lake", 0, poll_fsb_nothing, poll_timings_rocketlake, setup_rocketlake, poll_rocketlake, NULL, decode_rocketlake},
    {0, 0, 0, 0x8086, 0x4c63, "Intel Rocket Lake", 0, poll_fsb_nothing, poll_timings_rocketlake, setup_rocketlake, poll_rocketlake, NULL, decode_rocketlake},

    {0, 0, 0, 0x8086, 0x4601, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4602, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4609, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x460A, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4619, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x461A, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4621, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4623, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4629, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x462B, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4641, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4648, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4649, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4650, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4660, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4668, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4670, "Intel Alder Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},

    {0, 0, 0, 0x8086, 0x4617, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x461B, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x461C, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4675, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4674, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4678, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4679, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4614, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4632, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4673, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4677, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x467C, "Intel Alder Lake-N", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},

    {0, 0, 0, 0x8086, 0x4610, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4630, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4637, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x463B, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x463C, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4640, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4647, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0x4692, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},

    {0, 0, 0, 0x8086, 0xA700, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA702, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA703, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA704, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA705, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA706, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA707, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA708, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA709, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA70A, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA710, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA711, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA712, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA713, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA716, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA719, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA71B, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA71C, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA728, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA729, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA72A, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA73B, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA740, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA741, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA744, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},
    {0, 0, 0, 0x8086, 0xA745, "Intel Raptor Lake", 0, poll_fsb_nothing, poll_timings_alderlake, setup_alderlake, poll_alderlake, NULL, decode_alderlake},

    {0, 0, 0, 0x8086, 0x7D00, "Intel Meteor Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D01, "Intel Meteor Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D02, "Intel Meteor Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D14, "Intel Meteor Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D16, "Intel Meteor Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},

    {0, 0, 0, 0x8086, 0x7D05, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D1A, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D1B, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D1C, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D26, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D27, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D2A, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D2D, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},
    {0, 0, 0, 0x8086, 0x7D2F, "Intel Arrow Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},

    {0, 0, 0, 0x8086, 0x6400, "Intel Lunar Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},

    {0, 0, 0, 0x8086, 0x6400, "Intel Lunar Lake", 0, poll_fsb_nothing, poll_timings_meteorlake, setup_meteorlake, poll_meteorlake, NULL, decode_meteorlake},

    // Intel Atom E3800 SOC
    {0, 0, 0, 0x8086, 0x0f00, "Intel Atom E3800 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_e3800atom, poll_e3800atom},

    // Intel Atom C2000 SOC
    {0, 0, 0, 0x8086, 0x1f00, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f01, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f02, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f03, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f04, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f05, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f06, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f07, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f08, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f09, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0a, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0b, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0c, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0d, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0e, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},
    {0, 0, 0, 0x8086, 0x1f0f, "Intel Atom C2000 SoC Transaction Router", 0, poll_fsb_nothing, NULL, setup_c2000atom, poll_c2000atom},

    {0, 0, 0, 0x8086, 0x1980, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1981, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1982, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1983, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1984, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1985, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1986, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1987, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1988, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1989, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198a, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198b, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198c, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198d, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198e, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x198f, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1990, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1991, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1992, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1993, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1994, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1995, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1996, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1997, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1998, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x1999, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199a, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199b, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199c, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199d, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199e, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},
    {0, 0, 0, 0x8086, 0x199f, "Intel Atom C3000 System Agent", 0, poll_fsb_nothing, NULL, setup_c3000atom, poll_c3000atom},

    {0, 0, 0, 0x8086, 0x5AF0, "Intel Apollo Lake SoC", 0, poll_fsb_nothing, NULL, setup_apollolake, poll_apollolake},

    {0, 0, 0, 0x8086, 0x4502, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4504, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4506, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4508, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x450A, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x450C, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x450E, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4510, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4512, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x451E, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4514, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4516, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4518, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x451A, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4520, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4522, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4524, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4526, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4528, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x452A, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x452C, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x452E, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4530, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4532, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4534, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4536, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x4538, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},
    {0, 0, 0, 0x8086, 0x453A, "Intel Elkhart Lake", 0, poll_fsb_nothing, poll_timings_elkhartlake, setup_elkhartlake, poll_elkhartlake},

    {0x1f, 3, 0, 0x8086, 0x2c18, "Intel Nehalem", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x1f, 3, 0, 0x8086, 0x2c98, "Intel Lynnfield", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x1f, 3, 0, 0x8086, 0x2d98, "Intel Westmere", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},

    {0x1f, 15, 0, 0x8086, 0x3ca8, "Intel Sandy Bridge-E", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5sb, poll_e5sb},
    {0x1f, 15, 0, 0x8086, 0x0ea8, "Intel Ivy Bridge-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},
    {0x1f, 29, 0, 0x8086, 0x0e68, "Intel Ivy Bridge-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},

    {0x1f, 19, 0, 0x8086, 0x2fa8, "Intel Haswell-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x1f, 19, 0, 0x8086, 0x6fa8, "Intel Broadwell-DE (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},
    {0x1f, 22, 0, 0x8086, 0x2f68, "Intel Haswell-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x1f, 22, 0, 0x8086, 0x6f68, "Intel Broadwell-DE (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},

    {0x3f, 3, 0, 0x8086, 0x2c18, "Intel Nehalem", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x3f, 3, 0, 0x8086, 0x2c98, "Intel Lynnfield", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x3f, 3, 0, 0x8086, 0x2d98, "Intel Westmere", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},

    {0x3f, 15, 0, 0x8086, 0x3ca8, "Intel Sandy Bridge-E", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5sb, poll_e5sb},
    {0x3f, 15, 0, 0x8086, 0x0ea8, "Intel Ivy Bridge-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},
    {0x3f, 29, 0, 0x8086, 0x0e68, "Intel Ivy Bridge-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},

    {0x3f, 19, 0, 0x8086, 0x2fa8, "Intel Haswell-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x3f, 19, 0, 0x8086, 0x6fa8, "Intel Broadwell-DE (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},
    {0x3f, 22, 0, 0x8086, 0x2f68, "Intel Haswell-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x3f, 22, 0, 0x8086, 0x6f68, "Intel Broadwell-DE (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},

    // Xeon Scalable 1st generation (Skylake-SP) and 2nd generation (Cascade Lake)
    {0x20, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x20, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x24, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x24, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x36, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x36, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x3a, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x3a, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x44, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x44, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x52, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x52, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x62, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x62, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x60, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x60, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x64, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x64, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x90, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0x90, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0xa2, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0xa2, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0xd1, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0xd1, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0xae, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0xae, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0xe2, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0xe2, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0xf1, 10, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},
    {0xf1, 12, 0, 0x8086, 0x2040, "Intel Skylake-SP (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, poll_timings_skylake_sp /* poll_timings_nhm */, setup_skylake_sp, poll_skylake_sp},

    {0x7f, 3, 0, 0x8086, 0x2c18, "Intel Nehalem", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x7f, 3, 0, 0x8086, 0x2c98, "Intel Lynnfield", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0x7f, 3, 0, 0x8086, 0x2d98, "Intel Westmere", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},

    {0x7f, 15, 0, 0x8086, 0x3ca8, "Intel Sandy Bridge-E", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5sb, poll_e5sb},
    {0x7f, 15, 0, 0x8086, 0x0ea8, "Intel Ivy Bridge-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},
    {0x7f, 29, 0, 0x8086, 0x0e68, "Intel Ivy Bridge-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},

    {0x7f, 19, 0, 0x8086, 0x2fa8, "Intel Haswell-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x7f, 19, 0, 0x8086, 0x6fa8, "Intel Broadwell-DE (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},
    {0x7f, 22, 0, 0x8086, 0x2f68, "Intel Haswell-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0x7f, 22, 0, 0x8086, 0x6f68, "Intel Broadwell-DE (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},

    {0xbf, 19, 0, 0x8086, 0x2fa8, "Intel Haswell-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0xbf, 22, 0, 0x8086, 0x2f68, "Intel Haswell-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},

    {0xff, 3, 0, 0x8086, 0x2c18, "Intel Nehalem", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0xff, 3, 0, 0x8086, 0x2c98, "Intel Lynnfield", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},
    {0xff, 3, 0, 0x8086, 0x2d98, "Intel Westmere", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_nhm, poll_nhm},

    {0xff, 15, 0, 0x8086, 0x3ca8, "Intel Sandy Bridge-E", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5sb, poll_e5sb},
    {0xff, 15, 0, 0x8086, 0x0ea8, "Intel Ivy Bridge-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},
    {0xff, 29, 0, 0x8086, 0x0e68, "Intel Ivy Bridge-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5ib, poll_e5ib},

    {0xff, 19, 0, 0x8086, 0x2fa8, "Intel Haswell-E (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0xff, 19, 0, 0x8086, 0x6fa8, "Intel Broadwell-DE (IMC 0)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},
    {0xff, 22, 0, 0x8086, 0x2f68, "Intel Haswell-E (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_e5haswell, poll_e5haswell},
    {0xff, 22, 0, 0x8086, 0x6f68, "Intel Broadwell-DE (IMC 1)", 0, poll_fsb_nothing /* poll_fsb_nhm */, NULL /* poll_timings_nhm */, setup_broadwell, poll_broadwell, poll_temp_broadwell, decode_broadwell},

    // Xeon Scalable 3rd generation (Ice Lake-SP) and 4th generation (Sapphire Rapids-SP)
    {0xfe, 12, 0, 0x8086, 0x344a, "Intel Ice Lake-SP", 0, poll_fsb_nothing, poll_timings_icelake_sp, setup_icelake_sp, poll_icelake_sp},

    // Xeon Scalable 5th generation (Emerald Rapids-SP)
    {0x7e, 12, 0, 0x8086, 0x324a, "Intel Emerald Rapids-SP", 0, poll_fsb_nothing, poll_timings_emeraldrapids_sp, setup_emeraldrapids_sp, poll_emeraldrapids_sp},
    {0xfe, 12, 0, 0x8086, 0x324a, "Intel Emerald Rapids-SP", 0, poll_fsb_nothing, poll_timings_emeraldrapids_sp, setup_emeraldrapids_sp, poll_emeraldrapids_sp},

    {0, 24, 2, 0x1022, 0x1102, "AMD K8", 0, poll_fsb_nothing /* poll_fsb_amd64 */, NULL /* poll_timings_amd64 */, setup_amd64, poll_amd64},
    {0, 24, 2, 0x1022, 0x1202, "AMD K10", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x1602, "AMD 15h", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x1532, "AMD 16h", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x1572, "AMD Merlin Falcon (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x1582, "AMD Steppe Eagle", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x141c, "AMD 15h (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_k10, setup_amd10h, poll_amd64},
    {0, 24, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 24, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 24, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 24, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 24, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 24, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 24, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 24, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 24, 2, 0x1022, 0x14AF, "AMD Ryzen Zen 4 (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen4_61h, poll_ryzen_zen4_61h, NULL, decode_ryzen_zen4_61h},
    {0, 24, 2, 0x1022, 0x14E2, "AMD Ryzen Zen 4 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen4_61h, poll_ryzen_zen4_61h, NULL, decode_ryzen_zen4_61h},
    {0, 24, 2, 0x1022, 0x14F2, "AMD Ryzen Zen 4 (78h-7bh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen4_78h, poll_ryzen_zen4_78h, NULL, decode_ryzen_zen4_78h},

    {0, 24, 2, 0x1022, 0x12C2, "AMD Ryzen Zen 5 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen5, setup_ryzen_zen5, poll_ryzen_zen5, NULL, decode_ryzen_zen5},

    {0, 24, 2, 0x1022, 0x114A, "AMD Ryzen Zen 5 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen5, setup_ryzen_zen5, poll_ryzen_zen5, NULL, decode_ryzen_zen5},
    {0, 24, 2, 0x1022, 0x124A, "AMD Ryzen Zen 5 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen5, setup_ryzen_zen5, poll_ryzen_zen5, NULL, decode_ryzen_zen5},

    {0, 24, 2, 0x1D94, 0x1462, "Hygon Dhyana (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 24, 2, 0x1D94, 0x15EA, "Hygon Dhyana (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 25, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 25, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 25, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 25, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 25, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 25, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 25, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 25, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 26, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 26, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 26, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 26, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 26, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 26, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 26, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 26, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 27, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 27, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 27, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 27, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 27, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 27, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 27, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 27, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 28, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 28, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 28, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 28, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 28, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 28, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 28, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 28, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 29, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 29, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 29, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 29, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 29, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 29, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 29, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 29, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 30, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 30, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 30, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 30, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 30, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 30, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 30, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 30, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

    {0, 31, 2, 0x1022, 0x1442, "AMD Ryzen Zen 2 (70h-7fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 31, 2, 0x1022, 0x144A, "AMD Ryzen Zen 2 (60h-6fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 31, 2, 0x1022, 0x1462, "AMD Ryzen (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},
    {0, 31, 2, 0x1022, 0x1492, "AMD Ryzen Zen 2 (30h-3fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 31, 2, 0x1022, 0x15EA, "AMD Ryzen (10h-1fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen, poll_ryzen},

    {0, 31, 2, 0x1022, 0x1652, "AMD Ryzen Zen 3 (0h-fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 31, 2, 0x1022, 0x167B, "AMD Ryzen Zen 3 (40h-4fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen_zen4, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},
    {0, 31, 2, 0x1022, 0x166c, "AMD Ryzen Zen 3 (50h-5fh)", 0, poll_fsb_nothing /*poll_fsb_k10 */, poll_timings_ryzen, setup_ryzen_zen2, poll_ryzen_zen2, NULL, decode_ryzen_zen2},

#if 0
    { 0,0,0, 0x8086, 0x3400, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing},
    { 0,0,0, 0x8086, 0x3401, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing},
    { 0,0,0, 0x8086, 0x3402, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing},
    { 0,0,0, 0x8086, 0x3403, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing},
    { 0,0,0, 0x8086, 0x3404, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing},
    { 0,0,0, 0x8086, 0x3405, "NHM IMC",                         0, poll_fsb_nothing /* poll_fsb_nhm */,     NULL /* poll_timings_nhm */, setup_nhm, poll_nothing}
#endif
};

#if 0
static void print_memory_controller(void)
{
    /* Print memory controller info */

    int d;

    char *name;
    if (ctrl.index == 0) {
        return;
    }

    /* Print the controller name */
    name = controllers[ctrl.index].name;
    col = 10;
    cprint(LINE_CPU + 5, col, name);
    /* Now figure out how much I just printed */
    while (name[col - 10] != '\0') {
        col++;
    }
    /* Now print the memory controller capabilities */
    cprint(LINE_CPU + 5, col, " "); col++;
    if (ctrl.cap == ECC_UNKNOWN) {
        return;
    }
    if (ctrl.cap & __ECC_DETECT) {
        int on;
        on = ctrl.mode & __ECC_DETECT;
        cprint(LINE_CPU + 5, col, "(ECC : ");
        cprint(LINE_CPU + 5, col + 7, on ? "Detect" : "Disabled)");
        on ? (col += 13) : (col += 16);
    }
    if (ctrl.mode & __ECC_CORRECT) {
        int on;
        on = ctrl.mode & __ECC_CORRECT;
        cprint(LINE_CPU + 5, col, " / ");
        if (ctrl.cap & __ECC_CHIPKILL) {
            cprint(LINE_CPU + 5, col + 3, on ? "Correct -" : "");
            on ? (col += 12) : (col += 3);
        }
        else {
            cprint(LINE_CPU + 5, col + 3, on ? "Correct)" : "");
            on ? (col += 11) : (col += 3);
        }
    }
    if (ctrl.mode & __ECC_DETECT) {
        if (ctrl.cap & __ECC_CHIPKILL) {
            int on;
            on = ctrl.mode & __ECC_CHIPKILL;
            cprint(LINE_CPU + 5, col, " Chipkill : ");
            cprint(LINE_CPU + 5, col + 12, on ? "On)" : "Off)");
            on ? (col += 15) : (col += 16);
        }
    }
    if (ctrl.mode & __ECC_SCRUB) {
        int on;
        on = ctrl.mode & __ECC_SCRUB;
        cprint(LINE_CPU + 5, col, " Scrub");
        cprint(LINE_CPU + 5, col + 6, on ? "+ " : "- ");
        col += 7;
    }
    if (ctrl.cap & __ECC_UNEXPECTED) {
        int on;
        on = ctrl.mode & __ECC_UNEXPECTED;
        cprint(LINE_CPU + 5, col, "Unknown");
        cprint(LINE_CPU + 5, col + 7, on ? "+ " : "- ");
        col += 9;
    }


    /* Print advanced caracteristics  */
    col2 = 0;
    d = get_key();
    /* if F1 is pressed, disable advanced detection */
    if (d != 0x3B) {
        controllers[ctrl.index].poll_fsb();
        controllers[ctrl.index].poll_timings();
    }
}
#endif

int find_mem_controller(void)
{
    unsigned long vendor = 0;
    unsigned long device = 0;

    int i;
    int result = -1;

    struct ecc_info ctrl;
    int maxctrls = 8;

    if (NeedBSODWorkaround())
        return 0;

    free_mem_controller();

    SetMem(&ctrl, sizeof(ctrl), 0);
    ctrl.bus = (unsigned int)-1;
    ctrl.dev = (unsigned int)-1;
    ctrl.fn = (unsigned int)-1;
    ctrl.index = 0;

    s_numctrls = 0;
    s_ctrl = (struct ecc_info *)AllocateZeroPool(sizeof(s_ctrl[0]) * maxctrls);
    if (s_ctrl == NULL)
    {
        AsciiFPrint(DEBUG_FILE_HANDLE, "find_mem_controller - error allocating memory");
        return 0;
    }

#if defined(WIN32) && !defined(_M_ARM) && !defined(_M_ARM64)
    get_cpuid(&cpu_id);
#endif

    // Enumerate through the database of memory controllers to see if we find a match
    for (i = 1; i < sizeof(controllers) / sizeof(controllers[0]); i++)
    {
        if (controllers[i].bus != ctrl.bus || controllers[i].dev != ctrl.dev || controllers[i].fn != ctrl.fn)
        {
            ctrl.bus = controllers[i].bus;
            ctrl.dev = controllers[i].dev;
            ctrl.fn = controllers[i].fn;

            result = pci_conf_read(ctrl.bus, ctrl.dev, ctrl.fn, PCI_VENDOR_ID, 2, &vendor);
            result = pci_conf_read(ctrl.bus, ctrl.dev, ctrl.fn, PCI_DEVICE_ID, 2, &device);
        }

        if (result == 0)
        {
            if ((controllers[i].vendor == vendor) && (controllers[i].device == device))
            {
                AsciiSPrint(gBuffer, BUF_SIZE, "find_mem_controller - found " MBSTRFMT " (%04X:%04X) at %d-%d-%d", controllers[i].name, controllers[i].vendor, controllers[i].device, controllers[i].bus, controllers[i].dev, controllers[i].fn);
                MtSupportDebugWriteLine(gBuffer);

                if (s_numctrls >= maxctrls)
                {
                    int newmaxctrls = maxctrls * 2;
                    UINTN OldBufSize = sizeof(s_ctrl[0]) * maxctrls;
                    UINTN NewBufSize = sizeof(s_ctrl[0]) * newmaxctrls;
                    VOID *NewBuf = ReallocatePool(OldBufSize, NewBufSize, (VOID *)s_ctrl);
                    if (NewBuf == NULL)
                    {
                        AsciiFPrint(DEBUG_FILE_HANDLE, "find_mem_controller - error expanding array (%d ->%d)", maxctrls, newmaxctrls);
                        break;
                    }
                    maxctrls = newmaxctrls;
                    s_ctrl = (struct ecc_info *)NewBuf;
                }

                s_ctrl[s_numctrls].bus = ctrl.bus;
                s_ctrl[s_numctrls].dev = ctrl.dev;
                s_ctrl[s_numctrls].fn = ctrl.fn;
                s_ctrl[s_numctrls].index = i;
                s_ctrl[s_numctrls].ctrlno = s_numctrls;

                s_numctrls++;
            }
        }
    }

#if 0       
    // AMD K8 use integrated mem controller, force detection
    if (cpu_id.vers.bits.family /*cpu_id.type*/ == 15 && cpu_id.vend_id.char_array[0] == 'A') { ctrl.index = 4; }

    // Same thing for K10. Detect by cpu_id.model = 2, will change it to ext.cpuid > 10 later
    if (cpu_id.vers.bits.family /*cpu_id.type*/ == 15 && cpu_id.vend_id.char_array[0] == 'A' && cpu_id.vers.bits.model /* cpu_id.model */ == 2) { ctrl.index = 5; }
#endif

    if (s_numctrls == 0)
    {
        MtSupportDebugWriteLine("find_mem_controller - Could not find controller, enumerating PCI bus...");

        // Enumerate the PCI bus
        Scan_PCI(PCI_A_SCAN, NULL, NULL);

        if (s_ctrl)
            FreePool(s_ctrl);
        s_ctrl = NULL;
    }
    else
    {
        for (i = 0; i < s_numctrls; i++)
        {
            controllers[s_ctrl[i].index].setup_ecc(&s_ctrl[i]);

            AsciiSPrint(gBuffer, BUF_SIZE, "find_mem_controller - " MBSTRFMT " (%04X:%04X) at %d-%d-%d",
                        controllers[s_ctrl[i].index].name, controllers[s_ctrl[i].index].vendor, controllers[s_ctrl[i].index].device, s_ctrl[i].bus, s_ctrl[i].dev, s_ctrl[i].fn);

            MtSupportDebugWriteLine(gBuffer);

            AsciiSPrint(gBuffer, BUF_SIZE, "find_mem_controller - " MBSTRFMT " (Ch mode: %d, ECC mode: {detect: " MBSTRFMT ", correct: " MBSTRFMT ", scrub: " MBSTRFMT ", chipkill: " MBSTRFMT ", IBECC: " MBSTRFMT "})",
                        controllers[s_ctrl[i].index].name,
                        s_ctrl[i].chmode,
                        s_ctrl[i].mode & __ECC_DETECT ? "yes" : "no",
                        s_ctrl[i].mode & __ECC_CORRECT ? "yes" : "no",
                        s_ctrl[i].mode & __ECC_SCRUB ? "yes" : "no",
                        s_ctrl[i].mode & __ECC_CHIPKILL ? "yes" : "no",
                        s_ctrl[i].mode & __ECC_INBAND ? "yes" : "no");

            MtSupportDebugWriteLine(gBuffer);

            /* Don't enable ECC polling by default unless it has
             * been well tested.
             */
            set_ecc_polling(i, -1);
            // print_memory_controller();
        }

        UINTN OldBufSize = sizeof(s_ctrl[0]) * maxctrls;
        UINTN NewBufSize = sizeof(s_ctrl[0]) * s_numctrls;
        VOID *NewBuf = ReallocatePool(OldBufSize, NewBufSize, (VOID *)s_ctrl);
        if (NewBuf == NULL)
        {
            AsciiFPrint(DEBUG_FILE_HANDLE, "find_mem_controller - error shrinking array (%d ->%d)", maxctrls, s_numctrls);
        }
        else
        {
            s_ctrl = (struct ecc_info *)NewBuf;
        }
    }
    return s_numctrls;
}

void free_mem_controller(void)
{
    if (s_ctrl)
    {
        for (int i = 0; i < s_numctrls; i++)
        {
            if (s_ctrl[i].userdata)
                FreePool(s_ctrl[i].userdata);
        }
        FreePool(s_ctrl);
    }
    s_ctrl = NULL;
    s_numctrls = 0;
}

void poll_errors(void)
{
    int i;
    for (i = 0; i < s_numctrls; i++)
    {
        if (s_ctrl[i].poll)
        {
            controllers[s_ctrl[i].index].poll_errors(&s_ctrl[i]);
        }
    }
}

int poll_temp(void)
{
    int i;
    int temp = -1;
    for (i = 0; i < s_numctrls; i++)
    {
        if (controllers[s_ctrl[i].index].poll_temp)
        {
            if (controllers[s_ctrl[i].index].poll_temp(&s_ctrl[i]) == 0)
            {
                int dimm = 0;
                for (dimm = 0; dimm < sizeof(s_ctrl[i].dimmtemp) / sizeof(s_ctrl[i].dimmtemp[0]); dimm++)
                {
                    if (temp < 0 && s_ctrl[i].dimmtemp[i] > 0 && s_ctrl[i].dimmtemp[i] < 200)
                        temp = s_ctrl[i].dimmtemp[i];
                }
            }
        }
    }
    return temp;
}

int decode_addr(unsigned long long addr, unsigned long long ebits, unsigned long esize, unsigned char form_factor, int *pskt, int *pch, int *pdimm, int *prank, int *pchip, int *pbank, int *prow, int *pcol, unsigned long long *subaddr)
{
#ifdef PRO_RELEASE // Address decoding available only in Pro version
    int i;
    for (i = 0; i < s_numctrls; i++)
    {
        if (controllers[s_ctrl[i].index].decode_addr)
        {
#ifdef SITE_EDITION // Chip decoding available only in Pro version
            return controllers[s_ctrl[i].index].decode_addr(&s_ctrl[i], addr, ebits, esize, form_factor, pskt, pch, pdimm, prank, pchip, pbank, prow, pcol, subaddr);
#else
            return controllers[s_ctrl[i].index].decode_addr(&s_ctrl[i], addr, ebits, esize, form_factor, pskt, pch, pdimm, prank, NULL, pbank, prow, pcol, subaddr);
#endif
        }
    }
#endif
    return -1;
}

void set_ecc_polling(int index, int val)
{
    if (index < 0 || index >= s_numctrls)
        return;

#if 0
    int tested = controllers[s_ctrl[i].index].tested;
    if (val == -1) {
        val = tested;
    }
#endif
    if (/* val && */ (s_ctrl[index].mode & ECC_ANY))
    {
        s_ctrl[index].poll = 1;
        MtSupportDebugWriteLine("ECC polling enabled");
#if 0
        cprint(LINE_INFO + 2, COL_INF3 - 3, tested ? " on" : " ON");
#endif
    }
    else
    {
        MtSupportDebugWriteLine("ECC polling disabled");
        s_ctrl[index].poll = 0;
#if 0
        cprint(LINE_INFO + 2, COL_INF3 - 3, "off");
#endif
    }
}

char *get_mem_ctrl_name()
{
    if (s_numctrls == 0)
        return "";

    return controllers[s_ctrl[0].index].name;
}

unsigned int get_mem_ctrl_cap()
{
    int i;
    unsigned int cap = 0;

    if (s_numctrls == 0)
        return ECC_UNKNOWN;

    for (i = 0; i < s_numctrls; i++)
        cap |= s_ctrl[i].cap;
    return cap;
}

unsigned int get_mem_ctrl_mode()
{
    int i;
    unsigned int mode = 0;

    if (s_numctrls == 0)
        return ECC_UNKNOWN;

    for (i = 0; i < s_numctrls; i++)
        mode |= s_ctrl[i].mode;
    return mode;
}

unsigned int get_mem_ctrl_channel_mode()
{
    if (s_numctrls == 0)
        return 0;

    int chmode = 0;
    for (int i = 0; i < s_numctrls; i++)
        chmode += s_ctrl[i].chmode;

    return chmode;
}

int get_mem_ctrl_num_channels()
{
    if (s_numctrls == 0)
        return 0;

    int numch = 0;
    for (int i = 0; i < s_numctrls; i++)
        numch += s_ctrl[i].numch;

    return numch;
}

int get_mem_ctrl_num_dimms_per_channel()
{
    if (s_numctrls == 0)
        return 0;

    return s_ctrl[0].numsl;
}

int get_mem_ctrl_num_slots()
{
    if (s_numctrls == 0)
        return 0;

    int numsl = 0;
    for (int i = 0; i < s_numctrls; i++)
        numsl += s_ctrl[i].numch * s_ctrl[i].numsl;

    return numsl;
}

unsigned char get_mem_ctrl_num_ranks(unsigned int dimm)
{
    if (s_numctrls == 0)
        return 0;

    int sl_per_mc = s_ctrl[0].numch * s_ctrl[0].numsl;

    if (sl_per_mc == 0)
        return 0;

    int ctrlidx = sl_per_mc > 0 ? dimm / sl_per_mc : 0;

    if (ctrlidx >= s_numctrls)
        return 0;

    int dimmidx = dimm % sl_per_mc;

    if (dimmidx >= MAX_UMC * MAX_SLOTS_PER_UMC)
        return 0;

    return s_ctrl[ctrlidx].numranks[dimmidx];
}

unsigned char get_mem_ctrl_chip_width(unsigned int dimm)
{
    if (s_numctrls == 0)
        return 0;

    int sl_per_mc = s_ctrl[0].numch * s_ctrl[0].numsl;

    if (sl_per_mc == 0)
        return 0;

    int ctrlidx = sl_per_mc > 0 ? dimm / sl_per_mc : 0;

    if (ctrlidx >= s_numctrls)
        return 0;

    int dimmidx = dimm % sl_per_mc;

    if (dimmidx >= MAX_UMC * MAX_SLOTS_PER_UMC)
        return 0;

    return s_ctrl[ctrlidx].chipwidth[dimmidx];
}

int get_mem_ctrl_decode_supported()
{
    if (s_numctrls == 0)
        return 0;

    return controllers[s_ctrl[0].index].decode_addr != NULL;
}

int get_mem_ctrl_timings(unsigned int *memclk, unsigned int *ctrlclk, unsigned char *cas, unsigned char *rcd, unsigned char *rp, unsigned char *ras)
{
    unsigned int memspeed = 0;
    if (s_numctrls == 0)
        return -1;

    for (int i = 0; i < s_numctrls; i++)
    {
        if (controllers[s_ctrl[i].index].poll_timings == NULL)
            continue;

        controllers[s_ctrl[i].index].poll_timings(&s_ctrl[i]);

        if (s_ctrl[i].chmode > 0)
        {
            if (memclk)
                *memclk = s_ctrl[i].memclk;

            memspeed = s_ctrl[i].memclk * 2;

            if (ctrlclk)
                *ctrlclk = s_ctrl[i].ctrlclk;

            if (cas)
                *cas = s_ctrl[i].tAA;

            if (rcd)
                *rcd = s_ctrl[i].tRCD;

            if (rp)
                *rp = s_ctrl[i].tRP;

            if (ras)
                *ras = s_ctrl[i].tRAS;
        }
        AsciiFPrint(DEBUG_FILE_HANDLE, "get_mem_ctrl_timings - [%d-%d-%d] %d MT/s (%d-%d-%d-%d)", s_ctrl[i].bus, s_ctrl[i].dev, s_ctrl[i].fn, s_ctrl[i].memclk * 2, s_ctrl[i].tAA, s_ctrl[i].tRCD, s_ctrl[i].tRP, s_ctrl[i].tRAS);
    }

    // Adjust for rounding errors
    int rem = memspeed % 100;
    if (rem >= 63 && rem <= 69) // round to 67
    {
        memspeed -= rem + 67;
    }
    else if (rem >= 30 && rem <= 36) // round to 33
    {
        memspeed -= rem + 33;
    }

    return memspeed > 0 ? 0 : -1;
}
